package elvira.tools.statistics.miscellany;import java.util.Vector;public class dataSet {	public double [][] X;	public String [] names;	public int n,k;	String description;	/**	 * Constructor of data set, vector data keeps n observations of K variables' data;	 * vector vn keeps K variable's string names.	 */	public dataSet(int n, int k,Vector vn, Vector data) {		X = new double[n][k];		names = new String[k];		this.n=n;		this.k=k;		for (int i=0;i<n;i++) {			X[i] = (double []) data.elementAt(i);		}		for (int i=0;i<k;i++) {			names[i] = (String) vn.elementAt(i);		}	}		/**	 * Constructor of data set, X[][] keeps n observations of K variables' data;	 * names keeps K variable's string names.	 */	public dataSet(String [] names, double [][] X) {		this.names=names;		this.X=X;		n=X.length;		k=X[0].length;			}		/**	 * Return a boolean variable group variable v[i] true if:	 * 1. range is between 0 to 15;	 * 2. min =1 and min<>max	 * 3. every number between min and max show up once in this variable's observation.	 */	public boolean [] grouping() {		boolean [] r = new boolean[k];		double max,min;		for (int i=0;i<k;i++) {						r[i]=true;			max = X[0][i];			min = max;						for (int j=0;j<n;j++) {				//System.out.println("--- " + j + " " + i + " " + X[j][i]);				max = Math.max(max,X[j][i]);				min = Math.min(min,X[j][i]);				if ((X[j][i] <0) || (X[j][i] > 15) || (Math.rint(X[j][i]) != X[j][i])) {					r[i] = false;					break;				}			}			if (r[i]) {				if((min != 1.0) || (min==max)) {					r[i]=false;				}			}			if (r[i]) {				int ncat = (int) max;				int [] check = new int[ncat];				for (int j=0;j<ncat;j++) {					check[j]=1;				}				int sum = 0;				for (int j=0;j<n;j++) {					int v = (int) X[j][i];				//System.out.println("v= " + v);					sum+= check[v-1];					check[v-1]=0;				}				if(sum != max) r[i] = false;			}			/*			if (r[i]) {				System.out.println("passed test");			}			else {				System.out.println("sum not equal to max");			}			*/			}		return r;	}				/**	 * According to the string name, find out the variable index	 */ 			int getIndexFromName(String vname) {		int L=-1;		for (int i=0;i<k;i++) {			if (names[i].equals(vname)) {					L=i;					break;			}		}		return L;	}		/** 	 * According to the variable's index, return a double array which contains that	 * variable's observation.	 */	public double [] getVar(int L) {		double [] Z = new double[n];		for (int i=0;i<n;i++) {			Z[i] = X[i][L];		}		return Z;	}		/** 	 * According to the variable's name, return a double array which contains that	 * variable's observations.	 */		public double [] getVar(String s) {		int L =	getIndexFromName(s);		return getVar(L);	}		/** 	 * According to the variables' names, return a two-dimensional double array which contains	 * the required variables' observations.	 */	public double [][] getVars(String [] s) {		int L = s.length;		int v[] = new int[L];		for (int i=0;i<L;i++) {			v[i] = getIndexFromName(s[i]);		}		return getVars(v);	}		/** 	 * According to the variables' indexes, return a two-dimensional double array which contains	 * the required variables' observations.	 */	public double[][] getVars(int [] v) {		int nv = v.length;		double [][] Z = new double [nv][n];		for (int i=0;i<n;i++) {			for (int j=0;j<nv;j++) {				int L=v[j];				Z[j][i]= X[i][L];			}		}		return Z;	}		/** 	 * According to the variable's name, return a maximum observation for that variable.	 */	public int getMaxLevel(String vname) {		int L = getIndexFromName(vname);		int m = getMaxLevel(L);		return m;	}		/** 	 * According to the variable's index, return a maximum observation for that variable.	 */	public int getMaxLevel(int L) {				if (L==-1) return 0;		double m = X[0][L];		for (int i=1;i<n;i++) {			m = Math.max(m,X[i][L]);		}		return (int) Math.rint(m);	}		/** 	 * According to the variable's index, return the frequency of each observation.	 */	int [] nPerCell(int LL) {		int ncell=getMaxLevel(LL);		int[] nn = new int[ncell];		for (int i=0;i<n;i++){			int index = (int) X[i][LL]-1;			nn[index]++;					}		return nn;	}		public double [][] getGroups(String g, String x) {		int LL=getIndexFromName(g);		int v=getIndexFromName(x);		return getGroups(LL,v);	}		/**	 * According to the first variable's index, find out the corresponding observations of the second	 * variable(according to the second variable's index), sort by the first variable's order, 	 * one-to-one store the pairs of data into a two-dimensional array G and return that array.	 */	public double [][] getGroups(int  LL, int v) {		int [] nn = nPerCell(LL);		int k = nn.length;		int [] count = new int[k];		double [][] G = new double[k][];		for (int i=0;i<k;i++) {			 G[i] = new double[nn[i]];		}		for (int i=0;i<n;i++) {			int index = (int) X[i][LL]-1;			G[index][count[index]]=X[i][v];			count[index]++;		}		return G;	}						/**	 * Summary of the dataset information, includes # of observations, # of variables, variable	 * names, and the actual observations for each variable.	 */	public String toString() {		String s= "Number of obs = " + n + "\n";		s+= "Number of var = " + k + "\n";		s+="Variable names: ";				for (int i=0;i<k;i++) {			s+=names[i] + " " ;		}		s+="\n";				for (int i=0;i<n;i++) {			for(int j=0;j<k;j++) {				s+= X[i][j] + " ";			}			s+="\n";		}				return s;	}		public void setDescription(String description) {		this.description=description;	}		public String getDescription() {		return description;	}		}