package elvira.tools.statistics.analysis;public class genBivariate {	double mean,sd,slope,seEst,inter;	int N;	double [] X,e;	boolean zcode=false;	boolean sdzCode=false;		/**	 * Generates bivariate data with specified mean, standard deviation, slope, intercept,	 * standard error of estimate sample size. Mean and sd of X and Y are the same.	 *	 * @param N			sample size	 * @param _mean		mean	 * @param _sd		standard deviation	 * @param _slope	slope	 * @param _inter	line intercept	 * @param _seEst	standard error of estimate	 *	 */	public genBivariate (int _N, double _mean,double _sd,double _slope, double _inter,	                      double _seEst) {			mean = _mean;sd=_sd;slope=_slope;inter=_inter;seEst=_seEst;N=_N;		e= new double[N];		X= new double[N];		double sum=0, ssq=0, meane=0, ssqe=0;		int N2=N/2;		for (int i = 0;i<N2;i++){			X[i] = Math.random();			e[i] = Math.random();			sum += X[i];			ssq+= X[i]*X[i];				meane+=e[i];		//System.out.println(T[i][0] + " " + e[i]);			}		//double meanX = mean - sum/N2;		meane /=N2;		for (int i = 0;i<N2;i++){				//X[i]+=meanX;				X[i+N2] = -X[i];			ssq+= X[i]*X[i];			e[i]-=meane;			e[i+N2] = e[i];			ssqe+=	e[i]*e[i];		//System.out.println(T[i][0] + " " + e[i]);				}		ssqe*=2;		double sd1 = Math.sqrt(ssq/N);		double sde = Math.sqrt(ssqe/N);		double sdAdj = sd/sd1;		double sdAdje = seEst/sde;		//System.out.println("-----------");		//Date d1 = new Date();		for (int i = 0;i<N;i++){				X[i]*=sdAdj;         //X adjusted for sd1			X[i]+=mean;			e[i]*=sdAdje;		 //e ajusted for sde		}		//Date d2 = new Date();		//System.out.println(d2.getTime() - d1.getTime());	}	/**	 * Returns the Y data	 * 	 * @return 		y	 */	public double [] getY() {		double [] y = new double[N];			//System.out.println("-----------xx");				if (!zcode) {				for (int i = 0;i<N;i++){				y[i] = slope*X[i] + inter + e[i];				//System.out.println(": " + X[i] + " " + e[i] + " " + y[i]);				}		}		else {			for (int i = 0;i<N;i++){				y[i] = slope*X[i] + inter;				}		}				return y;	}	/**	 * Returns the X data	 * 	 * @return 		X	 */	public double [] getX() {		return X;	}	/**	 * Sets standard error of estimate	 *	 * @param _seEst	standard error of estimate 	 */	public void setSeEst(double _seEst) {		if (_seEst >0) {			double sdAdje = _seEst/seEst;			for (int i = 0;i<N;i++){					e[i]*=sdAdje;			}			zcode=false;			seEst=_seEst;		}		else {			zcode=true;		}			}	/**	 * Sets slope	 *	 * @param _slope	slope 	 */	public void setSlope(double _slope) {		slope=_slope;	}	/**	 * Returns standard deviation	 * 	 * @return 		sd	 */	public double getsd() {		return sd;	}	/**	 * Sets standard deviation	 *	 * @param _sd	standard deviation, data adjusted for the setting sd	 */	public void setsd(double _sd) {		if(_sd <= 0) _sd= .0001;		double sdAdj = _sd/sd;		for (int i=0;i<N;i++) {			X[i]*=sdAdj;		}		sd=_sd;	}			}			