package elvira.tools.statistics.anova;public class twoanov{	double[] meanAB;	double[] meanA;	double[] meanB;		String A = "A";	String B = "B";			double[] ssA = new double[3];	double[] ssB = new double[3];	double ssG,ssAB,ssE,ssTOT, ssAu,ssBu,ssABu, ssABc,ssAABc,ssBABc, ssABABc;	double sumA, sumB, sumG, sumTOT, grandMean; 	int sumNA=0, sumNB=0, grandN=0;			      			int dA,dB,dAB,dG,dE,dTOT;						probFandT probFandT1;		/**	 *class constructor.	 */	public twoanov() {	}			/**	 *setData for fixed sample size in each factor combination group.	 */	public void setData(double[][][] d, int NA, int NB, int NC)	{		int [][] n = new int[NA][NB];				for (int i=0;i<NA;i++)		for (int j=0;j<NB;j++)			n[i][j] = NC;				setData(d, n, NA, NB);		}		/**	 *setData for variable sample sizes in each factor combination group.	 */	public void setData(double[][][] d)	{					int NA = d.length;		int NB = d[NA-1].length;				int [][] n = new int[NA][NB];				for (int i=0;i<NA;i++)		for (int j=0;j<NB;j++)			n[i][j] = d[i][j].length;			setData(d, n, NA, NB);		}		public void setSouceName(String A, String B)	{		this.A = A;		this.B = B;	}					/**	 * setData for fixed 2x3 two-way factorial design. C matrix is the orthogonal contrast	 * matrix to  calculate Type I, II & III ANOVA results.	 * Using control matrix I, the reductions of sum square errors can be calculated from different hypothese	 * used for different types of ANOVA anayses. This is done by including proper contrasts in the regression	 * method to see the residual SS caused by related factors.	 */	public void setData(double[][][] d, int[][] n, int NA, int NB)	{			int i,j,k;		double cmean;	 		 		 	if ((NA==2) & (NB==3))	 	{	 		meanAB = new double[NA*NB];	 		meanA = new double[NA];	 		meanB = new double[NB];		 			 		double[][] c = new double[6][5];	 			 		double[] c0 = { 1, 2, 0, 2, 0};	 		double[] c1 = { 1,-1, 1,-1, 1};	 		double[] c2 = { 1,-1,-1,-1,-1};	 		double[] c3 = {-1, 2, 0,-2, 0};	 		double[] c4 = {-1,-1, 1, 1,-1};	 		double[] c5 = {-1,-1,-1, 1, 1};	 			 		c[0] = c0;	 		c[1] = c1;	 		c[2] = c2;	 		c[3] = c3;	 		c[4] = c4;	 		c[5] = c5;	 			 		ssG = 0.0;	 		for (i=0; i<NA; i++)			for (j=0; j<NB; j++)			{				sumG = 0.0;	 				 			for (k=0; k<n[i][j]; k++) sumG = sumG + d[i][j][k];	 			 			if (n[i][j] > 0)	 			{	 				ssG = ssG + sumG*sumG/n[i][j];	 				meanAB[i*3+j] = sumG/n[i][j]; 	 			}		 		}	 			 		ssTOT=0.0;	 		sumTOT = 0.0;	 		grandN = 0;	 		for (i=0; i<NA; i++)	 		for (j=0; j<NB; j++)	 		for (k=0; k<n[i][j]; k++)	 		{	 			sumTOT = sumTOT + d[i][j][k];	 			ssTOT = ssTOT + d[i][j][k]*d[i][j][k];	 			grandN = grandN +1;	 		}				 		 		grandMean = sumTOT/grandN;	 		ssTOT = ssTOT - sumTOT*sumTOT/grandN;	 		ssG = ssG - sumTOT*sumTOT/grandN;		 		ssE = ssTOT - ssG; 					 			 		double[][] X = new double[grandN][5];	 		double[] Y = new double[grandN];	 			 		k=0;	 		for (i=0; i<NA; i++)	 		for (j=0; j<NB; j++)	 		for (int ii=0; ii<n[i][j]; ii++)	 		{				X[k] = c[i*3+j];				Y[k] = d[i][j][ii];//-grandMean;				k=k+1;			}	 				 			 		for (i=0; i<3; i++)			{				ssA[i] = 0.0;				ssB[i] = 0.0;			}						ssAB= 0.0;				 		int[] I1    = {1,0,0,0,0}; //factor A only	 		int[] I123  = {1,1,1,0,0}; //factor A and B	 		int[] I23   = {0,1,1,0,0}; //factor B only	 		int[] I2345 = {0,1,1,1,1}; //factor B and AB	 		int[] I145  = {1,0,0,1,1}; //factor A and AB	 		int[] I45   = {0,0,0,1,1}; //factor AB	 		int[] I12345= {1,1,1,1,1}; //factor A, B and AB	 		 			 		regResults r1     = RegAllTypes.ss(X, Y, I1);	 		regResults r123   = RegAllTypes.ss(X, Y, I123);	 			 		regResults r23    = RegAllTypes.ss(X, Y, I23); 	 		regResults r2345  = RegAllTypes.ss(X, Y, I2345);	 		regResults r145   = RegAllTypes.ss(X, Y, I145);	 		regResults r12345 = RegAllTypes.ss(X, Y, I12345);	 		regResults r45    = RegAllTypes.ss(X, Y, I45);	 			 			 		//sum of squares all adjusted for y*y/N	 		double ss1     = r1.rsq;   			double ss123   = r123.rsq;   			double ss23    = r23.rsq;   			double ss2345  = r2345.rsq;   			double ss145   = r145.rsq;   			double ss12345 = r12345.rsq;   			double ss45    = r45.rsq;   				 		ssA[0] = ss1;				//Type I	 		ssB[0] = ss123 - ss1;	 			 		ssA[1] = ss123 - ss23;      //Type II	 		ssB[1] = ssB[0];	 			 		ssA[2] = ss12345 - ss2345;  //Type III	 		ssB[2] = ss12345 - ss145;	 			 		ssAB = ss12345- ss123;      // interaction AB is same for all three types	 			 		ssAu   = ssA[2]; //commonality of unique A, B, and AB, same as Type III ssA, ssB and ssAB	 		ssBu   = ssB[2];	 		ssABu  = ssAB;	 			 		ssABc  = ss145 + ss2345 - ss12345 - ss45; //commonality of A*B, A*AB, B*AB	 		ssAABc = ss123 + ss2345 - ss12345 - ss23;	 		ssBABc = ss123 + ss145  - ss12345 - ss1;	 			 		ssABABc = ss1+ss23+ss45-ss123-ss145-ss2345+ss12345; //commonality of A*B*AB	 				 		dA = NA - 1;	 		dB = NB - 1;	 		dAB = (NA-1)*(NB-1);	 		dG = NA*NB - 1;	 		dE = grandN - NA*NB;	 		dTOT = grandN - 1;	 			 	}	 	else	 	{	 		clearData();	 		System.out.println("This two-way-anova is for 2x3 factorial design only, your NA="+NA+" NB="+NB);	 			 	}		 			 							}			public void clearData()	{		for (int i=0; i<3; i++)		{			ssA[i] = 0.0;			ssB[i] = 0.0;		}					ssG = 0.0;		ssAB= 0.0;		ssE = 0.0;		ssTOT =0.0;					 	grandN = 0;	 		 	dA=1;	 	dB=2;	 	dAB=2;	 	dG=5;	 	dE=0;	 	dTOT=0;	}											public double[] getMeanA()	{ 		return meanA;	}		public double[] getMeanB()	{ 		return meanB;	}	  		public double[] getMeanAB()	{ 		return meanAB;	}		public String getSourceA()	{		return(A);	}		public String getSourceB()	{		return(B);	}			public int getdA()	{		return dA;	}			public int getdB()	{		return dB;	}		public int getdAB()	{		return dAB;	}		public int getdG()	{		return dG;	}		public int getdE()	{		if (dE<0)		return 0;		else		return dE;	}		public int getdTOT()	{		if (dTOT<0)		return 0;		else		return dTOT;	}		public double getSSA(int ind)	{		return ssA[ind-1];	}		public double getSSB(int ind)	{		return ssB[ind-1];	}			public double getSSAB()	{		return ssAB;	}		public double getSSTOT()	{		return ssTOT;	}		public double getSSG()	{		return ssG;	}		public double getSSE()	{		return ssE;	}			public double getMSA(int ind)	{		if (dA <= 0) return 0;		else return (ssA[ind-1]/dA);	}		public double getMSB(int ind)	{		if (dB <= 0) return 0;		else return (ssB[ind-1]/dB);	}			public double getMSAB()	{		if (dAB <= 0) return 0;		else return (ssAB/dAB);	}		public double getMSG()	{		if (dG <= 0) return 0;		else return (ssG/dG);	}		public double getMSE()	{		if (dE <= 0) return 0;		else return (ssE/dE);	}				public double get_F_A(int ind)	{		if (Math.abs(getMSE() - 0) < 0.001) return 0;		else return( getMSA(ind)/getMSE() );		}		public double get_F_B(int ind)	{		if (Math.abs(getMSE() - 0) < 0.001) return 0;		else return( getMSB(ind)/getMSE() );		}		public double get_F_AB()	{		if (Math.abs(getMSE() - 0) < 0.001) return 0;		else return( getMSAB()/getMSE() );		}		public double get_F_G()	{		if (Math.abs(getMSE() - 0) < 0.001) return 0;		else return( getMSG()/getMSE() );		}		public double get_P_A(int ind)	{			if (Math.abs(get_F_A(ind)-0) < 0.001) return 1;		else		return ( probFandT1.probF( get_F_A(ind), dA, dE ) );		}			public double get_P_B(int ind)	{			if (Math.abs(get_F_B(ind)-0) < 0.001) return 1;		else		return ( probFandT1.probF( get_F_B(ind), dA, dE ) );		}		public double get_P_AB()	{			if (Math.abs(get_F_AB()-0) < 0.001) return 1;		else		return ( probFandT1.probF( get_F_AB(), dAB, dE ) );		}		public double get_P_G()	{			if (Math.abs(get_F_G()-0) < 0.001) return 1;		else		return ( probFandT1.probF( get_F_G(), dG, dE ) );		}		public double get_u_A()	{		return(ssAu);	}		public double get_u_B()	{		return(ssBu);	}			public double get_u_AB()	{		return(ssABu);	}		public double get_c_AB()	{		return(ssABc);	}		public double get_c_AAB()	{		return(ssAABc);	}		public double get_c_BAB()	{		return(ssBABc);	}		public double get_c_ABAB()	{		return(ssABABc);	}	}