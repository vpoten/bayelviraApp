package elvira.tools.statistics.anova;public class RegAllTypes{	/**	 * Class constructor. RegAllTypes can be used for polynomial regression, to	 * calculate the regression results according to the input dependent X matrix and	 * independent Y variables.	 */	public RegAllTypes() {	}		/**	 * If the input dependent variable ia an array, it is used to do polynomial regression.	 * The highest order of polynomial is stored in the I array. I could be linear {1,0,0},	 * quadratic {1,1,0} or cubic {1,1,1}	 */	public static regResults ss(double[] x, double[] y, int[] I) {		double[][] xx = new double[x.length][3];				for (int i=0; i< x.length; i++)		{			xx[i][0] = x[i];			xx[i][1] = x[i]*x[i];			xx[i][2] = x[i]*x[i]*x[i];		}				return(ss(xx, y, I));	}						/**	 * The input dependent variable xx is a matrix, the regression is y on xx.	 * Control array I controls the columns of xx matrix to be included in the	 * regression. The lines of xx matrix should be equal to the # of y observations;	 * the length of I array should be equal to the total columns of xx matrix, 	 * Otherwise the return regResults will only contain an error.	 * If all the inputs have the correct length and format, the regression results are	 * stored in regResults, include SS model, SS error, SS total, degree of freedoms of	 * model and error, and the coeffient array. The SS all are adjusted for Y*Y/N.	 */		public static regResults ss(double[][] xx, double[] y, int[] I) {		int i,j,k, err1=1, err2=2;		double ss, yy, sstotal;				i = xx.length;		j = xx[i-1].length;				if (i!=y.length) 		{ 			regResults rr = new regResults(err1); 			return(rr);		}				if (j!=I.length)		{			regResults rr = new regResults(err2); 			return(rr);		}	 		        				double[][] xxI = matrixUtil.Transpose(xx,i,j); //xxI:jxi				k=0;		for (int ii=0; ii<j; ii++)  //determine the real independent matrix X according to control array I		{			if (I[ii]==1) k=k+1;		}				//expand one more column for intercept 1 in X matrix				k=k+1;		double[][] xI = new double[k][i];					for (int ii=0; ii<i; ii++)		xI[0][ii] = 1.0;				k=1;		for (int ii=0; ii<j; ii++)		{			if (I[ii]==1)			{				xI[k] = xxI[ii];				k = k+1;			}		}				double[][] x = matrixUtil.Transpose(xI,k,i); //x=ixk		double[][] xtx = matrixUtil.XtY(x,x,i,k,k); //xtx=kxk		double[] xtxdim1 = matrixUtil.TwoOne(xtx, k);		double[] xtxdim1I = new double[k*(k+1)/2+1];		matrixUtil.syminv(xtxdim1, xtxdim1I,  k);		xtx = matrixUtil.OneTwo(xtxdim1I, k);				double[] xty = matrixUtil.Mtv(x, y, i, k);	//xty=kx1		double[] xtxIxty = matrixUtil.Mtv(xtx, xty, k, k);	//xtxIxty=kx1				ss=0.0;		for (int ii=0; ii<k; ii++) ss = ss + xty[ii] * xtxIxty[ii];				yy=0.0;        for (int ii=0; ii<i; ii++) yy = yy + y[ii];                ss = ss-yy*yy/(double)i; //calculate adjusted sum of squares                sstotal=0.0;        for (int ii=0; ii<i; ii++) sstotal = sstotal + y[ii]*y[ii];                sstotal = sstotal - yy*yy/(double)i; //calculate adjuated sum of squares total          					regResults rr = new regResults(ss, sstotal, xtxIxty, k-1,i-k);		return(rr);	}			}			