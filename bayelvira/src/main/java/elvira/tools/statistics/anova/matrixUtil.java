/** * matrixUtil is a class that contains methods which can be used to perform * calculations involving matrices. * * @author		David Lane * @author		Al Shea * @version		1.1, 02/27/98 */package elvira.tools.statistics.anova;public class matrixUtil {		/**	 * Class constructor.	 */	public matrixUtil() {	}		/**	 * Given a symmetric matrix order n as lower triangle in a[], it calculates an	 * uppper trangle, u[], such that uprime * u = a.	 *	 * @param a   an array with (n*(n+1)/2+1) elements, which represent the elements of	 *            lower triangle of the symmetric matrix	 * @param u   the resultant upper triangle, such that uprime * u = a	 * @param n   order of symmetric matrix a	 *	 * @return    returns ifault=0, if no error	       */		public static int chol(double [] a,double [] u,int n) {		int nn,ifault;		double x, w=0;		ifault = 1;		int j,k,L,m,ii,kk;		if (n <= 0)		return ifault;				ifault = 3;		nn = n*(n+1)/2 + 1;		if ((a.length<nn) || (u.length<nn)) 			return ifault;				ifault = 2;		u[0] = 0; //the nullity of a; the # of elements of u that have been set to 0		j=1;		k=0;		ii=0;	    for (int icol = 1; icol <= n; icol++) {  //loop A			ii = ii + icol;			x = 1E-9 * 1E-9 * a[ii];			L = 0;			kk = 0;			for (int irow = 1; irow <= icol; irow++) { //loop B				kk = kk + irow;				k++;				w = a [k];				m = j;					for (int i =1; i <= irow; i++) {						L++;												if (i == irow)							break; //break out of the current "for" loop						else {							w = w - u[L] * u[m];							m++;						}					}												if (irow != icol) {						if (u[L] != 0)							u[k] = w/u[L];						else {							if (w * w > Math.abs(x * a[kk])) 							    return ifault;						     else								u[k] = 0;						}					}					else						break;	//break out of the current "for" loop					 					        			} //loop B						if (Math.abs(w) > Math.abs(1E-9*a[k])) {														if (w < 0)							return ifault;							u[k] = Math.sqrt(w);								}						else {							u[k] = 0;							u[0]++;						}					j = j + icol;		}  //loop A							    ifault = 0;		    return ifault;  		}		/**	 * Forms in u[] as lower triangle, a generalized inverse of the positive semi-definite	 * symmetric matrix a[] of order n, which is stored as lower triangle	 *	 * @param a   an array with (n*(n+1)/2+1) elements, which represent the elements of	 *            lower triangle of the symmetric matrix	 * @param u   the resultant upper triangle, such that uprime * u = a	 * @param n   order of symmetric matrix a	 *	 * @return    returns ier=0, if no error	       */		public static int syminv(double [] a,double [] u,int n) {		int nn,L;		double x;		int irow = n;		nn = n*(n+1)/2; 		int ndiag = nn;		double [] w = new double[n+1];		int ier = chol(a,u,n);		//System.out.println("ier = " + ier + " n = " + n);		if (ier == 0) {		do {						L = ndiag;		out: 			if (u[ndiag] != 0.0) {				for (int i=irow;i<=n;i++) {					w[i] = u[L];					L = L + i;				}							int icol = n;			int jcol = nn;			int mdiag = nn;				do {  								L = jcol; 				x = 0.0;					if (icol == irow)						x = 1.0/w[irow];								int k = n;					while (k != irow) {						x = x-w[k]*u[L];						k--;						L--;										if (L > mdiag)						L = L-k+1;					}							u[L] = x/w[irow];					if (icol != irow) {						mdiag = mdiag - icol;						icol--;						jcol--;					}					else					break out;					 			} while (true);	        }	        else {	        	for (int j=irow;j<=n;j++) {	        		u[L] = 0.0;	        		L = L + j;	        	}	        	break;			}				        ndiag = ndiag - irow;	        irow--;		} while (irow != 0);		}		return ier;	}	/**	 * Converts X[], a 1-dimensional array whose elements represent the elements of the lower	 * triangle of a symmetric matrix into an n by n symmetric matrix.	 *	 * @param X   an array with (n*(n+1)/2+1) elements, which represent the elements of	 *            lower triangle of the symmetric matrix. Note that the first element is	 *            nothing but a filler, which was used to provide compatibility with the	 *            way Fortran language indexes an array.	 * @param n   order of symmetric matrix 	 *	 * @return    returns matrix, symmetric matrix with order n	 *     */		public  static double [][]  OneTwo(double [] X, int n) {		double [][] matrix = new double[n][];		for (int i=0;i<n;i++) {			matrix[i] = new double[n];		}		int k=0;		for (int i= 0; i < n; i++) {			for (int j=0;j<=i;j++) {				k++;				matrix[i][j] = X[k];				matrix[j][i] = X[k];			}		}		return matrix;	}		public static double[][] MMult(double[][] X,double [][] Y, int L, int M, int N) {		double [][] Z = new double[L][N];		for (int i= 0;i<L;i++) {			Z[0] = new double[N];		}		for (int i=0;i<L;i++) {			for (int j=0;j<N;j++) {				Z[i][j]=0;				for (int k=0;k<M;k++) {					Z[i][j]+=X[i][k] * Y[k][j];				}			}		}		return Z;	}			/**	Multiplies and L x M matrix times an M element vector and returns and M element vector		*/	public static double [] MvMult(double[][] X,double [] Y, int L, int M) {		double [] z = new double[L];		for (int i=0;i<L;i++) {			z[i]=0;			for (int j=0;j<M;j++) {				z[i]+=X[i][j]* Y[j];			}		}		return z;	}		/**	Multiplies the transpose of an L x M matrix times an L element vector	and returns an M element vector.		*/	public static double [] Mtv(double [][] X, double [] Y, int L, int M) {		double [] z = new double[M];		for (int i=0;i<M;i++) {			z[i]=0;			for (int j=0;j<L;j++) {				z[i]+=X[j][i]*Y[j];			}		}		return z;	}		/**	Multiplies the transpose of an L x M matrix time an L x N matrix	and returns and M x N matrix.		*/		public static double [][] XtY(double[][] X,double [][] Y, int L, int M, int N) {		double [][] Z = new double[M][N];		for (int i= 0;i<M;i++) {			Z[0] = new double[N];		}		for (int i=0;i<M;i++) {			for (int j=0;j<N;j++) {				Z[i][j]=0;				//System.out.println(i + " " + j);				for (int k=0;k<L;k++) {					Z[i][j]+=X[k][i]*Y[k][j];				}			}		}		return Z;			}		public static double [][] Transpose(double [][] X,int m,int n) {	double [][] XT = new double [n][m];		for (int i=0;i<m;i++) {			for (int j=0;j<n;j++) {				XT[j][i]=X[i][j];			}		}		return XT;	}	/**	 * Converts X[][], an n x n symmetric matrix into a 1-dimensional array whose elements,	 * with the first element being an exception, represents the elements of the lower 	 * triangle of the symmetric matrix.	 *	 * @param X   an array with n by n elements, which represent the elements of	 *            lower triangle of the symmetric matrix. 	 * @param n   order of symmetric matrix X	 *	 * @return    returns V [], a one-dimensional array with [n*(n+1)/2+1] elements	 *     */		public static double [] TwoOne(double [][] X,int n) {		double[] V = new double[n*(n+1)/2+1];		int k=0;		for (int i=0;i<n;i++) {			for (int j=0;j<=i;j++){				k++;				V[k]=X[i][j];			}		}		return V;	}  					}