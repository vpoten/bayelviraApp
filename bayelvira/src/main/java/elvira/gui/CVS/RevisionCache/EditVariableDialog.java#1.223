/*	EditVariableDialog.java	*/

package elvira.gui;

import java.awt.*;
import java.awt.event.*;

import javax.swing.plaf.basic.*;
import javax.swing.*;
import javax.swing.border.*;
import javax.swing.table.*;
import javax.swing.event.*;
import javax.swing.text.*;
import javax.swing.undo.*;
import javax.swing.tree.*;

import java.util.*;
import java.text.*;
import java.io.*;

import elvira.*;
import elvira.potential.*;
import elvira.gui.explication.*;
import elvira.gui.*;
import elvira.Bnet;
import elvira.Node;
import elvira.Relation;
import elvira.Elvira;
import elvira.gui.continuousEdit.*;

import elvira.sensitivityAnalysis.GeneralizedPotentialTable;//Introducido por jruiz

/**
 * A class that produce a Dialog for editing the properties
 * of a selected node.
 *
 * @author fjdiez, ratienza, francisco
 * @version 0.1
 * @since 21/10/99
 */

public class EditVariableDialog extends javax.swing.JDialog{

        public static String[] functionsNode;
        public static String[] unitsUtility;
        private static String[] unitsInitial = {"","QUALYs"};
        
	/* BEGIN: CONSTRUCTORS */

        /**
	 * Creates an empty EditVariableDialog as a child of the Frame
	 * given as parameter
	 */

	public EditVariableDialog(Frame parent)
	{
		super(parent);
                
                treePanelTree= new PanelEditTree(parent);  

                //A=new elvira.prueba.Application();
                dialogBundle = Elvira.getElviraFrame().getDialogBundle();
		// This code is automatically generated by Visual Cafe when you add
		// components to the visual environment. It instantiates and initializes
		// the components. To modify the code, only use code syntax that matches
		// what Visual Cafe can generate, or Visual Cafe may be unable to back
		// parse your Java file into its visual environment.
		//{{INIT_CONTROLS
		initializeFunctionsNode();
                initializeUnitsUtility();
		setModal(true);
		getContentPane().setLayout(new BorderLayout(0,0));
		setSize(578,376);
                setResizable(true);
		setVisible(false);
		getContentPane().add(BorderLayout.CENTER,editVarTabbedPane);
		editVarTabbedPane.setBounds(0,0,578,341);
		nodePanel.setLayout(null);
		editVarTabbedPane.add(nodePanel);
		nodePanel.setBounds(2,27,573,311);
		nodePanel.setVisible(false);
		nameLabel.setText(localize(dialogBundle,"EditVariable.Name.label"));
		nodePanel.add(nameLabel);
		nameLabel.setBackground(new java.awt.Color(204,204,204));
		nameLabel.setBounds(30,16,48,20);
		nameTextField.setColumns(20);
		nodePanel.add(nameTextField);
		nameTextField.setBounds(80,17,130,22);
		relevanceComboBox.setEditable(true);
		nodePanel.add(relevanceComboBox);
		relevanceComboBox.setBounds(384,17,70,24);
		titleLabel.setText(localize(dialogBundle,"EditVariable.Title.label"));
		nodePanel.add(titleLabel);
		titleLabel.setBounds(40,50,50,15);
		titleTextField.setColumns(40);
		nodePanel.add(titleTextField);
		titleTextField.setBounds(80,48,250,22);
		commentLabel.setText(localize(dialogBundle,"EditVariable.Comment.label"));
		nodePanel.add(commentLabel);
		commentLabel.setBounds(10,202,70,25);
		commentScrollPane.setOpaque(true);
		nodePanel.add(commentScrollPane);
		commentScrollPane.setBounds(82,200,220,80);
		commentScrollPane.getViewport().add(commentTextArea);
		commentTextArea.setBounds(0,0,217,77);

		functionLabel.setText(localize(dialogBundle,"EditVariable.Class.label"));
		nodePanel.add(functionLabel);
		functionLabel.setBounds(310,202,60,25);
		functionComboBox = new javax.swing.JComboBox(functionsNode);
		functionComboBox.setEditable(false);
		nodePanel.add(functionComboBox);
		functionComboBox.setBounds(380,202,150,30);

                unitsLabel.setText(localize(dialogBundle,"EditVariable.Units.label"));
                nodePanel.add(unitsLabel);
                unitsLabel.setBounds(310,202,60,25);
                unitsLabel.setVisible(false);
                unitsComboBox = new javax.swing.JComboBox(unitsUtility);
                unitsComboBox.setEditable(false);
                nodePanel.add(unitsComboBox);
                unitsComboBox.setBounds(380,202,150,30);
                unitsComboBox.setVisible(false);

		nodePanel.add(newfunctionLabel);
		newfunctionLabel.setBounds(310,250,60,30);
		newfunctionLabel.setEnabled(true);
		newfunctionLabel.setVisible(false);
		newfunctionLabel.setText(localize(dialogBundle, "New"));

		editFunctionText.setColumns(20);
		nodePanel.add(editFunctionText);
		editFunctionText.setBounds(380,250,150,30);
		editFunctionText.setEnabled(false);
		editFunctionText.setEditable(false);
		editFunctionText.setVisible(false);

		nodeKindPanel.setAlignmentY(0.0F);
		nodeKindPanel.setLayout(null);
		nodePanel.add(nodeKindPanel);
		nodeKindPanel.setBounds(94,81,156,107);

		chanceRadioButton.setText(
		      localize(dialogBundle,"EditVariable.Chance.label"));
		chanceRadioButton.setActionCommand("Bayes Network");
		nodeKindPanel.add(chanceRadioButton);
		chanceRadioButton.setBounds(24,23,113,29);
		decisionRadioButton.setText(
		      localize(dialogBundle,"EditVariable.Decision.label"));
		decisionRadioButton.setActionCommand("Markov Network");
		decisionRadioButton.setEnabled(false);
		nodeKindPanel.add(decisionRadioButton);
		decisionRadioButton.setBounds(24,47,102,29);
		utilityRadioButton.setText(
		      localize(dialogBundle,"EditVariable.UtilityNode.label"));
		utilityRadioButton.setActionCommand("Influence Diagram");
		utilityRadioButton.setEnabled(false);
		nodeKindPanel.add(utilityRadioButton);
		utilityRadioButton.setBounds(24,71,102,29);
		variableTypePanel.setAlignmentY(0.0F);
		variableTypePanel.setLayout(null);
		nodePanel.add(variableTypePanel);
		variableTypePanel.setBounds(298,81,156,107);
		discreteRadioButton.setText(
		      localize(dialogBundle,"EditVariable.Discrete.label"));
		discreteRadioButton.setActionCommand("Bayes Network");
		variableTypePanel.add(discreteRadioButton);
		discreteRadioButton.setBounds(24,23,84,29);
		continuousRadioButton.setText(
		      localize(dialogBundle,"EditVariable.Continuous.label"));
		continuousRadioButton.setActionCommand("Markov Network");
		continuousRadioButton.setEnabled(false);
		variableTypePanel.add(continuousRadioButton);
		continuousRadioButton.setBounds(24,47,96,29);
		hybridRadioButton.setText(
		      localize(dialogBundle,"EditVariable.Hybrid.label"));
		hybridRadioButton.setActionCommand("Influence Diagram");
		hybridRadioButton.setEnabled(false);
		variableTypePanel.add(hybridRadioButton);
		hybridRadioButton.setBounds(24,71,84,29);
		relevanceLabel.setText(
		      localize(dialogBundle,"EditVariable.Relevance.label"));
		nodePanel.add(relevanceLabel);
		relevanceLabel.setBackground(new java.awt.Color(204,204,204));
		relevanceLabel.setBounds(314,16,70,20);
		
		observedBox.setText(localize(dialogBundle,"EditVariable.Observed.label"));
		observedBox.setActionCommand("DAN");
		observedBox.setEnabled(false);
		observedBox.setBounds(360,45,170,29);
		nodePanel.add(observedBox);
		
		
	        //GridBagLayout gridbagvalue = new GridBagLayout();
		//valuesPanel.setLayout(gridbagvalue);

                
                valuesPanel.setLayout(null);
		//editVarTabbedPane.add(valuesPanel);
		valuesPanel.setBounds(2,27,573,311);
                valuesPanel.setVisible(false);

                valuesPanel.setBorder(BorderFactory.createTitledBorder(
                                    localize(dialogBundle,"EditVariable.DBorderText.label")));

                
                valuesPanel.add(valuesComboBox);
		valuesComboBox.setBounds(170,33,204,24);
		valuesComboBox.setSelectedIndex(-1);
		valuesScrollPane.setOpaque(true);
		valuesPanel.add(valuesScrollPane);
		valuesScrollPane.setBounds(34,96,204,110);
		valuesScrollPane.getViewport().add(valuesTable);
		valuesTable.setBounds(0,0,201,0);
		valuesTypeLabel.setText(
		      localize(dialogBundle,"EditVariable.ValuesType.label"));
		valuesPanel.add(valuesTypeLabel);
		valuesTypeLabel.setBounds(82,33,93,20);
		addButton.setText(
		      localize(dialogBundle,"EditVariable.AddState.label"));
		addButton.setActionCommand("Add New Row");
		valuesPanel.add(addButton);
		addButton.setBounds(322,93,154,33);
		removeButton.setText(
		      localize(dialogBundle,"EditVariable.RemoveState.label"));
		removeButton.setActionCommand("Remove Row");
		valuesPanel.add(removeButton);
		removeButton.setBounds(322,141,154,33);
		upButton.setActionCommand("up");
		valuesPanel.add(upButton);
		upButton.setBounds(240,98,32,30);
		downButton.setActionCommand("down");
		valuesPanel.add(downButton);
		downButton.setBounds(240,130,32,30);

		CardLayout cardl2 = new CardLayout();
		valuesPanelCard.setLayout(cardl2);

                createContinuousValuesPanel();
                
                
                valuesPanelCard.add(valuesPanel,"DISCRETEVALUES");
                valuesPanelCard.add(cValuesPanel,"CONTINUOUSVALUES");
                
                
                editVarTabbedPane.add(valuesPanelCard);

                
                
	        GridBagLayout gridbag = new GridBagLayout();
	        GridBagConstraints c = new GridBagConstraints();

		/**
		 * In relation Panel, by default, only the TypeRelationComboBox
		 * should be shown for the first time.
		 */

		relationPanel.setLayout(gridbag);

		/* Added for the edition of probability trees*/
		comboNodes = new JComboBox();
		comboNodes.setEditable(true);
		comboNodes.addActionListener(new MiActionListener());
		((JTextField)comboNodes.getEditor().getEditorComponent()).addCaretListener(new MiCaretListener());

		treeNode = new DefaultMutableTreeNode(" ");
		treeModel = new DefaultTreeModel(treeNode);
		myTreeModelListener = new MyTreeModelListener(treeModel,comboNodes, parents);
		treeModel.addTreeModelListener(myTreeModelListener);

		tree = new JTree(treeModel);
		tree.setEditable(true);
		tree.getSelectionModel().setSelectionMode(TreeSelectionModel.SINGLE_TREE_SELECTION);
		tree.setShowsRootHandles(true);
		tree.setCellEditor( new DefaultCellEditor( comboNodes ) );
		//treeScrollPane = new JScrollPane(tree);
                treeScrollPane = new JScrollPane(treePanelTree);

		feedBackTree = new JTextField();
		feedBackTree.setEditable(false);
		feedBackTreeScrollPane = new JScrollPane(feedBackTree);

		CardLayout cardl = new CardLayout();
		relationPanelCard.setLayout(cardl);

		//editVarTabbedPane.add(relationPanelCard);
		/**/

		relationPanel.setBounds(2,27,573,311);
		relationPanel.setVisible(false);
                
//		CardLayout cardl2 = new CardLayout();
//		valoresPanelCard.setLayout(cardl2);
                
//		valoresPanel.setBounds(2,27,573,311);
//		valoresPanel.setVisible(false);
                
                
		panel1.setLayout(null);
       
		c = setGridBagConstraints (2,0,2,1,0.7,0.15);
		//c = setGridBagConstraints (1,0,1,1,0.7,0.15);
		gridbag.setConstraints(panel1, c);
		relationPanel.add(panel1);
		panelSetEnabled(panel1,false);
		
		    
	

		probRadioButton.setSelected(true);
		probRadioButton.setText(
		      localize(dialogBundle,"EditVariable.Probabilistic.label"));
		probRadioButton.setActionCommand("jradioButton");
		panel1.add(probRadioButton);
		probRadioButton.setBounds(14,6,99,23);
		detRadioButton.setText(
		      localize(dialogBundle,"EditVariable.Deterministic.label"));
		detRadioButton.setActionCommand("jradioButton");
		panel1.add(detRadioButton);
		detRadioButton.setBounds(120,6,95,23);
		
	
		
		panelOptProbDet.setLayout(null);
		
		c=this.setGridBagConstraints(2,0,2,1,0.7,0.15);
		gridbag.setConstraints(panelOptProbDet, c);
		relationPanel.add(panelOptProbDet);
		panelSetEnabled(panelOptProbDet,false);
		//panelOptProbDet.setBounds(296, 34, 120, 30);
		
		//Button for the policy of decisions
		
		optimalRadioButtonDecs.setText(
			      localize(dialogBundle,"EditVariable.Optimal.label"));
		optimalRadioButtonDecs.setActionCommand("jradioButton");
		panelOptProbDet.add(optimalRadioButtonDecs);
	
		probRadioButtonDecs.setText(
		      localize(dialogBundle,"EditVariable.Probabilistic.label"));
		probRadioButtonDecs.setActionCommand("jradioButton");
		panelOptProbDet.add(probRadioButtonDecs);
		
		detRadioButtonDecs.setText(
		      localize(dialogBundle,"EditVariable.Deterministic.label"));
		detRadioButtonDecs.setActionCommand("jradioButton");
		panelOptProbDet.add(detRadioButtonDecs);
		
		setBoundsForButtonsOptProbDet();
		
		//Group for panel of relation of decisions
		optProbDecGroup.add(optimalRadioButtonDecs);
		optProbDecGroup.add(probRadioButtonDecs);
		optProbDecGroup.add(detRadioButtonDecs);
		
		

		
		
	       
           
           
	         
    
           //panelSVNode.setBounds(296,34,90,30); Va bien
           
	panelOptProbDet.setVisible(false);
		
	tablePanel.setLayout(new BorderLayout(0,0));
		c = setGridBagConstraints (0,2,4,3,1.5,1.0);
		gridbag.setConstraints(tablePanel, c);
		relationPanel.add(tablePanel);

		tablePanel.setBounds(1,90,571,220);
		relationScrollPane.setOpaque(true);
		tablePanel.add(BorderLayout.CENTER,relationScrollPane);
		relationScrollPane.setBounds(0,0,570,219);
		relationTable.setAutoResizeMode(javax.swing.JTable.AUTO_RESIZE_OFF);
		relationScrollPane.getViewport().add(relationTable);
		relationTable.setBounds(0,0,0,0);
		panel2.setLayout(null);

		c = setGridBagConstraints (0,1,1,1,0.25,0.25);
		gridbag.setConstraints(panel2, c);
		relationPanel.add(panel2);

		panel2.setBounds(1,34,184,56);
		panelSetEnabled(panel2,false);
		allRadioButton.setText(
		      localize(dialogBundle,"EditVariable.AllPar.label"));
		allRadioButton.setActionCommand("jradioButton");
		panel2.add(allRadioButton);
		allRadioButton.setBounds(3,6,150,23);
		//indRadioButton.setSelected(false);
		allRadioButton.setSelected(true);
		indRadioButton.setText(
		      localize(dialogBundle,"EditVariable.IndPar.label"));
		indRadioButton.setActionCommand("jradioButton");
		panel2.add(indRadioButton);
		indRadioButton.setBounds(3,27,180,20);
		panel3.setLayout(null);
		c = setGridBagConstraints (1,1,1,1,0.15,0.25);
		gridbag.setConstraints(panel3, c);
		relationPanel.add(panel3);

		panel3.setBounds(185,34,111,56);
		panelSetEnabled(panel3,false);
		valRadioButton.setSelected(true);
		valRadioButton.setText(
		      localize(dialogBundle,"EditVariable.Values.label"));
		valRadioButton.setActionCommand("jradioButton");
		panel3.add(valRadioButton);
		valRadioButton.setBounds(3,6,64,23);
		probsRadioButton.setText(
		      localize(dialogBundle,"EditVariable.Probabilities.label"));
		probsRadioButton.setActionCommand("jradioButton");
		panel3.add(probsRadioButton);
		probsRadioButton.setBounds(3,27,102,20);
		
		panel4.setLayout(null);
		c = setGridBagConstraints (2,1,1,1,0.15,0.25);
		gridbag.setConstraints(panel4, c);
		relationPanel.add(panel4);
		panel4.setBounds(296,34,184,56);
		panelSetEnabled(panel4,false);
		cptRadioButton.setText(
		      localize(dialogBundle,"EditVariable.CPT.label"));
		cptRadioButton.setActionCommand("CPT");
		panel4.add(cptRadioButton);
		cptRadioButton.setBounds(3,6,94,23);
		canRadioButton.setSelected(true);
		canRadioButton.setText(
		      localize(dialogBundle,"EditVariable.CanPar.label"));
		canRadioButton.setActionCommand("Canonical models");
		panel4.add(canRadioButton);
		canRadioButton.setBounds(3,27,145,20);
                
                /* panelSVNode de combinacion de utilidades */
                /*panelSVNode.setLayout(null);
                               
                
         
                c=this.setGridBagConstraints(2,0,2,1,0.7,0.15);
		gridbag.setConstraints(panelSVNode, c);
		relationPanel.add(panelSVNode);
                panelSVNode.setBounds(296, 34, 120, 30);
                //panelSVNode.setBounds(296,34,90,30); Va bien
                
                panelSVNode.setVisible(false);
                             
                addRadioButton.setSelected(true);
                addRadioButton.setText(localize(dialogBundle, "EditVariable.Relation.UtilityAdd.label"));
                addRadioButton.setActionCommand("jradioButton");
                addRadioButton.setBounds(14,6,130,23);
                //addRadioButton.setBounds(14,6,99,23);
                panelSVNode.add(addRadioButton);
                multiplyRadioButton.setText(localize(dialogBundle, "EditVariable.Relation.UtilityMultiply.label"));
                multiplyRadioButton.setActionCommand("jradioButton");
                multiplyRadioButton.setBounds(150,6,130,23);
                //multiplyRadioButton.setBounds(120,6,95,23);
                panelSVNode.add(multiplyRadioButton);*/
		
                /* panelSVNode de combinacion de utilidades */
                panelSVNode.setLayout(null);
                               
                
         
                c=this.setGridBagConstraints(2,0,2,1,0.7,0.15);
		gridbag.setConstraints(panelSVNode, c);
		relationPanel.add(panelSVNode);
                panelSVNode.setBounds(296, 34, 120, 30);
                //panelSVNode.setBounds(296,34,90,30); Va bien
                
                panelSVNode.setVisible(false);
                             
                addRadioButton.setSelected(true);
                addRadioButton.setText(localize(dialogBundle, "EditVariable.Relation.UtilityAdd.label"));
                addRadioButton.setActionCommand("jradioButton");
                addRadioButton.setBounds(10,6,130,23);
                //addRadioButton.setBounds(14,6,99,23);
                panelSVNode.add(addRadioButton);
                utilityCombinationGroup.add(addRadioButton);
                multiplyRadioButton.setText(localize(dialogBundle, "EditVariable.Relation.UtilityMultiply.label"));
                multiplyRadioButton.setActionCommand("jradioButton");
                multiplyRadioButton.setBounds(136,6,134,23);
                //multiplyRadioButton.setBounds(120,6,95,23);
                utilityCombinationGroup.add(multiplyRadioButton);
                panelSVNode.add(multiplyRadioButton);
                //panelSVNode.add(multiplyRadioButton);
                orTypePanel.setLayout(null);
                
               
		c = setGridBagConstraints (3,1,1,1,0.1,0.25);
		gridbag.setConstraints(orTypePanel, c);
		relationPanel.add(orTypePanel);
                
                
                
                
		orTypePanel.setBounds(480,34,92,56);
		panelSetEnabled(orTypePanel,false);
		diezRadioButton.setSelected(true);
		diezRadioButton.setText(
		      localize(dialogBundle,"EditVariable.Diez.label"));
		diezRadioButton.setActionCommand("Díez");
		orTypePanel.add(diezRadioButton);
		diezRadioButton.setBounds(3,6,90,23);
		henrionRadioButton.setSelected(false);
		henrionRadioButton.setText(
		      localize(dialogBundle,"EditVariable.Henrion.label"));
		henrionRadioButton.setActionCommand("Henrion");
		orTypePanel.add(henrionRadioButton);
		henrionRadioButton.setBounds(3,27,90,20);
		relationTypePanel.setLayout(null);

		c = setGridBagConstraints (0,0,2,1,0.7,0.15);
		gridbag.setConstraints(relationTypePanel, c);
		relationPanel.add(relationTypePanel);

		/* Added for the edition of probability trees*/
		GridBagLayout gridBagTree = new GridBagLayout();
		GridBagConstraints ct = new GridBagConstraints();
                treePanel.setLayout(gridBagTree);
                

		ct.fill = GridBagConstraints.HORIZONTAL;

//		ct = setGridBagConstraints (0,0,2,1,0.7,0.15);
//		gridBagTree.setConstraints(relationTypePanel, ct);

                ct = setGridBagConstraints (0,0,2,1,0.7,0.15);
		gridBagTree.setConstraints(relationTypePanel, ct);

                
		ct = setGridBagConstraints (0,1,1,1,0.7,0.5);
		gridBagTree.setConstraints(treeScrollPane, ct);
		treePanel.add(treeScrollPane);

                
                ct = setGridBagConstraints (0,2,1,2,0,0.04);
		((GridBagLayout)treePanel.getLayout()).setConstraints(feedBackTreeScrollPane, ct);
		treePanel.add(feedBackTreeScrollPane);


                

                
                
                
		relationPanelCard.add(treePanel, "TREE");
            
                relationPanelCard.add(relationPanel,"TABLE");
          
		/**/

		typeRelationLabel.setText(
		      localize(dialogBundle,"EditVariable.RelationType.label"));
		relationTypePanel.add(typeRelationLabel);
		typeRelationLabel.setBounds(4,10,90,15);
		relationTypePanel.add(typeRelationButton);
		typeRelationButton.setBounds(100,7,180,23);
		typeRelationButton.setText(
		      localize(dialogBundle,"EditVariable.relationDialogGeneral.label"));
		typeRelationButton.setActionCommand("TypeRelation");
               	parentsPanel.setLayout(null);

                
                editVarTabbedPane.add(parentsPanel);
		editVarTabbedPane.add(relationPanelCard);
		//editVarTabbedPane.add(relationPanel); /* After the parents' one */
		parentsPanel.setBounds(2,27,573,311);
		parentsPanel.setVisible(false);
		parentsPanel.add(parentsKindLabel);
		parentsKindLabel.setBounds(170,33,204,24);
		parentsScrollPane.setOpaque(true);
		parentsPanel.add(parentsScrollPane);
		parentsScrollPane.setBounds(34,96,204,110);
		parentsScrollPane.getViewport().add(parentsTable);
		parentsTable.setBounds(0,0,201,0);
		parentsTypeLabel.setText(
		      localize(dialogBundle,"EditVariable.ParentsType.label"));
		//parentsPanel.add(parentsTypeLabel); /* For the moment */
		parentsTypeLabel.setBounds(82,33,93,20);
		addParentButton.setText(
		      localize(dialogBundle,"EditVariable.AddParent.label"));
		addParentButton.setActionCommand("Add New Parent");
		parentsPanel.add(addParentButton);
		addParentButton.setBounds(322,93,170,33);
		removeParentButton.setText(
		      localize(dialogBundle,"EditVariable.RemoveParent.label"));
		removeParentButton.setActionCommand("Remove Parent");
		parentsPanel.add(removeParentButton);
		removeParentButton.setBounds(322,189,170,33);
                
                addFromGUIParentButton.setText(
                      localize(dialogBundle,"EditVariable.AddFromGUI.label"));
                addFromGUIParentButton.setActionCommand("Add From GUI");
                parentsPanel.add(addFromGUIParentButton);
                addFromGUIParentButton.setBounds(322,141,170,33);
		upParentButton.setActionCommand("up");
		parentsPanel.add(upParentButton);
		upParentButton.setBounds(240,98,32,30);
		downParentButton.setActionCommand("down");
		parentsPanel.add(downParentButton);
		downParentButton.setBounds(240,130,32,30);
		
                
                //editVarTabbedPane.add(cValuesPanel);
                /** When editing, start showing nodePanel as default **/
		editVarTabbedPane.setSelectedIndex(0);
		lastTabbedPane = 0;
		editVarTabbedPane.setSelectedComponent(nodePanel);
		try {
			editVarTabbedPane.setTitleAt(0,
			      localize(dialogBundle,"EditVariable.Node.label"));
		}
		catch(ArrayIndexOutOfBoundsException e) { }
	        editVarTabbedPane.setTitleAt(1,
		      localize(dialogBundle,"EditVariable.Values.label"));
		editVarTabbedPane.setTitleAt(3,
		      localize(dialogBundle,"EditVariable.Relation.label"));
                editVarTabbedPane.setTitleAt(2,
		      localize(dialogBundle,"EditVariable.Parents.label"));
//                editVarTabbedPane.setTitleAt(4,
//		      localize(dialogBundle,"EditVariable.Values.label"));

                
		buttonsPanel.setLayout(new FlowLayout(FlowLayout.CENTER,5,5));
		getContentPane().add(BorderLayout.SOUTH,buttonsPanel);
		buttonsPanel.setBounds(0,341,578,35);
		okButton.setText(localize(dialogBundle,"OK.label"));
		okButton.setActionCommand("OK");
		buttonsPanel.add(okButton);
		okButton.setBounds(189,5,51,25);
		cancelButton.setText(
		      localize(dialogBundle,"Cancel.label"));
		cancelButton.setActionCommand("Cancel");
		buttonsPanel.add(cancelButton);
		cancelButton.setBounds(245,5,73,25);
		applyButton.setText(
		      localize(dialogBundle,"Apply.label"));
		applyButton.setActionCommand("Apply");
		buttonsPanel.add(applyButton);
		applyButton.setBounds(323,5,65,25);
		//}}

		inicializeDataArrays();

	        model = new ValuesTableModel(data, columnNames);
		valuesTable.setModel(model);
		parentsModel = new ParentsTableModel(parentsData,parentsName);
		parentsTable.setModel(parentsModel);
		parentsDialogModel = new ParentsTableModel(nodesData,nodesName);
		parentsDialogTable.setModel(parentsDialogModel);

		upButton.setIcon(arrowUpIcon);
		downButton.setIcon(arrowDownIcon);

                upParentButton.setIcon(arrowUpIcon);
		downParentButton.setIcon(arrowDownIcon);

		headerTable.setAutoResizeMode(JTable.AUTO_RESIZE_OFF);

		for (int i=10; i>=0; i--) {
		   relevanceComboBox.addItem(String.valueOf(i)+".00");
		}

		nodeKindPanel.setBorder(
		      new TitledBorder(
		         localize(dialogBundle,"EditVariable.Kind.label")));

		nodeKindGroup.add (chanceRadioButton);
		nodeKindGroup.add (decisionRadioButton);
		nodeKindGroup.add (utilityRadioButton);
                chanceRadioButton.setEnabled(false);
                decisionRadioButton.setEnabled(false);
                utilityRadioButton.setEnabled(false);

		variableTypePanel.setBorder (
		      new TitledBorder (
		         localize(dialogBundle,"EditVariable.Type.label")));

		variableTypeGroup.add (discreteRadioButton);
		variableTypeGroup.add (continuousRadioButton);
		variableTypeGroup.add (hybridRadioButton);
                discreteRadioButton.setEnabled(false);
                continuousRadioButton.setEnabled(false);
                hybridRadioButton.setEnabled(false);

      
                
		// Setting the characteristics of the values Table
	        valuesTable.getColumn(columnNames[0]).setMaxWidth(60);
		valuesTable.getModel().addTableModelListener(
	        new TableModelListener() {
           	   public void tableChanged(TableModelEvent e) {
	               statesHasChanged = true;
		       int theRow = e.getLastRow();
		       int theColumn = e.getColumn();

		       if ((theRow < 0) || (theColumn < 0)) {
			return;
		       }

		       String data = (String) model.getValueAt(theRow, theColumn);

		       if (data==null) {
		        TableCellEditor rowcolCellEditor =
			  (TableCellEditor) valuesTable.getCellEditor(theRow,theColumn);
			rowcolCellEditor.stopCellEditing(); /* This was the action lacking */
		        data = (String) rowcolCellEditor.getCellEditorValue();

		       }
		   }
	         });

	        relationTable.getModel().addTableModelListener(
                  new RelationTableListener());

	        menuBundle = Elvira.getElviraFrame().getMenuBundle();
	        dialogBundle = Elvira.getElviraFrame().getDialogBundle();

		panel1.setBorder(new EtchedBorder());
		panel2.setBorder(new EtchedBorder());
		panel3.setBorder(new EtchedBorder());
		panel4.setBorder(new EtchedBorder());
                panelSVNode.setBorder(new EtchedBorder());
		orTypePanel.setBorder(new EtchedBorder());

		bGroup1.add(probRadioButton);
		bGroup1.add(detRadioButton);

		bGroup2.add(allRadioButton);
		bGroup2.add(indRadioButton);

		bGroup3.add(valRadioButton);
		bGroup3.add(probsRadioButton);

		bGroup4.add(cptRadioButton);
		bGroup4.add(canRadioButton);

		orTypeGroup.add(diezRadioButton);
		orTypeGroup.add(henrionRadioButton);
		

		/** The dialog to show when editing relation type **/

		relationDialog.setModal(true);
		relationDialog.getContentPane().setLayout(new BorderLayout(0,0));
		relationDialog.setVisible(false);
		relationDialog.setResizable(false);
		relationDialog.setTitle(localize(dialogBundle, "EditVariable.relationDialogTitle.label"));
		/**/relationDialog.setBounds(0,0,180,250);
		relationDialog.setLocationRelativeTo(this);
		panelRelation.setLayout(null);
                /**/panelRelation.setBounds(0,0,174,180);
		generalRadioButton.setText(
		      localize(dialogBundle,"EditVariable.relationDialogGeneral.label"));
	        generalRadioButton.setBounds(15,10,145,20);
		panelRelation.add(generalRadioButton);
		orRadioButton.setText(
		      localize(dialogBundle,"EditVariable.relationDialogOr.label"));
		orRadioButton.setBounds(15,30,145,20);
		panelRelation.add(orRadioButton);
      		causalMaxRadioButton.setText(
		      localize(dialogBundle,"EditVariable.relationDialogCausalMax.label"));
		causalMaxRadioButton.setBounds(15,50,145,20);
		panelRelation.add(causalMaxRadioButton);
      		generalizedMaxRadioButton.setText(
		      localize(dialogBundle,"EditVariable.relationDialogGeneralizedMax.label"));
		generalizedMaxRadioButton.setBounds(15,70,145,20);
		panelRelation.add(generalizedMaxRadioButton);
      		andRadioButton.setText(
		      localize(dialogBundle,"EditVariable.relationDialogAnd.label"));
		andRadioButton.setBounds(15,90,145,20);
		panelRelation.add(andRadioButton);
      		minRadioButton.setText(
		      localize(dialogBundle,"EditVariable.relationDialogMin.label"));
		minRadioButton.setBounds(15,110,145,20);
		panelRelation.add(minRadioButton);
      		xorRadioButton.setText(
		      localize(dialogBundle,"EditVariable.relationDialogXor.label"));
		xorRadioButton.setBounds(15,130,145,20);
		panelRelation.add(xorRadioButton);

		
                
		/* Added for the edition of probability trees*/
		treeRadioButton.setText(localize(dialogBundle,"EditVariable.relationDialogProbabilityTree.label"));
		treeRadioButton.setBounds(15,150,145,20);
		treeRadioButton.setEnabled(true);
		panelRelation.add(treeRadioButton);
		/* Added for decisions */
	/*	optimalPolicyRadioButton.setText(localize(dialogBundle,"EditVariable.relationDialogOptimalPolicy.label"));
		optimalPolicyRadioButton.setBounds(15,170,145,20);
		panelRelation.add(optimalPolicyRadioButton);
		forcePolicyRadioButton.setText(localize(dialogBundle,"EditVariable.relationDialogForcePolicy.label"));
		forcePolicyRadioButton.setBounds(15,190,145,20);
		panelRelation.add(forcePolicyRadioButton);*/
		/**/
                
                //panelRelation es la ventanita que se abre para elegir el tipo de relación               
                
                panelRelation.setBorder(new EtchedBorder());
		relationDialog.getContentPane().add(panelRelation);
                                                
                /*****************************************/
                relGroup.add(generalRadioButton);
		relGroup.add(orRadioButton);
		relGroup.add(causalMaxRadioButton);
		relGroup.add(generalizedMaxRadioButton);
		relGroup.add(andRadioButton);
		relGroup.add(minRadioButton);
		relGroup.add(xorRadioButton);
		/**/relGroup.add(treeRadioButton);
                /****************************************/
		
                
                
                
                
                generalRadioButton.setSelected(true);
		orRadioButton.setEnabled(true);
		causalMaxRadioButton.setEnabled(true);
		generalizedMaxRadioButton.setEnabled(true);
		andRadioButton.setEnabled(true);
		minRadioButton.setEnabled(true);
		xorRadioButton.setEnabled(false);
                
		buttonsRelationDialogPanel.setLayout(null);
		relationDialog.getContentPane().add(buttonsRelationDialogPanel);
		/**/buttonsRelationDialogPanel.setBounds(0,184,164,40);
		okRelationDialogButton.setText(localize(dialogBundle,"OK.label"));
		okRelationDialogButton.setActionCommand("OK");
		okRelationDialogButton.setVisible(true);
		buttonsRelationDialogPanel.add(okRelationDialogButton);
		/**/okRelationDialogButton.setBounds(3,190,80,30);
		cancelRelationDialogButton.setText(localize(dialogBundle,"Cancel.label"));
		cancelRelationDialogButton.setActionCommand("Cancel"); 
		cancelRelationDialogButton.setVisible(true);
		buttonsRelationDialogPanel.add(cancelRelationDialogButton);
		buttonsRelationDialogPanel.setVisible(true);
		/**/cancelRelationDialogButton.setBounds(87,190,84,30);

		// Set the dialog position
		setLocationRelativeTo(Elvira.getElviraFrame());

		/* The dialog to show when choosing the node parents from EditVariableDialog */
		parentsDialog.setModal(true);
		parentsDialog.getContentPane().setLayout(new BorderLayout(0,0));
		parentsDialog.setVisible(false);
		parentsDialog.setResizable(false);
		parentsDialog.setTitle(localize(dialogBundle, "EditVariable.parentsDialogTitle.label"));
		parentsDialog.setBounds(0,0,180,230);
		parentsDialog.setLocationRelativeTo(this);
		parentsDialogPanel.setVisible(true);
		parentsDialogPanel.setLayout(null);
		parentsDialogPanel.setBounds(0,0,174,160);
		parentsDialogScrollPane.setOpaque(true);
		parentsDialogPanel.add(parentsDialogScrollPane);
		parentsDialogScrollPane.setBounds(7,7,160,150);
		parentsDialogScrollPane.getViewport().add(parentsDialogTable);
		parentsDialog.getContentPane().add(parentsDialogPanel);
		buttonsParentsDialogPanel.setLayout(null);
		parentsDialog.getContentPane().add(buttonsParentsDialogPanel);
		buttonsParentsDialogPanel.setBounds(0,164,164,40);
		okParentsButton.setText(localize(dialogBundle,"OK.label"));
		okParentsButton.setActionCommand("OK");                
		buttonsParentsDialogPanel.add(okParentsButton);
		okParentsButton.setBounds(3,170,80,30);
		cancelParentsButton.setText(localize(dialogBundle,"Cancel.label"));
		cancelParentsButton.setActionCommand("Cancel");                
		buttonsParentsDialogPanel.add(cancelParentsButton);
		cancelParentsButton.setBounds(87,170,84,30);

		//{{REGISTER_LISTENERS
		SymAction lSymAction = new SymAction();
                editVarTabbedPane.registerKeyboardAction(lSymAction, javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_ESCAPE,0,false),JComponent.WHEN_ANCESTOR_OF_FOCUSED_COMPONENT);
                panelRelation.registerKeyboardAction(lSymAction, javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_ESCAPE,0,false),JComponent.WHEN_ANCESTOR_OF_FOCUSED_COMPONENT);
                buttonsRelationDialogPanel.registerKeyboardAction(lSymAction, javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_ESCAPE,0,false),JComponent.WHEN_ANCESTOR_OF_FOCUSED_COMPONENT);
                parentsPanel.registerKeyboardAction(lSymAction, javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_ESCAPE,0,false),JComponent.WHEN_ANCESTOR_OF_FOCUSED_COMPONENT);
                buttonsParentsDialogPanel.registerKeyboardAction(lSymAction, javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_ESCAPE,0,false),JComponent.WHEN_ANCESTOR_OF_FOCUSED_COMPONENT);
                parentsTable.registerKeyboardAction(lSymAction, javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_ESCAPE,0,false),JComponent.WHEN_ANCESTOR_OF_FOCUSED_COMPONENT);
                parentsDialogTable.registerKeyboardAction(lSymAction, javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_ESCAPE,0,false),JComponent.WHEN_ANCESTOR_OF_FOCUSED_COMPONENT);
		okButton.addActionListener(lSymAction);
                okButton.registerKeyboardAction(lSymAction, javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_ENTER,0,false),JComponent.WHEN_FOCUSED);
		cancelButton.addActionListener(lSymAction);
                cancelButton.registerKeyboardAction(lSymAction, javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_ENTER,0,false),JComponent.WHEN_FOCUSED);
		SymItem lSymItem = new SymItem();
		valuesComboBox.addItemListener(lSymItem);
		functionComboBox.addItemListener(lSymItem);
                unitsComboBox.addItemListener(lSymItem);
		addButton.addActionListener(lSymAction);
                addButton.registerKeyboardAction(lSymAction, javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_ENTER,0,false),JComponent.WHEN_FOCUSED);
		removeButton.addActionListener(lSymAction);
                removeButton.registerKeyboardAction(lSymAction, javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_ENTER,0,false),JComponent.WHEN_FOCUSED);
		upButton.addActionListener(lSymAction);
                upButton.registerKeyboardAction(lSymAction, javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_ENTER,0,false),JComponent.WHEN_FOCUSED);
		downButton.addActionListener(lSymAction);
                downButton.registerKeyboardAction(lSymAction, javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_ENTER,0,false),JComponent.WHEN_FOCUSED);
                addParentButton.addActionListener(lSymAction);
                addParentButton.registerKeyboardAction(lSymAction, javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_ENTER,0,false),JComponent.WHEN_FOCUSED);
		removeParentButton.addActionListener(lSymAction);
                removeParentButton.registerKeyboardAction(lSymAction, javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_ENTER,0,false),JComponent.WHEN_FOCUSED);
                addFromGUIParentButton.addActionListener(lSymAction);
                addFromGUIParentButton.registerKeyboardAction(lSymAction, javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_ENTER,0,false),JComponent.WHEN_FOCUSED);
		upParentButton.addActionListener(lSymAction);
                upParentButton.registerKeyboardAction(lSymAction, javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_ENTER,0,false),JComponent.WHEN_FOCUSED);
		downParentButton.addActionListener(lSymAction);
                downParentButton.registerKeyboardAction(lSymAction, javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_ENTER,0,false),JComponent.WHEN_FOCUSED);
		applyButton.addActionListener(lSymAction);
                applyButton.registerKeyboardAction(lSymAction, javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_ENTER,0,false),JComponent.WHEN_FOCUSED);
		SymChange lSymChange = new SymChange();
		editVarTabbedPane.addChangeListener(lSymChange);
		relevanceComboBox.addItemListener(lSymItem);
		typeRelationButton.addActionListener(lSymAction);
                typeRelationButton.registerKeyboardAction(lSymAction, javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_ENTER,0,false),JComponent.WHEN_FOCUSED);
		valRadioButton.addItemListener(lSymItem);
		allRadioButton.addItemListener(lSymItem);
		indRadioButton.addItemListener(lSymItem);
		cptRadioButton.addItemListener(lSymItem);
		canRadioButton.addItemListener(lSymItem);
		detRadioButton.addItemListener(lSymItem);
		probRadioButton.addItemListener(lSymItem);
		henrionRadioButton.addItemListener(lSymItem);
		diezRadioButton.addItemListener(lSymItem);
		probsRadioButton.addItemListener(lSymItem);
		probRadioButtonDecs.addItemListener(lSymItem);
		detRadioButtonDecs.addItemListener(lSymItem);
		optimalRadioButtonDecs.addItemListener(lSymItem);
		
		
		//}}

		/** Buttons in the Relation Type dialog **/

		generalRadioButton.addItemListener(lSymItem);
		orRadioButton.addItemListener(lSymItem);
		causalMaxRadioButton.addItemListener(lSymItem);
		generalizedMaxRadioButton.addItemListener(lSymItem);
		andRadioButton.addItemListener(lSymItem);
		minRadioButton.addItemListener(lSymItem);
		xorRadioButton.addItemListener(lSymItem);
		cancelRelationDialogButton.addActionListener(lSymAction);
                cancelRelationDialogButton.registerKeyboardAction(lSymAction, javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_ENTER,0,false),JComponent.WHEN_FOCUSED);
		okRelationDialogButton.addActionListener(lSymAction);
                okRelationDialogButton.registerKeyboardAction(lSymAction, javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_ENTER,0,false),JComponent.WHEN_FOCUSED);
		/**/treeRadioButton.addItemListener(lSymItem);/* FIN LJ*/


		/** Buttons in the Parents dialog **/
		cancelParentsButton.addActionListener(lSymAction);
                cancelParentsButton.registerKeyboardAction(lSymAction, javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_ENTER,0,false),JComponent.WHEN_FOCUSED);
		okParentsButton.addActionListener(lSymAction);
                okParentsButton.registerKeyboardAction(lSymAction, javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_ENTER,0,false),JComponent.WHEN_FOCUSED);
                
         observedBox.addItemListener(lSymItem);

                /**/
	}

	/**
	 * Mark the corresponding button (optimal, prob, det) according to the existing relation for the decision
	 * Marked button will be taken into account when creating the dialog and displaying it
	 */
	private void selectButtonOptProbDecGroup() {
		// TODO Auto-generated method stub
		Relation rel;
		Hashtable<Node,Relation> fp;
		JRadioButton jrb=null;
		
		
		fp = ((IDiagram)bayesNet).getForcedPolicies();
		if (fp.containsKey(node)){
		  rel = fp.get(node);
		 
		  if (rel.isDeterministic()){
				jrb = this.detRadioButtonDecs;
			}
			else{
				jrb = this.probRadioButtonDecs;
			}
		}
		else{
			jrb = this.optimalRadioButtonDecs;
		}
		jrb.setSelected(true);
		
	}

	/**
	 * Creates an empty EditVariableDialog with no parent frame
	 */

	public EditVariableDialog()
	{
		this((Frame)null);
	}

	/**
	 * Creates an empty EditVariableDialog object and set its title with
	 * the given parameter
	 */

	public EditVariableDialog(String sTitle)
	{
		this();
		setTitle(sTitle);
	}

	/**
	 * Creates an EditVariableDialog object, fill it with the
	 * information contained in node and set its title to sTitle
	 *
	 * @param node Node whose information will be displayed into
	 * the dialog
	 * @param byTitle Contains information about how the nodes are
	 * drawn in the panels. If it is true the nodes are displayed
	 * with its title and if it is false by its name
	 * @param sTitle The title of the dialog
	 * @param isEditable Sets if the dialog will be editable to
	 * the user. Sometimes this dialog will be used only for show
	 * some information.
	 */

	public EditVariableDialog(Node node, boolean byTitle,
	                String sTitle, boolean isEditable)
	{
          
          this(sTitle);
          this.node=node;
          optionsDisabled=true;
          indRadioButton.setSelected(node.toShowIndependent());
          optionsDisabled=false;
          nodeRelation = obtainRelationOfNodeOrForcedPolicyOrGenerateIt();
          
          
          
          
          //nodeRelation=bayesNet.getRelation(node);
          newRelation=nodeRelation;
          this.byTitle=byTitle;

          treePanelTree.setRelation(nodeRelation);
          
          Class<? extends Bnet> bayesNetClass = bayesNet.getClass();
		if ((bayesNetClass == IDiagram.class)||(bayesNetClass==IDWithSVNodes.class)) {
            if (((IDiagram) bayesNet).isThereAGlobalUtilityNode() != null) {
                if (!((IDiagram) bayesNet).isThereAGlobalUtilityNode().getName().equals(node.getName())) {
                   verifyIfNonSenseConstraints(nodeRelation); /* Provisional */
                }
            }
            else {
                verifyIfNonSenseConstraints(nodeRelation); /* Provisional */
            }
          }
          
        int kindOfNode = node.getKindOfNode();
		if (kindOfNode==Node.SUPER_VALUE){
         	PotentialFunction potSV;
         	potSV=((PotentialFunction)(nodeRelation.getValues()));
            if (potSV.getFunction().getClass()==SumFunction.class){
            	addRadioButton.setSelected(true);
            }
            else{
            	multiplyRadioButton.setSelected(true);
            }
        }
          
          if (kindOfNode==Node.DECISION) {
                identifier = new String("d");
                valuesComboBox.setVisible(false);
                valuesTypeLabel.setVisible(false);
                addButton.setText(
                    localize(dialogBundle,"EditVariable.NewDecision.label"));
                removeButton.setText(
                    localize(dialogBundle,"EditVariable.DeleteDecision.label"));
                TableColumnModel tcm = valuesTable.getColumnModel();
                TableColumn tc = tcm.getColumn(0);
                tc.setHeaderValue("Decision");
                selectButtonOptProbDecGroup();
          }

          else {//Chance
            identifier = new String("s");
            String s = "EditVariable.Values.label";
            String number;
            for (int i=1; i<=6; i++) {
              number = Integer.toString(i);
              valuesComboBox.addItem(localize(dialogBundle,s+number));
            }
            valuesComboBox.setVisible(true);
            valuesTypeLabel.setVisible(true);
            addButton.setText(
                localize(dialogBundle,"EditVariable.AddState.label"));
            removeButton.setText(
                localize(dialogBundle,"EditVariable.RemoveState.label"));
            
          }
          
          boolean isNodeObserved;
          isNodeObserved = (kindOfNode==Node.OBSERVED);
          observedBox.setEnabled((bayesNetClass==Dan.class)&&((kindOfNode==Node.CHANCE)||(isNodeObserved)));
          observedBox.setSelected(kindOfNode==Node.OBSERVED);

          this.isEditable=isEditable;
          if (node.getClass() != FiniteStates.class) {
            oldStatesNumber=valuesTable.getRowCount();
          }
          else {
            oldStatesNumber=((FiniteStates) node).getStates().size();
          }
          enableDialog(isEditable);

          /* ADDED */ /* DUPLICATED CODE FOR THE MOMENT */
          /* Initialization of the parents variable */
          //Relation relation=bayesNet.getRelation(node);
          Relation relation=this.obtainRelationOfNodeOrForcedPolicyOrGenerateIt();
          NodeList nodes = new NodeList();
          //if (node.getKindOfNode() != Node.DECISION) {
            nodes=relation.getVariables().duplicate();
            nodes.removeNode(0);
          /*}
          else {
            LinkList ll=node.getParents();
            for (int i=0; i<ll.size(); i++) {
              nodes.insertNode(((Node) ((Link) ll.elementAt(i)).getTail()).copy());
            }
          }*/
          //nodes.printNames();

          for (int i=0; i<nodes.size(); i++) {
              Node iNode=nodes.elementAt(i);
            if (iNode.getClass() == FiniteStates.class) {
              FiniteStates father=(FiniteStates) nodes.elementAt(i);
              parents.addElement(father);
            }
            else if (iNode.getClass() == Continuous.class) {
              Continuous father=(Continuous) nodes.elementAt(i);
              parents.addElement(father);
            }
            else if (iNode.getKindOfNode()==Node.UTILITY)
            {
                parents.addElement(iNode);
            }
          
          }
               
          

          fillDialog();

          //if ((node.getKindOfNode() != Node.DECISION) && (nodeRelation.getValues() != null)) {
          if ((nodeRelation.getValues() != null)) {
            if ((nodeRelation.getValues().getClass() == CanonicalPotential.class) &&
                (((CanonicalPotential) nodeRelation.getValues()).getFunction().getName().equals("Or") ||
                ((CanonicalPotential) nodeRelation.getValues()).getFunction().getName().equals("CausalMax"))) {
              if (((CanonicalPotential) nodeRelation.getValues()).isHenrionVSDiez().equals("Henrion")) {
                optionsDisabled = true;
                henrionRadioButton.setSelected(true);
                optionsDisabled = false;
              }
              else {
                optionsDisabled = true;
                diezRadioButton.setSelected(true);
                optionsDisabled = false;
              }
            }
          }
          /* END ADDED */

          /*We fill the comboBox for the edition of probability trees*/
          if ((nodeRelation != null) && (nodeRelation.getValues() != null)) {
            if (nodeRelation.getValues().getClass() == PotentialTree.class) {
              isTree = true;
                typeRelationButton.setText(
                      localize(dialogBundle,"EditVariable.relationDialogProbabilityTree.label"));
                GridBagConstraints c = ((GridBagLayout) treePanel.getLayout()).getConstraints(relationTypePanel);
                c = setGridBagConstraints (0,0,2,1,0.7,0.15);
                ((GridBagLayout)treePanel.getLayout()).setConstraints(relationTypePanel, c);
                treePanel.add(relationTypePanel);

                ((CardLayout)relationPanelCard.getLayout()).show(relationPanelCard,"TREE");
              
              
                ProbabilityTree T = ((PotentialTree)nodeRelation.getValues()).getTree();
              
                nodeRelation.setComment("");
              if (T!=null){
                treePanelTree.setTree(T);
                treePanelTree.repaint();              
              }
              
              
            }else  if (nodeRelation.getValues().getClass() == PotentialContinuousPT.class) {
              isTree = true;
                typeRelationButton.setText(
                      localize(dialogBundle,"EditVariable.relationDialogProbabilityTree.label"));
                GridBagConstraints c = ((GridBagLayout) treePanel.getLayout()).getConstraints(relationTypePanel);
                c = setGridBagConstraints (0,0,2,1,0.7,0.15);
                ((GridBagLayout)treePanel.getLayout()).setConstraints(relationTypePanel, c);
                treePanel.add(relationTypePanel);

                ((CardLayout)relationPanelCard.getLayout()).show(relationPanelCard,"TREE");

              
              ContinuousProbabilityTree T = ((PotentialContinuousPT)nodeRelation.getValues()).getTree();
              if (T!=null){
              treePanelTree.setTree(T);
              //treePanelTree.repaint();              
              }
              nodeRelation.setComment("");
              
            } else
            {
              isTree = false;
              ((CardLayout)relationPanelCard.getLayout()).show(relationPanelCard,"TABLE");
            }
            
          }
          else {
            isTree = false;
            ((CardLayout)relationPanelCard.getLayout()).show(relationPanelCard,"TABLE");
          }
          comboNodes.addItem(node.getName());
          for (int i= 0; i < parents.size();i++){
            comboNodes.addItem(((Node)parents.elementAt(i)).getName());
          }
          if (!isTree)
            generalRadioButton.setSelected(true);
          else
            treeRadioButton.setSelected(true);
          /**/
        
          if(node.getClass()==Continuous.class){
              String t=new String("");
              minCVText.setText(t.valueOf(((Continuous)node).getMin()));
              maxCVText.setText(t.valueOf(((Continuous)node).getMax()));
              precisionCVText.setText(t.valueOf(((Continuous)node).getPrecision()));
              undefValCVText.setText(t.valueOf(((Continuous)node).undefValue()));
              unitCVText.setText(((Continuous)node).getUnit());

              
          }
          
                 
        
        }

	private Relation obtainRelationOfNodeOrForcedPolicyOrGenerateIt() {
		// TODO Auto-generated method stub
		Relation rel;
		Hashtable<Node,Relation> fp;
		//if (((bayesNet.getClass()==IDiagram.class)||(bayesNet.getClass()==IDWithSVNodes.class))
		if ((IDiagram.class.isInstance(bayesNet))
				          &&(node.getKindOfNode()==Node.DECISION)){
					fp = ((IDiagram)bayesNet).getForcedPolicies();
					if (fp.containsKey(node)){
					  rel = fp.get(node);
					}
					else{
		        	  
		        	  //We haven't forced any policy for the decision
		        		  rel = constructRelationWithPast(node);
		        		  
		        	  }
		          }
		          else{
		        	  rel =bayesNet.getRelation(node);
		          }
		return rel;
	}

	private Relation constructRelationWithPast(Node node2) {
		// TODO Auto-generated method stub
		NodeList past;
		  NodeList vars;
		  Relation rel;
		  
		  vars = new NodeList();
		  vars.insertNode(node);
		  past = ((IDiagram)bayesNet).getPast(node);
		  vars.join(past);
		  rel = new Relation(vars.getNodes());
		  return rel;
	}

	/* END: CONSTRUCTORS */
        
       
        private void adaptRelationPanelForDecisions() {
		// TODO Auto-generated method stub
        	editVarTabbedPane.setTitleAt(3,localize(dialogBundle,"EditVariable.Policy.label"));
  
        	
	}

		/**
         * In case of a NonSenseConstraint is present and affects this node, the
         * relation values and the children's ones are accordingly modified for the
         * \"VariableDoesntMakeSense\" not to be shown...
         */

        private void verifyIfNonSenseConstraints(Relation theRelation) {

          Vector theParents = new Vector();
          Vector theChildren = new Vector();
          NodeList nodes = new NodeList();
          if (node.getKindOfNode() != Node.DECISION) {
            nodes=theRelation.getVariables().duplicate();
            nodes.removeNode(0);
          }
          else {
            LinkList ll=node.getParents();
            for (int i=0; i<ll.size(); i++) {
              nodes.insertNode(((Node) ((Link) ll.elementAt(i)).getTail()).copy());
            }
          }

          for (int i=0; i<nodes.size(); i++) {
            //FiniteStates father=(FiniteStates) nodes.elementAt(i);
              /* MANOLO> Voy a cambiar la línea anterior por la siguiente para permitir que los padres en una relación sean nodos
               de utilidad */
              Node father= nodes.elementAt(i);
            theParents.addElement(father);
          }

          for (int i=0; i<node.getChildrenNodes().size(); i++) {
            Node child=(Node) node.getChildrenNodes().elementAt(i);
            theChildren.addElement(child);
          }

          boolean isNonSense = false;

          if (node.getKindOfNode() == Node.DECISION) {
            Vector rl = bayesNet.getRelationList();

            for (int i=0; i<rl.size(); i++) {
              if (((Relation) rl.elementAt(i)).getKind() == Relation.CONSTRAINT) {
                if (((Relation) rl.elementAt(i)).getComment().equals("Non sense constraint")) {
                  if (((Node) ((Relation) rl.elementAt(i)).getVariables().elementAt(0)).getName().equals(node.getName())) {
                    //theConstraintState = ((FiniteStates) node).getState(((FiniteStates) node).getNumStates()-1);
                    theConstraintState = (String) ((LogicalExpression) ((Relation) rl.elementAt(i)).getValues()).getAntecedent().getValuesSet().getValues().elementAt(0);
                  }
                }
              }
            }

            for (int i=0; i<theChildren.size(); i++) {
              int position = -1;
              isNonSense = false;
              if (theChildren.elementAt(i).getClass() == FiniteStates.class) {
                for (int j=0; j<((FiniteStates) theChildren.elementAt(i)).getStates().size(); j++) {
                  if (((FiniteStates) theChildren.elementAt(i)).getState(j).equals("\"VariableDoesntMakeSense\"")) {
                    isNonSense = true;
                    position = j;
                    break;
                  }
                }
              }

              if (isNonSense) {
                theRelation = bayesNet.getRelation((Node) theChildren.elementAt(i));
                hasNSConstraints = true;

                if (theRelation.getValues().getClass() == PotentialTable.class) {
                  Configuration config = new Configuration(((PotentialTable) theRelation.getValues()).getVariables());
                  Vector finalValues = new Vector();
                  for (int j=0; j<((PotentialTable) theRelation.getValues()).getSize(); j++) {
                    if ((!(config.getValue(((FiniteStates) theChildren.elementAt(i)).getName()) == position))) {
                      if (!(theConstraintState.equals("")) && (!(config.getValue(((FiniteStates) node).getName()) == (((FiniteStates) node).getNumStates()-1)))) {
                        finalValues.addElement(new Double(((PotentialTable) theRelation.getValues()).getValue(j)));
                      }
                      else if (theConstraintState.equals("")) {
                        finalValues.addElement(new Double(((PotentialTable) theRelation.getValues()).getValue(j)));
                      }
                    }
                    config.nextConfiguration();
                  }
                  Vector theStats = new Vector();
                  for (int j=0; j<((FiniteStates) theChildren.elementAt(i)).getStates().size(); j++) {
                    if (j != position) {
                      theStats.addElement(((FiniteStates) theChildren.elementAt(i)).getState(j));
                    }
                  }
                  FiniteStates toChange = new FiniteStates();
                  toChange = (FiniteStates) theChildren.elementAt(i);
                  toChange.setStates(theStats);
                  childrenWithNSConstraints.add((FiniteStates) toChange);
                  double[] finVal = new double[(int) finalValues.size()];
                  for (int j=0; j<finalValues.size(); j++) {
                    finVal[j] = ((Double) finalValues.elementAt(j)).doubleValue();
                  }

                  Vector theStates = new Vector();
                  for (int k=0; k<((FiniteStates) node).getNumStates(); k++) {
                    if (!((FiniteStates) node).getState(k).equals(theConstraintState)) {
                      theStates.addElement(((FiniteStates) node).getState(k));
                    }
                  }
                  ((FiniteStates) node).setStates(theStates);

                  PotentialTable pt = new PotentialTable(theRelation.getValues().getVariables());
                  pt.setValues(finVal);
                  theRelation.setValues(pt);

                  theStates = new Vector();
                  for (int k=0; k<((FiniteStates) node).getNumStates(); k++) {
                    theStates.addElement(((FiniteStates) node).getState(k));
                  }
                  if (!theConstraintState.equals("")) {
                    theStates.addElement(theConstraintState);
                  }
                  ((FiniteStates) node).setStates(theStates);
                } 

                //Introducido por jruiz
                else if (theRelation.getValues().getClass() == GeneralizedPotentialTable.class) {
                  Configuration config = new Configuration(((GeneralizedPotentialTable) theRelation.getValues()).getVariables());
                  Vector finalValues = new Vector();
                  for (int j=0; j<((GeneralizedPotentialTable) theRelation.getValues()).getSize(); j++) {
                    if ((!(config.getValue(((FiniteStates) theChildren.elementAt(i)).getName()) == position))) {
                      if (!(theConstraintState.equals("")) && (!(config.getValue(((FiniteStates) node).getName()) == (((FiniteStates) node).getNumStates()-1)))) {
                        finalValues.addElement(new Double(((GeneralizedPotentialTable) theRelation.getValues()).getValue(j)));
                      }
                      else if (theConstraintState.equals("")) {
                        finalValues.addElement(new Double(((GeneralizedPotentialTable) theRelation.getValues()).getValue(j)));
                      }
                    }
                    config.nextConfiguration();
                  }
                  Vector theStats = new Vector();
                  for (int j=0; j<((FiniteStates) theChildren.elementAt(i)).getStates().size(); j++) {
                    if (j != position) {
                      theStats.addElement(((FiniteStates) theChildren.elementAt(i)).getState(j));
                    }
                  }
                  FiniteStates toChange = new FiniteStates();
                  toChange = (FiniteStates) theChildren.elementAt(i);
                  toChange.setStates(theStats);
                  childrenWithNSConstraints.add((FiniteStates) toChange);
                  double[] finVal = new double[(int) finalValues.size()];
                  for (int j=0; j<finalValues.size(); j++) {
                    finVal[j] = ((Double) finalValues.elementAt(j)).doubleValue();
                  }

                  Vector theStates = new Vector();
                  for (int k=0; k<((FiniteStates) node).getNumStates(); k++) {
                    if (!((FiniteStates) node).getState(k).equals(theConstraintState)) {
                      theStates.addElement(((FiniteStates) node).getState(k));
                    }
                  }
                  ((FiniteStates) node).setStates(theStates);

                  GeneralizedPotentialTable pt = new GeneralizedPotentialTable(theRelation.getValues().getVariables());
                  pt.setValues(finVal);
                  theRelation.setValues(pt);

                  theStates = new Vector();
                  for (int k=0; k<((FiniteStates) node).getNumStates(); k++) {
                    theStates.addElement(((FiniteStates) node).getState(k));
                  }
                  if (!theConstraintState.equals("")) {
                    theStates.addElement(theConstraintState);
                  }
                  ((FiniteStates) node).setStates(theStates);
                }//Fin introducido por jruiz

                else if (theRelation.getValues().getClass() == CanonicalPotential.class) {
                  /*TO DO*/
                }
              }
            }

            Vector theStates = new Vector();
            for (int i=0; i<((FiniteStates) node).getNumStates(); i++) {
                // Modified by mluque
              if ((!((FiniteStates) node).getState(i).equals(theConstraintState))||(node.getKindOfNode()==Node.DECISION)) {
//                              if ((!((FiniteStates) node).getState(i).equals(theConstraintState))) {
                theStates.addElement(((FiniteStates) node).getState(i));
              }
            }
            ((FiniteStates) node).setStates(theStates);
          }
          else if (node.getKindOfNode() == Node.CHANCE) {
            for (int i=0; i<((FiniteStates) node).getStates().size(); i++) {
              if (((FiniteStates) node).getState(i).equals("\"VariableDoesntMakeSense\"")) {
                theConstraintState = "\"VariableDoesntMakeSense\"";
              }
            }

            /* THE CHILDREN */
            for (int i=0; i<theChildren.size(); i++) {
              int position = -1;
              isNonSense = false;
              if (theChildren.elementAt(i).getClass() == FiniteStates.class) {
                for (int j=0; j<((FiniteStates) theChildren.elementAt(i)).getStates().size(); j++) {
                  if (((FiniteStates) theChildren.elementAt(i)).getState(j).equals("\"VariableDoesntMakeSense\"")) {
                    isNonSense = true;
                    position = j;
                    break;
                  }
                }
              }

              if (isNonSense) {
                theRelation = bayesNet.getRelation((Node) theChildren.elementAt(i));
                hasNSConstraints = true;

                if (theRelation.getValues().getClass() == PotentialTable.class) {
                  Configuration config = new Configuration(((PotentialTable) theRelation.getValues()).getVariables());
                  Vector finalValues = new Vector();
                  for (int j=0; j<((PotentialTable) theRelation.getValues()).getSize(); j++) {
                    if ((!(config.getValue(((FiniteStates) theChildren.elementAt(i)).getName()) == position))) {
                      if (!(theConstraintState.equals("")) && (!(config.getValue(((FiniteStates) node).getName()) == (((FiniteStates) node).getNumStates()-1)))) {
                        finalValues.addElement(new Double(((PotentialTable) theRelation.getValues()).getValue(j)));
                      }
                      else if (theConstraintState.equals("")) {
                        finalValues.addElement(new Double(((PotentialTable) theRelation.getValues()).getValue(j)));
                      }
                    }
                    config.nextConfiguration();
                  }
                  Vector theStats = new Vector();
                  for (int j=0; j<((FiniteStates) theChildren.elementAt(i)).getStates().size(); j++) {
                    if (j != position) {
                      theStats.addElement(((FiniteStates) theChildren.elementAt(i)).getState(j));
                    }
                  }
                  FiniteStates toChange = new FiniteStates();
                  toChange = (FiniteStates) theChildren.elementAt(i);
                  toChange.setStates(theStats);
                  childrenWithNSConstraints.add((FiniteStates) toChange);
                  double[] finVal = new double[(int) finalValues.size()];
                  for (int j=0; j<finalValues.size(); j++) {
                    finVal[j] = ((Double) finalValues.elementAt(j)).doubleValue();
                  }

                  Vector theStates = new Vector();
                  for (int k=0; k<((FiniteStates) node).getNumStates(); k++) {
                    if (!((FiniteStates) node).getState(k).equals(theConstraintState)) {
                      theStates.addElement(((FiniteStates) node).getState(k));
                    }
                  }
                  ((FiniteStates) node).setStates(theStates);

                  PotentialTable pt = new PotentialTable(theRelation.getValues().getVariables());
                  pt.setValues(finVal);
                  theRelation.setValues(pt);

                  theStates = new Vector();
                  for (int k=0; k<((FiniteStates) node).getNumStates(); k++) {
                    theStates.addElement(((FiniteStates) node).getState(k));
                  }
                  if (!theConstraintState.equals("")) {
                    theStates.addElement(theConstraintState);
                  }
                  ((FiniteStates) node).setStates(theStates);
                }

                //Introducido por jruiz
                else if (theRelation.getValues().getClass() == GeneralizedPotentialTable.class) {
                  Configuration config = new Configuration(((GeneralizedPotentialTable) theRelation.getValues()).getVariables());
                  Vector finalValues = new Vector();
                  for (int j=0; j<((GeneralizedPotentialTable) theRelation.getValues()).getSize(); j++) {
                    if ((!(config.getValue(((FiniteStates) theChildren.elementAt(i)).getName()) == position))) {
                      if (!(theConstraintState.equals("")) && (!(config.getValue(((FiniteStates) node).getName()) == (((FiniteStates) node).getNumStates()-1)))) {
                        finalValues.addElement(new Double(((GeneralizedPotentialTable) theRelation.getValues()).getValue(j)));
                      }
                      else if (theConstraintState.equals("")) {
                        finalValues.addElement(new Double(((GeneralizedPotentialTable) theRelation.getValues()).getValue(j)));
                      }
                    }
                    config.nextConfiguration();
                  }
                  Vector theStats = new Vector();
                  for (int j=0; j<((FiniteStates) theChildren.elementAt(i)).getStates().size(); j++) {
                    if (j != position) {
                      theStats.addElement(((FiniteStates) theChildren.elementAt(i)).getState(j));
                    }
                  }
                  FiniteStates toChange = new FiniteStates();
                  toChange = (FiniteStates) theChildren.elementAt(i);
                  toChange.setStates(theStats);
                  childrenWithNSConstraints.add((FiniteStates) toChange);
                  double[] finVal = new double[(int) finalValues.size()];
                  for (int j=0; j<finalValues.size(); j++) {
                    finVal[j] = ((Double) finalValues.elementAt(j)).doubleValue();
                  }

                  Vector theStates = new Vector();
                  for (int k=0; k<((FiniteStates) node).getNumStates(); k++) {
                    if (!((FiniteStates) node).getState(k).equals(theConstraintState)) {
                      theStates.addElement(((FiniteStates) node).getState(k));
                    }
                  }
                  ((FiniteStates) node).setStates(theStates);

                  GeneralizedPotentialTable pt = new GeneralizedPotentialTable(theRelation.getValues().getVariables());
                  pt.setValues(finVal);
                  theRelation.setValues(pt);

                  theStates = new Vector();
                  for (int k=0; k<((FiniteStates) node).getNumStates(); k++) {
                    theStates.addElement(((FiniteStates) node).getState(k));
                  }
                  if (!theConstraintState.equals("")) {
                    theStates.addElement(theConstraintState);
                  }
                  ((FiniteStates) node).setStates(theStates);
                }//Fin introducido por jruiz

                else if (theRelation.getValues().getClass() == CanonicalPotential.class) {
                  /*TO DO*/
                }
              }
            }

            /* THE PARENTS & THE NODE ITSELF */
            theRelation = bayesNet.getRelation(node);

            if (theRelation.getValues().getClass() == PotentialTable.class) {
              for (int i=0; i<theParents.size(); i++) {
                int position = -1;
                isNonSense = false;
                if ((((Node) theParents.elementAt(i)).getKindOfNode() == Node.DECISION) ||
                    (((Node) theParents.elementAt(i)).getKindOfNode() == Node.CHANCE)) {
                  if (((Node) theParents.elementAt(i)).getKindOfNode() == Node.CHANCE) {
                    for (int j=0; j<((FiniteStates) theParents.elementAt(i)).getStates().size(); j++) {
                      if (((FiniteStates) theParents.elementAt(i)).getState(j).equals("\"VariableDoesntMakeSense\"")) {
                        isNonSense = true;
                        position = j;
                        break;
                      }
                    }
                  }
                  else if (((Node) theParents.elementAt(i)).getKindOfNode() == Node.DECISION) {
                    Vector rl = bayesNet.getRelationList();

                    for (int k=0; k<rl.size(); k++) {
                      if (((Relation) rl.elementAt(k)).getKind() == Relation.CONSTRAINT) {
                        if (((Relation) rl.elementAt(k)).getComment().equals("Non sense constraint")) {
                          if ((((Node) ((Relation) rl.elementAt(k)).getVariables().elementAt(0)).getName().equals(((Node) theParents.elementAt(i)).getName()) &&
                              (((Node) ((Relation) rl.elementAt(k)).getVariables().elementAt(1)).getName().equals(node.getName())))){
                            isNonSense = true;
                            String decState = (String)((LogicalExpression) ((Relation) rl.elementAt(k)).getValues()).getAntecedent().getValuesSet().getValues().elementAt(0); 
                            //position = ((FiniteStates) theParents.elementAt(i)).getNumStates()-1;
                            //theDecisionStates.addElement(((FiniteStates) theParents.elementAt(i)).getState(((FiniteStates) theParents.elementAt(i)).getNumStates()-1));
                            theDecisionStates.addElement(decState);
                            for (int m=0; m<((FiniteStates) theParents.elementAt(i)).getNumStates(); m++) {
                                if (decState.equals(((FiniteStates) theParents.elementAt(i)).getState(m))) {
                                    position=m;
                                    break;
                                }
                            }
                            break;
                          }
                        }
                      }
                    }
                  }

                  if (isNonSense) {
                    hasNSConstraints = true;
                    Configuration config = new Configuration(((PotentialTable) theRelation.getValues()).getVariables());
                    Vector finalValues = new Vector();
                    for (int j=0; j<((PotentialTable) theRelation.getValues()).getSize(); j++) {
                      if (!(config.getValue(((FiniteStates) theParents.elementAt(i)).getName()) == position)) {
                        finalValues.addElement(new Double(((PotentialTable) theRelation.getValues()).getValue(j)));
                      }
                      config.nextConfiguration();
                    }
                    Vector theStats = new Vector();
                    for (int j=0; j<((FiniteStates) theParents.elementAt(i)).getStates().size(); j++) {
                      if (j != position) {
                        theStats.addElement(((FiniteStates) theParents.elementAt(i)).getState(j));
                      }
                    }
                    FiniteStates toChange = new FiniteStates();
                    for (int j=0; j<((PotentialTable) theRelation.getValues()).getVariables().size(); j++) {
                      if (((FiniteStates) ((PotentialTable) theRelation.getValues()).getVariables().elementAt(j)).getName().equals(((FiniteStates) theParents.elementAt(i)).getName())) {
                        toChange = (FiniteStates) ((PotentialTable) theRelation.getValues()).getVariables().elementAt(j);
                        break;
                      }
                    }
                    toChange.setStates(theStats);
                    parentsWithNSConstraints.add((FiniteStates) toChange);
                    double[] finVal = new double[(int) finalValues.size()];
                    for (int j=0; j<finalValues.size(); j++) {
                      finVal[j] = ((Double) finalValues.elementAt(j)).doubleValue();
                    }
                    PotentialTable pt = new PotentialTable(theRelation.getValues().getVariables());
                    pt.setValues(finVal);
                    theRelation.setValues(pt);
                  }
                }
              }

              if (!theConstraintState.equals("")) {
              //if (false) {
                Vector theValues = new Vector();
                Configuration config = new Configuration(theRelation.getValues().getVariables());

                for (int j=0; j<theRelation.getValues().getSize(); j++) {
                  if (!((FiniteStates) node).getState(config.getValue(node.getName())).equals(theConstraintState)) {
                    theValues.addElement(new Double(((PotentialTable) theRelation.getValues()).getValue(config)));
                  }
                  config.nextConfiguration();
                }

                Vector theStates = new Vector();
                for (int i=0; i<((FiniteStates) node).getNumStates(); i++) {
                  if (!((FiniteStates) node).getState(i).equals(theConstraintState)) {
                    theStates.addElement(((FiniteStates) node).getState(i));
                  }
                }
                ((FiniteStates) node).setStates(theStates);

                PotentialTable pt = new PotentialTable(theRelation.getValues().getVariables());

                double[] theVals = new double[(int) theValues.size()];
                for (int j=0; j<theValues.size(); j++) {
                  theVals[j] = ((Double) theValues.elementAt(j)).doubleValue();
                }

                pt.setValues(theVals);
                theRelation.setValues(pt);
              }
            }
            else if (theRelation.getValues().getClass() == CanonicalPotential.class) {
              /* TO DO */
            }
          }
          else if (node.getKindOfNode() == Node.UTILITY) {
            for (int i=0; i<theParents.size(); i++) {
              int position = -1;
              isNonSense = false;
              if ((((Node) theParents.elementAt(i)).getKindOfNode() == Node.DECISION) ||
                  (((Node) theParents.elementAt(i)).getKindOfNode() == Node.CHANCE)) {
                for (int j=0; j<((FiniteStates) theParents.elementAt(i)).getStates().size(); j++) {
                  if (((FiniteStates) theParents.elementAt(i)).getState(j).equals("\"VariableDoesntMakeSense\"")) {
                    isNonSense = true;
                    position = j;
                    break;
                  }
                }

                if (isNonSense) {
                  hasNSConstraints = true;
                  Configuration config = new Configuration(((PotentialTable) theRelation.getValues()).getVariables());
                  Vector finalValues = new Vector();
                  for (int j=0; j<((PotentialTable) theRelation.getValues()).getSize(); j++) {
                    if (!(config.getValue(((FiniteStates) theParents.elementAt(i)).getName()) == position)) {
                      finalValues.addElement(new Double(((PotentialTable) theRelation.getValues()).getValue(j)));
                    }
                    config.nextConfiguration();
                  }
                  Vector theStats = new Vector();
                  for (int j=0; j<((FiniteStates) theParents.elementAt(i)).getStates().size(); j++) {
                    if (j != position) {
                      theStats.addElement(((FiniteStates) theParents.elementAt(i)).getState(j));
                    }
                  }
                  FiniteStates toChange = new FiniteStates();
                  for (int j=0; j<((PotentialTable) theRelation.getValues()).getVariables().size(); j++) {
                    if (((FiniteStates) ((PotentialTable) theRelation.getValues()).getVariables().elementAt(j)).getName().equals(((FiniteStates) theParents.elementAt(i)).getName())) {
                      toChange = (FiniteStates) ((PotentialTable) theRelation.getValues()).getVariables().elementAt(j);
                      break;
                    }
                  }
                  toChange.setStates(theStats);
                  parentsWithNSConstraints.add((FiniteStates) toChange);
                  double[] finVal = new double[(int) finalValues.size()];
                  for (int j=0; j<finalValues.size(); j++) {
                    finVal[j] = ((Double) finalValues.elementAt(j)).doubleValue();
                  }
                  PotentialTable pt = new PotentialTable(theRelation.getValues().getVariables());
                  pt.setValues(finVal);
                  theRelation.setValues(pt);
                }
              }
            }
          }
        }

        /**
         * Before disposing, the changes made in the previous method have to be
         * undone...
         */

        private void readdIfNonSenseConstraints() {
          if (node.getKindOfNode() == Node.DECISION) {
            if (!theConstraintState.equals("")) {
              Vector theStates = new Vector();

              for (int i=0; i<((FiniteStates) node).getNumStates(); i++) {
                theStates.addElement(((FiniteStates) node).getState(i));
              }
              /* Modified by mluque */
              if (node.getKindOfNode()!=Node.DECISION)
              {
                theStates.addElement(theConstraintState);
              }

              ((FiniteStates) node).setStates(theStates);
            }

            for (int i=0; i<childrenWithNSConstraints.size(); i++) {
              Relation theRelation = bayesNet.getRelation((Node) childrenWithNSConstraints.elementAt(i));
              double[] theInitialValues = ((PotentialTable) theRelation.getValues()).getValues();

              Vector finalStates = new Vector();
              for (int j=0; j<((FiniteStates) childrenWithNSConstraints.elementAt(i)).getNumStates(); j++) {
                finalStates.addElement(((FiniteStates) childrenWithNSConstraints.elementAt(i)).getState(j));
              }
              finalStates.addElement("\"VariableDoesntMakeSense\"");
              ((FiniteStates) childrenWithNSConstraints.elementAt(i)).setStates(finalStates);

              if (theRelation.getValues().getClass() == PotentialTable.class) {

                PotentialTable pt = new PotentialTable(theRelation.getVariables());
                Configuration config = new Configuration(theRelation.getVariables());

                int k=0;
                for (int j=0; j<pt.getSize(); j++) {
                  if (!(theConstraintState.equals("")) && !(config.getValue(node.getName()) == (((FiniteStates) node).getNumStates() - 1))) {
                    if (!(config.getValue(((FiniteStates) childrenWithNSConstraints.elementAt(i)).getName()) == (((FiniteStates) childrenWithNSConstraints.elementAt(i)).getNumStates() - 1))) {
                      pt.setValue(config,theInitialValues[k]);
                      k++;
                    }
                  }
                  else if (theConstraintState.equals("")) {
                    if (!(config.getValue(((FiniteStates) childrenWithNSConstraints.elementAt(i)).getName()) == (((FiniteStates) childrenWithNSConstraints.elementAt(i)).getNumStates() - 1))) {
                      pt.setValue(config,theInitialValues[k]);
                      k++;
                    }
                  }
                  config.nextConfiguration();
                }

                for (int l=0; l<pt.getSize()/((FiniteStates) childrenWithNSConstraints.elementAt(i)).getNumStates(); l++) {
                  double doubleValue=0.0;
                  for (int j=0; j<((FiniteStates) childrenWithNSConstraints.elementAt(i)).getNumStates()-1; j++) {
                    doubleValue=doubleValue+pt.getValue((int) (j*pt.getSize()/((FiniteStates) childrenWithNSConstraints.elementAt(i)).getNumStates())+l);
                  }
                  double lastStateValue = Math.round((1-doubleValue)*100000);
                  lastStateValue = lastStateValue/100000;
                  pt.setValue((int) ((((FiniteStates) childrenWithNSConstraints.elementAt(i)).getNumStates()-1)*pt.getSize()/((FiniteStates) childrenWithNSConstraints.elementAt(i)).getNumStates())+l,lastStateValue);
                }
                theRelation.setValues(pt);
              }

              //Introducido por jruiz
              else if (theRelation.getValues().getClass() == GeneralizedPotentialTable.class) {

                GeneralizedPotentialTable pt = new GeneralizedPotentialTable(theRelation.getVariables());
                Configuration config = new Configuration(theRelation.getVariables());

                int k=0;
                for (int j=0; j<pt.getSize(); j++) {
                  if (!(theConstraintState.equals("")) && !(config.getValue(node.getName()) == (((FiniteStates) node).getNumStates() - 1))) {
                    if (!(config.getValue(((FiniteStates) childrenWithNSConstraints.elementAt(i)).getName()) == (((FiniteStates) childrenWithNSConstraints.elementAt(i)).getNumStates() - 1))) {
                      pt.setValue(config,theInitialValues[k]);
                      k++;
                    }
                  }
                  else if (theConstraintState.equals("")) {
                    if (!(config.getValue(((FiniteStates) childrenWithNSConstraints.elementAt(i)).getName()) == (((FiniteStates) childrenWithNSConstraints.elementAt(i)).getNumStates() - 1))) {
                      pt.setValue(config,theInitialValues[k]);
                      k++;
                    }
                  }
                  config.nextConfiguration();
                }

                for (int l=0; l<pt.getSize()/((FiniteStates) childrenWithNSConstraints.elementAt(i)).getNumStates(); l++) {
                  double doubleValue=0.0;
                  for (int j=0; j<((FiniteStates) childrenWithNSConstraints.elementAt(i)).getNumStates()-1; j++) {
                    doubleValue=doubleValue+pt.getValue((int) (j*pt.getSize()/((FiniteStates) childrenWithNSConstraints.elementAt(i)).getNumStates())+l);
                  }
                  double lastStateValue = Math.round((1-doubleValue)*100000);
                  lastStateValue = lastStateValue/100000;
                  pt.setValue((int) ((((FiniteStates) childrenWithNSConstraints.elementAt(i)).getNumStates()-1)*pt.getSize()/((FiniteStates) childrenWithNSConstraints.elementAt(i)).getNumStates())+l,lastStateValue);
                }
                theRelation.setValues(pt);
              }//Fin introducido por jruiz

              else if (theRelation.getValues().getClass() == CanonicalPotential.class) {
                /* TO DO */
              }
            }
          }
          else if (node.getKindOfNode() == Node.CHANCE) {

            /* CHILDREN FIRST */

            for (int i=0; i<childrenWithNSConstraints.size(); i++) {
              Relation theRelation = bayesNet.getRelation((Node) childrenWithNSConstraints.elementAt(i));
              double[] theInitialValues = ((PotentialTable) theRelation.getValues()).getValues();

              Vector finalStates = new Vector();
              for (int j=0; j<((FiniteStates) childrenWithNSConstraints.elementAt(i)).getNumStates(); j++) {
                finalStates.addElement(((FiniteStates) childrenWithNSConstraints.elementAt(i)).getState(j));
              }
              finalStates.addElement("\"VariableDoesntMakeSense\"");
              ((FiniteStates) childrenWithNSConstraints.elementAt(i)).setStates(finalStates);

              if (!theConstraintState.equals("")) {
                Vector theStates = new Vector();

                for (int k=0; k<((FiniteStates) node).getNumStates(); k++) {
                  theStates.addElement(((FiniteStates) node).getState(k));
                }

                theStates.addElement(theConstraintState);

                ((FiniteStates) node).setStates(theStates);
              }

              if (theRelation.getValues().getClass() == PotentialTable.class) {

                PotentialTable pt = new PotentialTable(theRelation.getVariables());
                Configuration config = new Configuration(theRelation.getVariables());

                int k=0;
                for (int j=0; j<pt.getSize(); j++) {
                  if (!(theConstraintState.equals("")) && !(config.getValue(node.getName()) == (((FiniteStates) node).getNumStates() - 1))) {
                    if (!(config.getValue(((FiniteStates) childrenWithNSConstraints.elementAt(i)).getName()) == (((FiniteStates) childrenWithNSConstraints.elementAt(i)).getNumStates() - 1))) {
                      pt.setValue(config,theInitialValues[k]);
                      k++;
                    }
                  }
                  else if (theConstraintState.equals("")) {
                    if (!(config.getValue(((FiniteStates) childrenWithNSConstraints.elementAt(i)).getName()) == (((FiniteStates) childrenWithNSConstraints.elementAt(i)).getNumStates() - 1))) {
                      pt.setValue(config,theInitialValues[k]);
                      k++;
                    }
                  }
                  config.nextConfiguration();
                }

                for (int l=0; l<pt.getSize()/((FiniteStates) childrenWithNSConstraints.elementAt(i)).getNumStates(); l++) {
                  double doubleValue=0.0;
                  for (int j=0; j<((FiniteStates) childrenWithNSConstraints.elementAt(i)).getNumStates()-1; j++) {
                    doubleValue=doubleValue+pt.getValue((int) (j*pt.getSize()/((FiniteStates) childrenWithNSConstraints.elementAt(i)).getNumStates())+l);
                  }
                  double lastStateValue = Math.round((1-doubleValue)*100000);
                  lastStateValue = lastStateValue/100000;
                  pt.setValue((int) ((((FiniteStates) childrenWithNSConstraints.elementAt(i)).getNumStates()-1)*pt.getSize()/((FiniteStates) childrenWithNSConstraints.elementAt(i)).getNumStates())+l,lastStateValue);
                }
                theRelation.setValues(pt);
              }

              //Introducido por jruiz
              else if (theRelation.getValues().getClass() == GeneralizedPotentialTable.class) {

                GeneralizedPotentialTable pt = new GeneralizedPotentialTable(theRelation.getVariables());
                Configuration config = new Configuration(theRelation.getVariables());

                int k=0;
                for (int j=0; j<pt.getSize(); j++) {
                  if (!(theConstraintState.equals("")) && !(config.getValue(node.getName()) == (((FiniteStates) node).getNumStates() - 1))) {
                    if (!(config.getValue(((FiniteStates) childrenWithNSConstraints.elementAt(i)).getName()) == (((FiniteStates) childrenWithNSConstraints.elementAt(i)).getNumStates() - 1))) {
                      pt.setValue(config,theInitialValues[k]);
                      k++;
                    }
                  }
                  else if (theConstraintState.equals("")) {
                    if (!(config.getValue(((FiniteStates) childrenWithNSConstraints.elementAt(i)).getName()) == (((FiniteStates) childrenWithNSConstraints.elementAt(i)).getNumStates() - 1))) {
                      pt.setValue(config,theInitialValues[k]);
                      k++;
                    }
                  }
                  config.nextConfiguration();
                }

                for (int l=0; l<pt.getSize()/((FiniteStates) childrenWithNSConstraints.elementAt(i)).getNumStates(); l++) {
                  double doubleValue=0.0;
                  for (int j=0; j<((FiniteStates) childrenWithNSConstraints.elementAt(i)).getNumStates()-1; j++) {
                    doubleValue=doubleValue+pt.getValue((int) (j*pt.getSize()/((FiniteStates) childrenWithNSConstraints.elementAt(i)).getNumStates())+l);
                  }
                  double lastStateValue = Math.round((1-doubleValue)*100000);
                  lastStateValue = lastStateValue/100000;
                  pt.setValue((int) ((((FiniteStates) childrenWithNSConstraints.elementAt(i)).getNumStates()-1)*pt.getSize()/((FiniteStates) childrenWithNSConstraints.elementAt(i)).getNumStates())+l,lastStateValue);
                }
                theRelation.setValues(pt);
              }//Fin introducido por jruiz

              else if (theRelation.getValues().getClass() == CanonicalPotential.class) {
                /* TO DO */
              }

              if (!theConstraintState.equals("")) {
                Vector theStates = new Vector();

                for (int k=0; k<((FiniteStates) node).getNumStates(); k++) {
                  if (!((FiniteStates) node).getState(k).equals(theConstraintState)) {
                    theStates.addElement(((FiniteStates) node).getState(k));
                  }
                }

                ((FiniteStates) node).setStates(theStates);
              }
            }

            /* THE PARENTS & THE NODE ITSELF */

            for (int i=0; i<parentsWithNSConstraints.size(); i++) {
              if (((Node) parentsWithNSConstraints.elementAt(i)).getKindOfNode() == Node.DECISION) {
                if (nodeRelation.getValues().getClass() == PotentialTable.class) {
                  Vector theInVals = new Vector();
                  for (int j=0; j<((PotentialTable) nodeRelation.getValues()).getSize(); j++) {
                    theInVals.add(new Double(((PotentialTable) nodeRelation.getValues()).getValue(j)));
                  }

                  Vector theStates = new Vector();
                  for (int j=0; j<((FiniteStates) parentsWithNSConstraints.elementAt(i)).getNumStates(); j++) {
                    theStates.add(((FiniteStates) parentsWithNSConstraints.elementAt(i)).getState(j));
                  }
                  theStates.add((String) theDecisionStates.elementAt(0));

                  for (int j=0; j<theDecisionStates.size()-1; j++) {
                    theDecisionStates.setElementAt((String) theDecisionStates.elementAt(j+1),j);
                  }
                  theDecisionStates.removeElementAt(theDecisionStates.size()-1);

                  for (int j=0; j<((PotentialTable) nodeRelation.getValues()).getVariables().size(); j++) {
                    if (((FiniteStates) parentsWithNSConstraints.elementAt(i)).getName().equals(((FiniteStates) ((PotentialTable) nodeRelation.getValues()).getVariables().elementAt(j)).getName())) {
                      ((FiniteStates) ((PotentialTable) nodeRelation.getValues()).getVariables().elementAt(j)).setStates(theStates);
                      //((FiniteStates) (nodeRelation.getVariables().elementAt(j))).setStates(theStates);
                      //((FiniteStates) parentsWithNSConstraints.elementAt(i)).setStates(theStates);
                      break;
                    }
                  }

                  PotentialTable pt = new PotentialTable(nodeRelation.getValues().getVariables());
                  double[] theVals = new double[(int) pt.getSize()];
                  Configuration config = new Configuration(pt.getVariables());
                  int count = 0;
                  for (int j=0; j<theVals.length; j++) {
                    if (config.getValue(((FiniteStates) parentsWithNSConstraints.elementAt(i)).getName()) !=
                        (((FiniteStates) parentsWithNSConstraints.elementAt(i)).getNumStates()-1)) {
                    theVals[j]=((Double) theInVals.elementAt(count)).doubleValue();
                    count++;
                  }
                  config.nextConfiguration();
                  }
                  pt.setValues(theVals);
                  nodeRelation.setValues(pt);
                }

                //Introducido por jruiz
                else if (nodeRelation.getValues().getClass() == GeneralizedPotentialTable.class) {
                  Vector theInVals = new Vector();
                  for (int j=0; j<((PotentialTable) nodeRelation.getValues()).getSize(); j++) {
                    theInVals.add(new Double(((GeneralizedPotentialTable) nodeRelation.getValues()).getValue(j)));
                  }

                  Vector theStates = new Vector();
                  for (int j=0; j<((FiniteStates) parentsWithNSConstraints.elementAt(i)).getNumStates(); j++) {
                    theStates.add(((FiniteStates) parentsWithNSConstraints.elementAt(i)).getState(j));
                  }
                  theStates.add((String) theDecisionStates.elementAt(0));

                  for (int j=0; j<theDecisionStates.size()-1; j++) {
                    theDecisionStates.setElementAt((String) theDecisionStates.elementAt(j+1),j);
                  }
                  theDecisionStates.removeElementAt(theDecisionStates.size()-1);

                  for (int j=0; j<((GeneralizedPotentialTable) nodeRelation.getValues()).getVariables().size(); j++) {
                    if (((FiniteStates) parentsWithNSConstraints.elementAt(i)).getName().equals(((FiniteStates) ((GeneralizedPotentialTable) nodeRelation.getValues()).getVariables().elementAt(j)).getName())) {
                      ((FiniteStates) ((GeneralizedPotentialTable) nodeRelation.getValues()).getVariables().elementAt(j)).setStates(theStates);
                      //((FiniteStates) (nodeRelation.getVariables().elementAt(j))).setStates(theStates);
                      //((FiniteStates) parentsWithNSConstraints.elementAt(i)).setStates(theStates);
                      break;
                    }
                  }

                  GeneralizedPotentialTable pt = new GeneralizedPotentialTable(nodeRelation.getValues().getVariables());
                  double[] theVals = new double[(int) pt.getSize()];
                  Configuration config = new Configuration(pt.getVariables());
                  int count = 0;
                  for (int j=0; j<theVals.length; j++) {
                    if (config.getValue(((FiniteStates) parentsWithNSConstraints.elementAt(i)).getName()) !=
                        (((FiniteStates) parentsWithNSConstraints.elementAt(i)).getNumStates()-1)) {
                    theVals[j]=((Double) theInVals.elementAt(count)).doubleValue();
                    count++;
                  }
                  config.nextConfiguration();
                  }
                  pt.setValues(theVals);
                  nodeRelation.setValues(pt);
                }//Fin introducido por jruiz

                else if (nodeRelation.getValues().getClass() == CanonicalPotential.class) {
                  /* TO DO */
                }
              }
              else {
                if (nodeRelation.getValues().getClass() == PotentialTable.class) {
                  Vector theInVals = new Vector();
                  for (int j=0; j<((PotentialTable) nodeRelation.getValues()).getSize(); j++) {
                    theInVals.add(new Double(((PotentialTable) nodeRelation.getValues()).getValue(j)));
                  }

                  Vector theStates = new Vector();
                  for (int j=0; j<((FiniteStates) parentsWithNSConstraints.elementAt(i)).getNumStates(); j++) {
                    theStates.add(((FiniteStates) parentsWithNSConstraints.elementAt(i)).getState(j));
                  }
                  theStates.add("\"VariableDoesntMakeSense\"");

                  for (int j=0; j<((PotentialTable) nodeRelation.getValues()).getVariables().size(); j++) {
                    if (((FiniteStates) parentsWithNSConstraints.elementAt(i)).getName().equals(((FiniteStates) ((PotentialTable) nodeRelation.getValues()).getVariables().elementAt(j)).getName())) {
                      ((FiniteStates) ((PotentialTable) nodeRelation.getValues()).getVariables().elementAt(j)).setStates(theStates);
                      //((FiniteStates) (nodeRelation.getVariables().elementAt(j))).setStates(theStates);
                      //((FiniteStates) parentsWithNSConstraints.elementAt(i)).setStates(theStates);
                      break;
                    }
                  }

                  PotentialTable pt = new PotentialTable(nodeRelation.getValues().getVariables());
                  double[] theVals = new double[(int) pt.getSize()];
                  Configuration config = new Configuration(pt.getVariables());
                  int count = 0;
                  for (int j=0; j<theVals.length; j++) {
                    if (config.getValue(((FiniteStates) parentsWithNSConstraints.elementAt(i)).getName()) !=
                        (((FiniteStates) parentsWithNSConstraints.elementAt(i)).getNumStates()-1)) {
                    theVals[j]=((Double) theInVals.elementAt(count)).doubleValue();
                    count++;
                  }
                  config.nextConfiguration();
                  }
                  pt.setValues(theVals);
                  nodeRelation.setValues(pt);
                }
                else if (nodeRelation.getValues().getClass() == CanonicalPotential.class) {
                  /* TO DO */
                }
              }
            }

            if (!theConstraintState.equals("")) {
              if (nodeRelation.getValues().getClass() == PotentialTable.class) {
                Vector vals = new Vector();
                for (int i=0; i<((PotentialTable) nodeRelation.getValues()).getSize(); i++) {
                  vals.addElement(new Double(((PotentialTable) nodeRelation.getValues()).getValue(i)));
                }

                Vector theStates = new Vector();
                for (int i=0; i<((FiniteStates) node).getNumStates(); i++) {
                  theStates.addElement(((FiniteStates) node).getState(i));
                }
                theStates.addElement(theConstraintState);
                ((FiniteStates) node).setStates(theStates);

                PotentialTable pt = new PotentialTable(((PotentialTable) nodeRelation.getValues()).getVariables());
                Configuration config = new Configuration(((PotentialTable) nodeRelation.getValues()).getVariables());
                double[] theVals = new double[(int) pt.getSize()];
                int k=0;
                for (int i=0; i<pt.getSize(); i++) {
                  if (!((FiniteStates) node).getState(config.getValue(node.getName())).equals(theConstraintState)) {
                    theVals[i] = ((Double) vals.elementAt(k)).doubleValue();
                    k++;
                  }
                  config.nextConfiguration();
                }
                pt.setValues(theVals);

                for (int l=0; l<pt.getSize()/((FiniteStates) node).getNumStates(); l++) {
                  double doubleValue=0.0;
                  for (int j=0; j<((FiniteStates) node).getNumStates()-1; j++) {
                    doubleValue=doubleValue+pt.getValue((int) (j*pt.getSize()/((FiniteStates) node).getNumStates())+l);
                  }
                  double lastStateValue = Math.round((1-doubleValue)*100000);
                  lastStateValue = lastStateValue/100000;
                  pt.setValue((int) ((((FiniteStates) node).getNumStates()-1)*pt.getSize()/((FiniteStates) node).getNumStates())+l,lastStateValue);
                }
                nodeRelation.setValues(pt);
              }

              //Introducido por jruiz
              else if (nodeRelation.getValues().getClass() == GeneralizedPotentialTable.class) {
                Vector vals = new Vector();
                for (int i=0; i<((GeneralizedPotentialTable) nodeRelation.getValues()).getSize(); i++) {
                  vals.addElement(new Double(((GeneralizedPotentialTable) nodeRelation.getValues()).getValue(i)));
                }

                Vector theStates = new Vector();
                for (int i=0; i<((FiniteStates) node).getNumStates(); i++) {
                  theStates.addElement(((FiniteStates) node).getState(i));
                }
                theStates.addElement(theConstraintState);
                ((FiniteStates) node).setStates(theStates);

                GeneralizedPotentialTable pt = new GeneralizedPotentialTable(((GeneralizedPotentialTable) nodeRelation.getValues()).getVariables());
                Configuration config = new Configuration(((GeneralizedPotentialTable) nodeRelation.getValues()).getVariables());
                double[] theVals = new double[(int) pt.getSize()];
                int k=0;
                for (int i=0; i<pt.getSize(); i++) {
                  if (!((FiniteStates) node).getState(config.getValue(node.getName())).equals(theConstraintState)) {
                    theVals[i] = ((Double) vals.elementAt(k)).doubleValue();
                    k++;
                  }
                  config.nextConfiguration();
                }
                pt.setValues(theVals);

                for (int l=0; l<pt.getSize()/((FiniteStates) node).getNumStates(); l++) {
                  double doubleValue=0.0;
                  for (int j=0; j<((FiniteStates) node).getNumStates()-1; j++) {
                    doubleValue=doubleValue+pt.getValue((int) (j*pt.getSize()/((FiniteStates) node).getNumStates())+l);
                  }
                  double lastStateValue = Math.round((1-doubleValue)*100000);
                  lastStateValue = lastStateValue/100000;
                  pt.setValue((int) ((((FiniteStates) node).getNumStates()-1)*pt.getSize()/((FiniteStates) node).getNumStates())+l,lastStateValue);
                }
                nodeRelation.setValues(pt);
              }//Fin introducido por jruiz

              else if (nodeRelation.getValues().getClass() == CanonicalPotential.class) {
                /* TO DO */
              }
            }
          }
          else if (node.getKindOfNode() == Node.UTILITY) {
            for (int i=0; i<parentsWithNSConstraints.size(); i++) {
              if (nodeRelation.getValues().getClass() == PotentialTable.class) {
                Vector theInVals = new Vector();
                for (int j=0; j<((PotentialTable) nodeRelation.getValues()).getSize(); j++) {
                  theInVals.add(new Double(((PotentialTable) nodeRelation.getValues()).getValue(j)));
                }

                Vector theStates = new Vector();
                for (int j=0; j<((FiniteStates) parentsWithNSConstraints.elementAt(i)).getNumStates(); j++) {
                  theStates.add(((FiniteStates) parentsWithNSConstraints.elementAt(i)).getState(j));
                }
                theStates.add("\"VariableDoesntMakeSense\"");

                for (int j=0; j<((PotentialTable) nodeRelation.getValues()).getVariables().size(); j++) {
                  if (((FiniteStates) parentsWithNSConstraints.elementAt(i)).getName().equals(((FiniteStates) ((PotentialTable) nodeRelation.getValues()).getVariables().elementAt(j)).getName())) {
                    ((FiniteStates) ((PotentialTable) nodeRelation.getValues()).getVariables().elementAt(j)).setStates(theStates);
                    //((FiniteStates) (nodeRelation.getVariables().elementAt(j))).setStates(theStates);
                    //((FiniteStates) parentsWithNSConstraints.elementAt(i)).setStates(theStates);
                    break;
                  }
                }

                PotentialTable pt = new PotentialTable(nodeRelation.getValues().getVariables());
                double[] theVals = new double[(int) pt.getSize()];
                Configuration config = new Configuration(pt.getVariables());
                int count = 0;
                for (int j=0; j<theVals.length; j++) {
                  if (config.getValue(((FiniteStates) parentsWithNSConstraints.elementAt(i)).getName()) !=
                      (((FiniteStates) parentsWithNSConstraints.elementAt(i)).getNumStates()-1)) {
                    theVals[j]=((Double) theInVals.elementAt(count)).doubleValue();
                    count++;
                  }
                  config.nextConfiguration();
                }
                pt.setValues(theVals);
                nodeRelation.setValues(pt);
              }

              //Introducido por jruiz
              else if (nodeRelation.getValues().getClass() == GeneralizedPotentialTable.class) {
                Vector theInVals = new Vector();
                for (int j=0; j<((GeneralizedPotentialTable) nodeRelation.getValues()).getSize(); j++) {
                  theInVals.add(new Double(((GeneralizedPotentialTable) nodeRelation.getValues()).getValue(j)));
                }

                Vector theStates = new Vector();
                for (int j=0; j<((FiniteStates) parentsWithNSConstraints.elementAt(i)).getNumStates(); j++) {
                  theStates.add(((FiniteStates) parentsWithNSConstraints.elementAt(i)).getState(j));
                }
                theStates.add("\"VariableDoesntMakeSense\"");

                for (int j=0; j<((GeneralizedPotentialTable) nodeRelation.getValues()).getVariables().size(); j++) {
                  if (((FiniteStates) parentsWithNSConstraints.elementAt(i)).getName().equals(((FiniteStates) ((GeneralizedPotentialTable) nodeRelation.getValues()).getVariables().elementAt(j)).getName())) {
                    ((FiniteStates) ((GeneralizedPotentialTable) nodeRelation.getValues()).getVariables().elementAt(j)).setStates(theStates);
                    //((FiniteStates) (nodeRelation.getVariables().elementAt(j))).setStates(theStates);
                    //((FiniteStates) parentsWithNSConstraints.elementAt(i)).setStates(theStates);
                    break;
                  }
                }

                GeneralizedPotentialTable pt = new GeneralizedPotentialTable(nodeRelation.getValues().getVariables());
                double[] theVals = new double[(int) pt.getSize()];
                Configuration config = new Configuration(pt.getVariables());
                int count = 0;
                for (int j=0; j<theVals.length; j++) {
                  if (config.getValue(((FiniteStates) parentsWithNSConstraints.elementAt(i)).getName()) !=
                      (((FiniteStates) parentsWithNSConstraints.elementAt(i)).getNumStates()-1)) {
                    theVals[j]=((Double) theInVals.elementAt(count)).doubleValue();
                    count++;
                  }
                  config.nextConfiguration();
                }
                pt.setValues(theVals);
                nodeRelation.setValues(pt);
              }//Fin introducido por jruiz

              else if (nodeRelation.getValues().getClass() == CanonicalPotential.class) {
                /* TO DO */
              }
            }
          }
        }

        private void dispose_EditVarDialog() {
          /* TO DO */
          if (hasNSConstraints) {
            readdIfNonSenseConstraints();
          }
          dispose();
        }

        private void initializeFunctionsNode(){
          functionsNode=new String[EditorPanel.functionsNode.length];
          for (int f=0; f<EditorPanel.functionsNode.length; f++)
            functionsNode[f]=localize(dialogBundle, EditorPanel.functionsNode[f]);
        }

        private void initializeUnitsUtility(){
          unitsUtility = new String[unitsInitial.length];

          for (int i=0; i<unitsInitial.length; i++) {
            unitsUtility[i] = unitsInitial[i];
          }
        }

        /**
         * @param x
         * @param y
         * @param width
         * @param height
         * @param wx
         * @param wy
         * @return
         */
        static GridBagConstraints setGridBagConstraints (int x, int y, int width,
                                       int height, double wx, double wy) {
	   GridBagConstraints c = new GridBagConstraints();
		c.gridx=x;
		c.gridy=y;
		c.gridwidth=width;
		c.gridheight=height;
		c.weightx=wx;
		c.weighty=wy;
		c.anchor=GridBagConstraints.CENTER;
		c.fill=GridBagConstraints.BOTH;
		return c;
	}


        /**
         * Shows or hides the EditVariableDialog component depending
         * on the value of parameter b.
	 */

	public void setVisible(boolean b)
	{
		if (b)
			setLocation(50, 50);
		super.setVisible(b);
	}

	static public void main(String args[])
	{
		(new EditVariableDialog()).setVisible(true);
	}


	/**
	 * Notifies this component that it has been added to a container
	 * and if a peer is required, it should be created. This method
	 * should be called by Container.add, and not by user code directly
	 */

	public void addNotify()
	{
		// Record the size of the window prior to calling parents addNotify.
		Dimension size = getSize();

		super.addNotify();

		if (frameSizeAdjusted)
			return;
		frameSizeAdjusted = true;

		// Adjust size of frame according to the insets
		Insets insets = getInsets();
		setSize(insets.left + insets.right + size.width, insets.top + insets.bottom + size.height);
	}

	// Used by addNotify
	boolean frameSizeAdjusted = false;

        String[] columnNames= {localize(Elvira.getElviraFrame().getDialogBundle(),"EditVariable.State.label"), localize(Elvira.getElviraFrame().getDialogBundle(),"EditVariable.Name.label")};
        Object[][] data = { {"s1", localize(Elvira.getElviraFrame().getDialogBundle(),"States.present")}, {"s0", localize(Elvira.getElviraFrame().getDialogBundle(),"States.absent")} };
        Object[][] data2 = { {"s1", localize(Elvira.getElviraFrame().getDialogBundle(),"States.yes")}, {"s0", localize(Elvira.getElviraFrame().getDialogBundle(),"States.no")} };
        Object[][] data3 = { {"s1", localize(Elvira.getElviraFrame().getDialogBundle(),"States.positive")}, {"s0", localize(Elvira.getElviraFrame().getDialogBundle(),"States.negative")} };
        Object[][] data4 = { {"s3", localize(Elvira.getElviraFrame().getDialogBundle(),"States.severe")}, {"s2", localize(Elvira.getElviraFrame().getDialogBundle(),"States.moderate")},
		                  {"s1", localize(Elvira.getElviraFrame().getDialogBundle(),"States.mild")}, {"s0", localize(Elvira.getElviraFrame().getDialogBundle(),"States.absent")} };
        Object[][] data5 = { {"s2", localize(Elvira.getElviraFrame().getDialogBundle(),"States.high")}, {"s1", localize(Elvira.getElviraFrame().getDialogBundle(),"States.medium")}, {"s0", localize(Elvira.getElviraFrame().getDialogBundle(),"States.low")} };
        Object[] emptyRow = {"", ""};

	Object[][] parentsData;
	Object[][] nodesData;
	Object[] parentsEmptyRow = {"",""};
        String[] parentsName = {localize(Elvira.getElviraFrame().getDialogBundle(),"EditVariable.Name.label"),
                                localize(Elvira.getElviraFrame().getDialogBundle(),"EditVariable.Title.label")};
	String[] nodesName = {localize(Elvira.getElviraFrame().getDialogBundle(),"EditVariable.Name.label"),
                              localize(Elvira.getElviraFrame().getDialogBundle(),"EditVariable.Title.label")};

        ValuesTableModel model = new ValuesTableModel(data, columnNames);
	ParentsTableModel parentsModel = new ParentsTableModel(parentsData,parentsName);
	ParentsTableModel parentsDialogModel = new ParentsTableModel(nodesData,nodesName);
        NodeTableModel relationModel = new NodeTableModel();

	//{{DECLARE_CONTROLS
	javax.swing.JTabbedPane editVarTabbedPane = new javax.swing.JTabbedPane();
	javax.swing.JPanel nodePanel = new javax.swing.JPanel();
	javax.swing.JLabel nameLabel = new javax.swing.JLabel();
	javax.swing.JTextField nameTextField = new javax.swing.JTextField();
	javax.swing.JComboBox relevanceComboBox = new javax.swing.JComboBox();
	javax.swing.JLabel titleLabel = new javax.swing.JLabel();
	javax.swing.JTextField titleTextField = new javax.swing.JTextField();
	javax.swing.JLabel commentLabel = new javax.swing.JLabel();
	javax.swing.JLabel functionLabel = new javax.swing.JLabel();
        javax.swing.JLabel unitsLabel = new javax.swing.JLabel();
	javax.swing.JLabel newfunctionLabel = new javax.swing.JLabel();
	javax.swing.JTextField editFunctionText = new javax.swing.JTextField();
	javax.swing.JScrollPane commentScrollPane = new javax.swing.JScrollPane();
	javax.swing.JTextArea commentTextArea = new javax.swing.JTextArea();
	javax.swing.JComboBox functionComboBox;
        javax.swing.JComboBox unitsComboBox;
	javax.swing.JPanel nodeKindPanel = new javax.swing.JPanel();
	javax.swing.JCheckBox observedBox = new javax.swing.JCheckBox();
	javax.swing.JRadioButton chanceRadioButton = new javax.swing.JRadioButton();
	javax.swing.JRadioButton decisionRadioButton = new javax.swing.JRadioButton();
	javax.swing.JRadioButton utilityRadioButton = new javax.swing.JRadioButton();
	javax.swing.JPanel variableTypePanel = new javax.swing.JPanel();
	javax.swing.JRadioButton discreteRadioButton = new javax.swing.JRadioButton();
	javax.swing.JRadioButton continuousRadioButton = new javax.swing.JRadioButton();
	javax.swing.JRadioButton hybridRadioButton = new javax.swing.JRadioButton();
	javax.swing.JLabel relevanceLabel = new javax.swing.JLabel();
	javax.swing.JPanel valuesPanel = new javax.swing.JPanel();
        javax.swing.JPanel cValuesPanel = new javax.swing.JPanel();
        javax.swing.JPanel parentsPanel = new javax.swing.JPanel();
	javax.swing.JComboBox valuesComboBox = new javax.swing.JComboBox();
	javax.swing.JScrollPane valuesScrollPane = new javax.swing.JScrollPane();
	javax.swing.JTable valuesTable = new javax.swing.JTable();
	javax.swing.JLabel valuesTypeLabel = new javax.swing.JLabel();
	javax.swing.JButton addButton = new javax.swing.JButton();
	javax.swing.JButton removeButton = new javax.swing.JButton();
	javax.swing.JButton upButton = new javax.swing.JButton();
	javax.swing.JButton downButton = new javax.swing.JButton();
        javax.swing.JLabel parentsKindLabel = new javax.swing.JLabel();
	javax.swing.JScrollPane parentsScrollPane = new javax.swing.JScrollPane();
	javax.swing.JTable parentsTable = new javax.swing.JTable();
	javax.swing.JLabel parentsTypeLabel = new javax.swing.JLabel();
	javax.swing.JButton addParentButton = new javax.swing.JButton();
	javax.swing.JButton removeParentButton = new javax.swing.JButton();
        javax.swing.JButton addFromGUIParentButton = new javax.swing.JButton();
	javax.swing.JButton upParentButton = new javax.swing.JButton();
	javax.swing.JButton downParentButton = new javax.swing.JButton();

	/*changes for the edition of probability trees*/
	javax.swing.JPanel relationPanelCard = new javax.swing.JPanel();
	javax.swing.JPanel treePanel = new javax.swing.JPanel();
        PanelEditTree treePanelTree;
        javax.swing.JTree tree;
	javax.swing.tree.DefaultTreeModel treeModel;
	javax.swing.tree.DefaultMutableTreeNode treeNode;
	javax.swing.JScrollPane treeScrollPane;
	javax.swing.JComboBox comboNodes;
	javax.swing.JRadioButton treeRadioButton = new javax.swing.JRadioButton();
	javax.swing.JTextField feedBackTree;
	javax.swing.JScrollPane feedBackTreeScrollPane;

	PotentialTree potentialTree;
	ProbabilityTree probabilityTree;
	MyTreeModelListener myTreeModelListener;
	boolean isTree;
	boolean treeChanged = false;
	int opcionEdicionTree = 2;
	int longitudTexto = 1;
	boolean edicionCorrecta;

	/**/

	javax.swing.JPanel relationPanel = new javax.swing.JPanel();
	javax.swing.JPanel panel1 = new javax.swing.JPanel();
	javax.swing.JRadioButton probRadioButton = new javax.swing.JRadioButton();
	javax.swing.JRadioButton detRadioButton = new javax.swing.JRadioButton();
	
	
	javax.swing.JPanel tablePanel = new javax.swing.JPanel();
	javax.swing.JScrollPane relationScrollPane = new javax.swing.JScrollPane();
	javax.swing.JTable relationTable = new javax.swing.JTable();
	javax.swing.JPanel panel2 = new javax.swing.JPanel();
	javax.swing.JRadioButton allRadioButton = new javax.swing.JRadioButton();
	javax.swing.JRadioButton indRadioButton = new javax.swing.JRadioButton();
	javax.swing.JPanel panel3 = new javax.swing.JPanel();
	javax.swing.JRadioButton valRadioButton = new javax.swing.JRadioButton();
	javax.swing.JRadioButton probsRadioButton = new javax.swing.JRadioButton();
	javax.swing.JPanel panel4 = new javax.swing.JPanel();
	
	javax.swing.JPanel panelOptProbDet = new javax.swing.JPanel();
	javax.swing.JRadioButton probRadioButtonDecs = new javax.swing.JRadioButton();
	javax.swing.JRadioButton detRadioButtonDecs = new javax.swing.JRadioButton();
	javax.swing.JRadioButton optimalRadioButtonDecs = new javax.swing.JRadioButton();
	
	javax.swing.JRadioButton cptRadioButton = new javax.swing.JRadioButton();
	javax.swing.JRadioButton canRadioButton = new javax.swing.JRadioButton();
        /*Manolo> Panel5 va a llevar los botones de la relacion de combinación de utilidades*/
        javax.swing.JPanel panelSVNode = new javax.swing.JPanel();
        
	javax.swing.JRadioButton addRadioButton = new javax.swing.JRadioButton();
	javax.swing.JRadioButton multiplyRadioButton = new javax.swing.JRadioButton();
        ButtonGroup utilityCombinationGroup = new ButtonGroup();
        
        
	javax.swing.JPanel orTypePanel = new javax.swing.JPanel();
	javax.swing.JRadioButton diezRadioButton = new javax.swing.JRadioButton();
	javax.swing.JRadioButton henrionRadioButton = new javax.swing.JRadioButton();
	javax.swing.JPanel relationTypePanel = new javax.swing.JPanel();
	javax.swing.JLabel typeRelationLabel = new javax.swing.JLabel();
	javax.swing.JButton typeRelationButton = new javax.swing.JButton();
	javax.swing.JPanel buttonsPanel = new javax.swing.JPanel();
	javax.swing.JButton okButton = new javax.swing.JButton();
	javax.swing.JButton cancelButton = new javax.swing.JButton();
	javax.swing.JButton applyButton = new javax.swing.JButton();

	//}}

	// !!!!!!! WARNING !!!!!!
	// If you want to edit visually in the VisualCafe you must remove the parameters of the
	// calling to JTable constructor (valuesTable). You must remove model in the parameters list
	// You must done the same for the relationTable variable

	/** Dialog to choose relation type **/

	javax.swing.JDialog relationDialog = new javax.swing.JDialog();
	javax.swing.JPanel panelRelation = new javax.swing.JPanel();
	javax.swing.JRadioButton generalRadioButton = new javax.swing.JRadioButton();
	javax.swing.JRadioButton orRadioButton = new javax.swing.JRadioButton();
	javax.swing.JRadioButton causalMaxRadioButton = new javax.swing.JRadioButton();
	javax.swing.JRadioButton generalizedMaxRadioButton = new javax.swing.JRadioButton();
	javax.swing.JRadioButton andRadioButton = new javax.swing.JRadioButton();
	javax.swing.JRadioButton minRadioButton = new javax.swing.JRadioButton();
	javax.swing.JRadioButton xorRadioButton = new javax.swing.JRadioButton();
	//javax.swing.JRadioButton optimalPolicyRadioButton = new javax.swing.JRadioButton();
	//javax.swing.JRadioButton forcePolicyRadioButton = new javax.swing.JRadioButton();
	javax.swing.JPanel buttonsRelationDialogPanel = new javax.swing.JPanel();
	javax.swing.JButton okRelationDialogButton = new javax.swing.JButton();
	javax.swing.JButton cancelRelationDialogButton = new javax.swing.JButton();
	ButtonGroup relGroup = new ButtonGroup();

	/** Dialog to choose the node's parents **/

	javax.swing.JDialog parentsDialog = new javax.swing.JDialog();
	javax.swing.JPanel parentsDialogPanel = new javax.swing.JPanel();
	javax.swing.JButton okParentsButton = new javax.swing.JButton();
	javax.swing.JButton cancelParentsButton = new javax.swing.JButton();
	javax.swing.JPanel buttonsParentsDialogPanel = new javax.swing.JPanel();
	javax.swing.JScrollPane parentsDialogScrollPane = new javax.swing.JScrollPane();
	javax.swing.JTable parentsDialogTable = new javax.swing.JTable();
	ButtonGroup parentsGroup = new ButtonGroup();

	
        
        /** Variables to fill Continuous Node*/
        javax.swing.JLabel minCVLabel = new javax.swing.JLabel();
        javax.swing.JLabel maxCVLabel = new javax.swing.JLabel();
        javax.swing.JLabel precisionCVLabel = new javax.swing.JLabel();
        javax.swing.JLabel undefValCVLabel = new javax.swing.JLabel();
        javax.swing.JLabel unitCVLabel = new javax.swing.JLabel();        

        javax.swing.JTextField minCVText = new javax.swing.JTextField();
        javax.swing.JTextField maxCVText = new javax.swing.JTextField();
        javax.swing.JTextField precisionCVText = new javax.swing.JTextField();
        javax.swing.JTextField undefValCVText = new javax.swing.JTextField();
        javax.swing.JTextField unitCVText = new javax.swing.JTextField();        
        
        javax.swing.JPanel valuesPanelCard = new javax.swing.JPanel();        
        // Variables to known the tables' state

	/**
	 * Using when a new node is created with double click and appears
	 * the EditVariableDialog. If this variable is True it means that
	 * the cancel button has been pressed and the node created must
	 * been deleted
	 */

	boolean cancelled = false;

	/**
	 * True if the states table has been modified
	 */

	boolean statesHasChanged = true;

	/**
	 * True if the relation table has been modified
	 */

	boolean relationTableChanged = false;
	boolean theTableChanged = false;

	/**
	 * True if the Dialog can be edited
	 */

	boolean isEditable;

	/**
	 * Agrupates all the RadioButtons using for select the
	 * kind of the node
	 */

	ButtonGroup nodeKindGroup = new ButtonGroup();

	/**
	 * Agrupates all the RadioButtons using for select the
	 * variable type of the node
	 */

	ButtonGroup variableTypeGroup = new ButtonGroup();

	/**
	 * Agrupates the different RadioButtons that appears in the
	 * Relation Pane
	 */

	ButtonGroup bGroup1 = new ButtonGroup(),
	            bGroup2 = new ButtonGroup(),
	            bGroup3 = new ButtonGroup(),
	            bGroup4 = new ButtonGroup(),
	            orTypeGroup = new ButtonGroup();
	ButtonGroup optProbDecGroup = new ButtonGroup();
	

	/**
	 * For accesing more easily to the current node's states
	 */

	Vector states = new Vector();

	/**
	 * Node that will be edited with the EditVariableDialog
	 * created
	 */

	Node node;

	/**
	 * Relation with the parents of the node. The information
	 * contained in this relation will be displayed in the
	 * Relation Tab
	 */

	Relation nodeRelation;

	/**
	 * Contains the new relation if older is changed
	 */

	private Relation newRelation;

	/**
	 * Kind of node's name displaying. If its value it is true the
	 * title of the node will be displayed, and its value it is false
	 * the name.
	 */

	boolean byTitle;

	/**
	 * Variable for accesing more easily to the Bayes Network that
	 * is currently used
	 */

	Bnet bayesNet = ((NetworkFrame) Elvira.getElviraFrame().getCurrentNetworkFrame()).getEditorPanel().getBayesNet();

	// Bundles for internacionalization. Not used yet.
	ResourceBundle menuBundle, dialogBundle;

	/**
	 * Variable to set the last Tabbed Pane selected
	 */

	private int lastTabbedPane;

	// Using for having the first column locked
	JTable headerTable = new JTable(relationModel);
	TableColumnModel tcm;
	TableColumn firstColumn;

	/**
	 * Number of columns of the relation Table
	 */

	int columns=0;

	/**
	 * Number of rows of the relation Table
	 */

	int rows=0;

	/**
	 * Contains a list of nodes with the parents of the node
	 */

	Vector parents = new Vector();
        Vector parentsWithNSConstraints = new Vector();
        Vector childrenWithNSConstraints = new Vector();
        String theConstraintState = new String("");
        Vector theDecisionStates = new Vector();
        boolean hasNSConstraints = false;

	String editingValue;
	String oldNodeName;

	// This variables are used to make the modifications when the order
	// or the number of the node's states change
	boolean newOrder = false;
	Vector order = new Vector();

	// Contains the string that appear in the state/decision identifier
	String identifier;
        public javax.swing.ImageIcon arrowUpIcon = new javax.swing.ImageIcon("elvira/gui/images/arrowup.gif"),
	                             arrowDownIcon = new javax.swing.ImageIcon("elvira/gui/images/arrowdown.gif");

	// To know if the relation contained in the Dialog is general or the other type
	public boolean general;

	public boolean lockedColumns;
	public int[] lockedColumnsArray;

	// The relation that is contained in the dialog is deterministic and the
	// user is filling with values
	public boolean valuesMode = false;

	// used to recover the relationType value when an error is produced
	private String previousRelationType;

	private int oldStatesNumber;
	private boolean optionsDisabled = false, andWithSubstitutors = false;

	/* ADDED TEMPORARILY */
	private boolean debug = false; /* TO PERFORM DEBUGGING IN THIS CLASS THROUGH System.out.println... */
	/* END ADDED TEMPORARILY */

	public void inicializeDataArrays() {
	  previousRelationType = localize(dialogBundle,"EditVariable.relationDialogGeneral.label");

	  columnNames[0] = localize(dialogBundle,"EditVariable.State.label");
	  columnNames[1] = localize(dialogBundle,"EditVariable.Name.label");

	  data[0][1] = localize(dialogBundle,"States.present");
	  data[1][1] = localize(dialogBundle,"States.absent");

	  data2[0][1] = localize(dialogBundle,"States.yes");
	  data2[1][1] = localize(dialogBundle,"States.no");

	  data3[0][1] = localize(dialogBundle,"States.positive");
	  data3[1][1] = localize(dialogBundle,"States.negative");

	  data4[0][1] = localize(dialogBundle,"States.severe");
	  data4[1][1] = localize(dialogBundle,"States.moderate");
	  data4[2][1] = localize(dialogBundle,"States.mild");
	  data4[3][1] = localize(dialogBundle,"States.absent");

	  data5[0][1] = localize(dialogBundle,"States.high");
	  data5[1][1] = localize(dialogBundle,"States.medium");
	  data5[2][1] = localize(dialogBundle,"States.low");

        }


	/**
	 * Show the EditVariableDialog. This method must be used when
	 * a node is created with a double click, because if the cancel
	 * button is clicked when the EditVariableDialog appears the node
	 * inserted must be deleted.
	 *
	 * @return True if the cancel button has been clicked
	 */

	public boolean showDialog() {
	   super.show();
	   return cancelled;
	}


	/**
	 * Enables/Disables and set editable/non editable the
	 * fields of the dialog depending on the isEditable
	 * parameter
	 */

	public void enableDialog (boolean isEditable) {
	   nameTextField.setEditable(isEditable);
	   relevanceComboBox.setEnabled(isEditable);
	   titleTextField.setEditable(isEditable);
	   commentTextArea.setEditable(isEditable);
	   //chanceRadioButton.setEnabled(isEditable);
//	   discreteRadioButton.setEnabled(isEditable);
  //         continuousRadioButton.setEnabled(isEditable);
	   valuesComboBox.setEnabled(isEditable);
	   addButton.setEnabled(isEditable);
	   removeButton.setEnabled(isEditable);
	   upButton.setEnabled(isEditable);
	   downButton.setEnabled(isEditable);
           addParentButton.setEnabled(isEditable);
           removeParentButton.setEnabled(isEditable);
           addFromGUIParentButton.setEnabled(isEditable);
           upParentButton.setEnabled(isEditable);
           downParentButton.setEnabled(isEditable);
	}

               
        
        /**
	 * Hides the options that let the user select the
	 * kind of relation when a decision node is being edited.
	 */
       /* private void enableRelationOptionsDecision() {
                          
                   typeRelationButton.setVisible(true);
                   typeRelationLabel.setVisible(true);
                   panel1.setVisible(false);
                   panel2.setVisible(false);
                   panel3.setVisible(false);
                   panel4.setVisible(false);
                   panelSVNode.setVisible(false);
                   orTypePanel.setVisible(false);
                   panelOptProbDet.setVisible(true);
        }*/
        
        /**
	 * Shows/Hides the options that let the user select the
	 * kind of relation when an utility node is being edited.
	 */
        private void enableRelationOptionsUtility() {
                  
                  typeRelationLabel.setVisible(true);
                  panel1.setVisible(false);
                  panel2.setVisible(false);
                  panel3.setVisible(false);
                  panel4.setVisible(false);
                  orTypePanel.setVisible(false);
                  panelSVNode.setVisible(false);
                  typeRelationButton.setVisible(true);
                  panelOptProbDet.setVisible(false);
                  
          }
        
        
               /**
	 * Shows/Hides the options that let the user select the
	 * kind of relation when an utility node is being edited.
	 */
        private void enableRelationOptionsSuperValue() {
            
            typeRelationLabel.setVisible(true);
            panel1.setVisible(false);
            panel2.setVisible(false);
            panel3.setVisible(false);
            panel4.setVisible(false);
            orTypePanel.setVisible(false);
            panelSVNode.setVisible(true);
            typeRelationButton.setVisible(false);
            panelOptProbDet.setVisible(false);
            
        }
        
        /**
	 * Shows/Hides the options that let the user select the
	 * kind of relation. This options only can be visible when
	 * a chance node is been edited
	 */
        private void enableRelationOptionsChanceAndDecisions() {
        	int kind;
        	boolean condition;
        	
        	kind = this.node.getKindOfNode();
        	
    		
            panelSVNode.setVisible(false);
            panel1.setVisible(kind==Node.CHANCE);
            panelOptProbDet.setVisible(kind==Node.DECISION);
            

            condition = ((kind==Node.CHANCE)||(kind==Node.DECISION));
        	
        	//if ((kind==Node.CHANCE)||((kind==Node.DECISION)&&(!optimalRadioButtonDecs.isSelected()))){
            if (condition){
        		typeRelationButton.setVisible(true);
                typeRelationLabel.setVisible(true);
        		
        		
   
                    if (nodeRelation.isDeterministic() && (!optionsDisabled)) {
                      if (!isEditable) {
                        panelSetEnabled(panel3,false);
                        panelSetEnabled(panel2,false);
                        if (kind==Node.CHANCE){
                        	panelSetEnabled(panel1,false);
                        }
                      }
                      else {
                        panelSetEnabled(panel3,true);
                        panelSetEnabled(panel2,true);
                        if (kind==Node.CHANCE){
                        panelSetEnabled(panel1,true);
                        }
                      }

                      if (isEditable) {
                        optionsDisabled = true;
                        detRadioButton.setSelected(true);
                        if (valuesMode==false) {
                          probsRadioButton.setSelected(true);
                        }
                        else {
                          valRadioButton.setSelected(true);
                        }
                        optionsDisabled = false;
                      }

                      if (general) {
                        panelSetEnabled(orTypePanel,false);
                        panelSetEnabled(panel4,false);
                      }
                      else {
                        //if (orRadioButton.isSelected() || causalMaxRadioButton.isSelected()) {
                    	  boolean conditionPanelOr;
                    	  conditionPanelOr = ((nodeRelation.getKind() == Relation.OR) || (nodeRelation.getKind() == Relation.CAUSAL_MAX))&&isEditable;
                        
                          panelSetEnabled(orTypePanel,conditionPanelOr);
                                                
                          panelSetEnabled(panel4,isEditable);
                        
                        
                      }
                      /* If it is deterministic, there's nothing else to do */
                      return;
                    }
                    else {
                      panelSetEnabled(panel3,false);
                    }

                    if ((nodeRelation.getValues() != null) && (nodeRelation.getValues().getClass() == CanonicalPotential.class)) {
                      if (!isEditable) {
                    	  if (kind==Node.CHANCE){
                    		  panelSetEnabled(panel1,false);
                    	  }
                        panelSetEnabled(panel2,false);
                        panelSetEnabled(panel3,false);
                        panelSetEnabled(panel4,false);
                      }
                      else {
                    	  if (kind==Node.CHANCE){
                        panelSetEnabled(panel1,true);
                    	  }
                        panelSetEnabled(panel2,true);
                        panelSetEnabled(panel3,false);
                        panelSetEnabled(panel4,true);
                      }
                      //if (orRadioButton.isSelected() || causalMaxRadioButton.isSelected()) {
                      if ((nodeRelation.getKind() == Relation.OR) || (nodeRelation.getKind() == Relation.CAUSAL_MAX)) {
                        panelSetEnabled(orTypePanel,isEditable);
                      }
                      else {
                        panelSetEnabled(orTypePanel,false);
                      }
                    }

                    //Modificado por jruiz
                    else if (nodeRelation.getValues().getClass() == PotentialTable.class || 
                             nodeRelation.getValues().getClass() == GeneralizedPotentialTable.class) {
                    	if (kind==Node.CHANCE){
                    		panelSetEnabled(panel1,isEditable);
                    	}
                      
                      if (nodeRelation.isDeterministic()) {
                        panelSetEnabled(panel2,false);
                      }
                      else {
                    	  panelSetEnabled(panel2,isEditable);
                        
                      }
                      panelSetEnabled(panel4,false);
                      panelSetEnabled(orTypePanel,false);
                    }//Fin modificado por jruiz
        	}
            
           if ((kind==Node.DECISION)&&(optimalRadioButtonDecs.isSelected())){
        		showPanelsActivatedButtonOptimal(true);
        	}
          }

        /**
	 * Shows/Hides the options that let the user select the
	 * kind of relation when a node is being edited.
	 */
        public void enableRelationOptions() {

            switch (node.getKindOfNode()) {
                case Node.CHANCE: enableRelationOptionsChanceAndDecisions();break;
                case Node.DECISION: enableRelationOptionsChanceAndDecisions(); break;
                case Node.UTILITY: enableRelationOptionsUtility(); break;
                case Node.SUPER_VALUE: enableRelationOptionsSuperValue();
                
            }
        }

	public static boolean isPredefined(String ppn){
		boolean isp=false;
		for (int p=0; p<EditorPanel.functionsNode.length-1 && !isp; p++)
		    isp=(ppn.equals(EditorPanel.functionsNode[p]));
		return isp;
	}
   
        private String withoutQm(String s)
        {
                if (s.substring(0,1).equals("\""))
                {
                    return (s.substring(1,s.length()-1));
                }
                else {
                    return s;
                }
        }
        
        private String addQm(String s)
        {
            if (s.charAt(0) == '\"')
            {
                return s;
            }
            else {
                return "\""+s+"\"";
            }
        }
        

	/**
	 * Fill the values in the dialog area. Using the information
	 * stored in the property node, the textfields and RadioButtons
	 * are filled with the information of the selected node.
	 */

	/* Some information has to be provided to say it is the first time
	 * we edit the node and let user choose the kind of relation */
/***********************************************************************************/
        private void fillDialog() {

	    String values[], all_values = "";
	    String property;

	    // Fill name
	    nameTextField.setText(node.getName());
	    oldNodeName = node.getName();

	    // Fill title <--- jgamez
	    titleTextField.setText(node.getTitle());

	    property = String.valueOf(node.getRelevance());
	    relevanceComboBox.setSelectedItem(property);

	    String nodepurpose=node.getPurpose();
	    System.out.println("Purpose"+nodepurpose);
            if (nodepurpose.equals(""))
              functionComboBox.setSelectedItem("");
            else if (!isPredefined(nodepurpose)){
              if (debug) {
                System.out.println(nodepurpose);
	      }
	      functionComboBox.setSelectedItem(localize(dialogBundle,"Defined"));
	      newfunctionLabel.setVisible(true);
	      editFunctionText.setVisible(true);
	      editFunctionText.setEnabled(true);
	      editFunctionText.setEditable(true);
	      editFunctionText.setText(nodepurpose);
	    }
            else functionComboBox.setSelectedItem(localize(dialogBundle, nodepurpose));

            if (node.getClass() == Continuous.class) {
              boolean isThere = false;
              for (int i=0; i<unitsComboBox.getItemCount(); i++) {
                if (((Continuous) node).getUnit().equals(unitsComboBox.getItemAt(i).toString())) {
                  unitsComboBox.setSelectedItem(((Continuous) node).getUnit());
                  isThere = true;
                  break;
                }
              }
              if (!isThere) {
                unitsComboBox.addItem(((Continuous) node).getUnit());
                unitsComboBox.setSelectedItem(((Continuous) node).getUnit());
              }
            }

	    // Fill comment <-- jgamez
	    commentTextArea.setText(node.getComment());

	    // Fill kind of node RadioButton group

	    switch (node.getKindOfNode()) {
	      case Node.CHANCE: chanceRadioButton.setSelected(true);  // chance node
	              break;
	      case Node.DECISION: decisionRadioButton.setSelected(true);  // decision node
	              break;
	      case Node.UTILITY: utilityRadioButton.setSelected(true);   //utility node
	              break;
	    }

	    // Fill type of variable RadioButton group

	    switch (node.getTypeOfVariable()) {
	      case Node.CONTINUOUS: continuousRadioButton.setSelected(true);  // continuous node
  //                    editVarTabbedPane.setEnabledAt(4,true);
    //                  editVarTabbedPane.setEnabledAt(1,false);                      
                     ((CardLayout)valuesPanelCard.getLayout()).show(valuesPanelCard,"CONTINUOUSVALUES");
                      break;
	      case Node.FINITE_STATES: discreteRadioButton.setSelected(true);  // discrete node
//                     editVarTabbedPane.setEnabledAt(4,false);
      //               editVarTabbedPane.setEnabledAt(1,true);                      
                   ((CardLayout)valuesPanelCard.getLayout()).show(valuesPanelCard,"DISCRETEVALUES");
                      break;
	      case Node.INFINITE_DISCRETE: // option for infinite discrete variables
	      case Node.MIXED: hybridRadioButton.setSelected(true);   // hybrid node
	              break;
	    }

	    /* Fill the Values Tab */
	    // Fill the type of values Combo-box
	    if (node.getKindOfNode()==Node.UTILITY) {
	    	
              functionLabel.setVisible(false);
              unitsLabel.setVisible(true);
              functionComboBox.setVisible(false);
              unitsComboBox.setVisible(true);
              editVarTabbedPane.setEnabledAt(1,false);
        
              editVarTabbedPane.setEnabledAt(3,true);
              //}
              enableRelationOptions();
              insertValuesInTables(null,parents);
	      return;
	    }
	    else {
	      //editVarTabbedPane.setEnabledAt(1,true);
	      if (node.getKindOfNode()==Node.DECISION) {
		
                /* <- This was only to show the decision table in the relation menu... */
                editVarTabbedPane.setEnabledAt(3,true);
                editVarTabbedPane.setTitleAt(3,localize(dialogBundle,"EditVariable.Policy.label"));
                fillPaneRelationForPolicy();
                enableRelationOptions();
	      }
	      else {
		/* Node is a random variable or a utility node */
		editVarTabbedPane.setEnabledAt(3,true);
		enableRelationOptions();
	      }
	   }

         if (node.getClass() == FiniteStates.class) {
	   FiniteStates fsNode = (FiniteStates) bayesNet.getNode(node.getName());

	   if (node.getKindOfNode()==Node.DECISION) {
	      insertValuesInTables(fsNode.getStates(),parents);
	   }
	   else
	    switch (fsNode.getNumStates()) {
            case 2: if (isPredefinedValue(data, fsNode.getStates()))
                     valuesComboBox.setSelectedIndex(0);
                  else if (isPredefinedValue (data2, fsNode.getStates()))
                     valuesComboBox.setSelectedIndex(1);
                  else if (isPredefinedValue (data3, fsNode.getStates()))
                     valuesComboBox.setSelectedIndex(2);
                  else
                     valuesComboBox.setSelectedIndex(5);
                  insertValuesInTables(fsNode.getStates(),parents);
                  break;
            case 3: if (isPredefinedValue (data5, fsNode.getStates()))
                     valuesComboBox.setSelectedIndex(4);
                  else
                     valuesComboBox.setSelectedIndex(5);
                  insertValuesInTables(fsNode.getStates(),parents);
                  break;
            case 4: if (isPredefinedValue (data4, fsNode.getStates()))
                     valuesComboBox.setSelectedIndex(3);
                  else
                     valuesComboBox.setSelectedIndex(5);
                  insertValuesInTables(fsNode.getStates(),parents);
                  break;
            default: valuesComboBox.setSelectedIndex(5);
                     insertValuesInTables(fsNode.getStates(),parents);
          }
          newOrder=false;
         }
         if(node.getClass()==Continuous.class){
           
             insertValuesInTables(null,parents);
             
         }
            
         }

	private void fillPaneRelationForPolicy() {
		
		//placeAndReallocateRadioButtonsOptimalProbDet();
		
		
	}

	/**
	* Function used by saveTree to recursively save the edition of the Probability Tree into the relation of the node
	*/
	
	private int saveProbabilityTreeRecursive(DefaultTreeModel treeModel, ProbabilityTree pTree,
					DefaultMutableTreeNode nodo, int i, MyTreeModelListener miTreeModelListener){
	
	  	ProbabilityTree newPTree;
		Double value;
		String nombreNodo, nombreHijo;
	   DefaultMutableTreeNode hijo;
		FiniteStates var;
		int correcto = 0;
	
		nombreNodo = miTreeModelListener.quitaComentarios(nodo);
		//System.out.println(nombreNodo);
	
		try{
			value = Double.valueOf(nombreNodo);
			newPTree = new ProbabilityTree(value.doubleValue());
			pTree.replaceChild(newPTree,i);
			return 0;
		}catch (NumberFormatException q){
			var = miTreeModelListener.buscaVariable(nombreNodo);
			newPTree = new ProbabilityTree(var);
			pTree.replaceChild(newPTree, i);
			for(int j = 0 ; j <var.getNumStates(); j++){
				hijo = (DefaultMutableTreeNode) nodo.getChildAt(j);
				//System.out.println("Nodo "+hijo.toString()+" hijo de "+ nodo.toString());
				if(miTreeModelListener.quitaComentarios(hijo).equals("")){
					return 1;
				}else{
					if ((correcto =  saveProbabilityTreeRecursive(treeModel, newPTree, hijo, j, miTreeModelListener)) == 1)
						return correcto;
				}
			}
			return correcto;
		}
	}

	private void setBoundsForButtonsOptProbDet() {
		// TODO Auto-generated method stub
		int width;
		int height = 23;
		int y = 6;
		int initialX;
		int shiftX;
		
		initialX = 10;
		width = 85;
		shiftX = width+7;
		
		optimalRadioButtonDecs.setBounds(initialX,y,width,height);
				
		probRadioButtonDecs.setBounds(initialX+shiftX,y,width,height);
		
		detRadioButtonDecs.setBounds(initialX+2*shiftX,y,width,height);
		

		
	}

	/**
	 * Returns True if the states vector has the same values that
	 * the object data. If this happens, the valuesComboBox must
	 * contain a value different from 'Others'.
	 *
	 * @param data Contains a set of predefinied values
	 * @param states States of the current node
	 */

	private boolean isPredefinedValue (Object[][] data, Vector states) {
	   int i=0;

	   // If has different size no more comparisons must be done
	   if (states.size()!=data.length)
	      return false;

	   //
	   while (i<data.length){
	      if (!states.contains(data[i][1]))
	         return false;
	      i++;
	   }
	   return true;
	}

        /**
         * Find out if theName corresponds to a Descendant of currentNode
         **/

        private boolean findOutIfNotDescendant(Node currentNode, String theName) {
            if (currentNode.getName().equals(theName)) {
                return false;
            }
            else {
               if (currentNode.getChildrenNodes() == null) {
                   return true;
               }
               else {
                   boolean isIt = true;
                   for (int i=0; i<currentNode.getChildren().size(); i++) {
                      if (!findOutIfNotDescendant((Node) currentNode.getChildrenNodes().elementAt(i),theName)) {
                        isIt = false;
                        break;
                      }
                   }
                   return isIt;
               }
            }
        }

	/**
	 * Fill the values table with the states of the current
	 * node
	 */

	private void insertValuesInTables (Vector states, Vector theParents) {
          int statesNumber=0;
          if (states != null) {
	    statesNumber = states.size();
          }
	  String stringValue, stringValue2;
	  order = new Vector();

	 	  
	  
          if (node.getKindOfNode() != Node.UTILITY) {
            for(int i=statesNumber;i<valuesTable.getRowCount();i++){
                model.removeRow(i);
            }

            for (int i=0; i<statesNumber; i++) {
                stringValue = String.valueOf(statesNumber-i-1);
                if (i>=valuesTable.getRowCount())
                    model.addRow(emptyRow);
                valuesTable.setValueAt(identifier+stringValue, i, 0);
                valuesTable.setValueAt(withoutQm((String)states.elementAt(i)),i,1);
                order.add(new Integer(i+1));
            }
          }
          for (int i=parentsModel.getRowCount()-1; i>=0; i--) {
            parentsModel.removeRow(i);
          }
	  for (int i=0; i<theParents.size(); i++) {
            stringValue = ((Node) parents.elementAt(i)).getName();
            parentsModel.addRow(parentsEmptyRow);
            parentsTable.setValueAt(stringValue, i, 0);
	    stringValue = ((Node) parents.elementAt(i)).getTitle();
	    parentsTable.setValueAt(stringValue, i, 1);
	  }
	  /* Modified by Manuel Luque */
          if (bayesNet.getClass() == IDiagram.class) {
            if (node.getKindOfNode()==Node.UTILITY){
                addParentButton.setEnabled(false);
                removeParentButton.setEnabled(false);
                addFromGUIParentButton.setEnabled(false);
                return;
            }
          }
	  int k = 0;
	  boolean isValid;
	  for (int i=0; i<bayesNet.getNodeList().size(); i++) {
	    stringValue = ((Node) bayesNet.getNodeList().elementAt(i)).getName();
            stringValue2 = ((Node) bayesNet.getNodeList().elementAt(i)).getTitle();
	    isValid = true;
            /*if (((Node) bayesNet.getNodeList().elementAt(i)).getKindOfNode() == Node.UTILITY) {
               isValid = false;
            }*/
	    if (node.getName().equals(stringValue)) {
	       isValid = false;
            }
            if (isValid) {
	      for (int j=0; j<parents.size(); j++) {
	       if (stringValue.equals(((Node) parents.elementAt(j)).getName())) {
		  isValid = false;
		  break;
	       }
	      }
            }
	    if (isValid) {
	      //for (int j=0; j<node.getChildrenNodes().size(); j++) {
	        /*if (stringValue.equals(((Node) node.getChildrenNodes().elementAt(j)).getName())) {
		  isValid = false;
		  break;
	        }*/
                isValid = findOutIfNotDescendant((Node) node,stringValue);

		/* Precondition for adding parents to an utility node: it must have some father, because if it hasn't any father
                 * user can select parents of different kinds, wich aren´t simultaneously compatible between themselves. */
                if (bayesNet.getClass()==IDiagram.class){
                    isValid=isValid&&IDiagram.isCompatibleLink(bayesNet.getNodeList().elementAt(i), node);
                }
                else if (bayesNet.getClass()==IDWithSVNodes.class){
                    isValid=isValid&&IDWithSVNodes.isCompatibleLink(bayesNet.getNodeList().elementAt(i), node);
                }

	      //}
            }
 	    if (isValid) {
	       parentsDialogModel.addRow(parentsEmptyRow);
	       parentsDialogTable.setValueAt(stringValue, k, 0);
               parentsDialogTable.setValueAt(stringValue2, k, 1);
	       k++;
	    }
	  }
	}

	/**
	 * Stores the information introduced in the EditVariableDialog
	 * in the node variable. Before storing the name of the dialog it
	 * must be cheked, because it cannot be correct.
	 *
	 * @see getValues
	 */

	public boolean getInformationFromDialog () {
          /* Commented for the moment: later developement for undoing... */
	  //ChangePropertiesEdit changeNode = new ChangePropertiesEdit(node,nodeRelation);
	  if (!node.getName().equals(nameTextField.getText()))
	    node.setName(bayesNet.checkName(nameTextField.getText()));

	  node.setTitle(titleTextField.getText());
	  node.setComment(commentTextArea.getText());
	  Double relevance = Double.valueOf((String) relevanceComboBox.getSelectedItem());
	  node.setRelevance(relevance.doubleValue());

	  // Get information from the kind of node ButtonGroup

	  if (chanceRadioButton.isSelected())
	    node.setKindOfNode(node.CHANCE);
	  else if (decisionRadioButton.isSelected())
	    node.setKindOfNode(node.DECISION);
	  else if (utilityRadioButton.isSelected())
	    node.setKindOfNode(node.UTILITY);

	  if (observedBox.isSelected()){
		  node.setKindOfNode(node.OBSERVED);
	  }
	  
	  // Get information from the kind of node ButtonGroup
	  if (discreteRadioButton.isSelected())
	    node.setTypeOfVariable(node.FINITE_STATES);
	  else if (continuousRadioButton.isSelected())
	    node.setTypeOfVariable(node.CONTINUOUS);
	  else if (utilityRadioButton.isSelected())
	    node.setTypeOfVariable(node.MIXED);

           // Get information from the Values Tab
          boolean value;

          if (isTree){
          ///System.out.println("is Tree");
          //if(treeChanged){
          if (true){
              //System.out.println("is change");
              int correcto=0;
              if (treePanelTree.isCPT()){
              //if (nodeRelation.getValues().getClass()==PotentialContinuousPT.class){
                  ContinuousProbabilityTree T=(ContinuousProbabilityTree)treePanelTree.getTree();
                  PotentialContinuousPT P;
                  if (T!=null)
                    P= new PotentialContinuousPT(nodeRelation.getVariables(),T);
                  else
                    P= new PotentialContinuousPT();
                  
                  nodeRelation.setValues(P);
                  treePanelTree.repaint();
              }else{

                  ProbabilityTree T=(ProbabilityTree)treePanelTree.getTree();
                  PotentialTree P= new PotentialTree(nodeRelation.getVariables());
                  //(PotentialTree)nodeRelation.getValues();

                  P.setTree(T);
                  nodeRelation.setValues(P);
                  treePanelTree.repaint();
              }
              
              
              if (correcto != 0){
                ShowMessages.showMessageDialog(ShowMessages.POT_TREE_INCOMP,
                    JOptionPane.ERROR_MESSAGE);
                value = false;
              }else
                value = true;
              general = false;

              // Get information from the Values Tab
              if (node.getClass()==FiniteStates.class){
                FiniteStates fsNode = (FiniteStates) bayesNet.getNode(node.getName());
                Vector tmpStates = new Vector();
                for (int i=0; i<valuesTable.getRowCount(); i++){
                  tmpStates.addElement(addQm((String)valuesTable.getValueAt(i, 1)));
                }
                fsNode.setStates(tmpStates);
              }

              if (node.getClass()==Continuous.class){
                Continuous fsNode = (Continuous) bayesNet.getNode(node.getName());
                Double a;
                a = new Double(minCVText.getText());
                if (a!=null){
                    fsNode.setMin(a.doubleValue());
                }
                a = new Double(maxCVText.getText());
                if (a!=null){
                    fsNode.setMax(a.doubleValue());
                }

                a = new Double(undefValCVText.getText());
                if (a!=null){
                    if (fsNode.getMin()<=a.doubleValue() && a.doubleValue()<=fsNode.getMax()){
              	        Object[] options = {"Acept"};
                        ShowMessages.showMessageDialog("UndefVal has to be out the range of Continuous node",
                                              JOptionPane.WARNING_MESSAGE);

                    }else{
                        fsNode.setUndefVal(a.doubleValue());
                    }
                    
                    
                }
                Integer b = new Integer(precisionCVText.getText());
                if (b!=null){
                    fsNode.setPrecision(b.intValue());
                }
                String c = unitCVText.getText();
                if (c!=null){
                    fsNode.setUnit(new String(c));
                }
                
              }
              
          
            }
            else {
              value = true;
            }

            return value;
          }
          else{
            if (node.getClass()==FiniteStates.class) {
              FiniteStates fsNode = (FiniteStates) bayesNet.getNode(node.getName());
              Vector tmpStates = new Vector();

              for (int i=0; i<valuesTable.getRowCount(); i++)
                tmpStates.addElement(addQm((String)valuesTable.getValueAt(i, 1)));

              fsNode.setStates(tmpStates);
            }
            
/*            if (node.getClass()==Continuous.class) {
              Continuous fsNode = (Continuous) bayesNet.getNode(node.getName());
              Vector tmpStates = new Vector();

              for (int i=0; i<valuesTable.getRowCount(); i++)
                tmpStates.addElement(addQm((String)valuesTable.getValueAt(i, 1)));

              fsNode.setStates(tmpStates);
            }
*/
            
            if (nodeRelation == null) {
              return true;
            }

            if (nodeRelation.getValues() == null) {
              //nodeRelation.setValues(new PotentialTable(nodeRelation.getVariables()));
              general = true;
              return true;
            }

            //Modificado por jruiz
            if ((nodeRelation.getValues().getClass() == PotentialTable.class ||
                 nodeRelation.getValues().getClass() == GeneralizedPotentialTable.class) && (!isTree)){
              general = true;
            }//Fin modificado por jruiz

            else if ((nodeRelation.getValues().getClass() == CanonicalPotential.class)) {
              general = false;
            }

            if (relationTableChanged) {
              if (valuesMode) {
                transformToProbabilities(nodeRelation);
                value = true;
              }
              else{
                value = getValues(nodeRelation,false);
              }

              if (debug) {
                System.out.println("En getInformationFromDialog");
              }
              /* If the dialog contains a Canonical Relation the posteriori
              probability it is obtained. This must be done because there is
              not an specific method for doing inference with canonical
              relations. In the next version of Elvira this will be implemented */

              /* MODIFIED: commented for the moment */
              if (!general) {
                //PotentialTable pt;
                //pt = ((CanonicalRelation) nodeRelation).expandCPT(parents,node,states);
                //nodeRelation.setValues(pt);
              }
              /* END MODIFIED */
            }
            else
              value = true;
          }
          // Set the relation that has been modified in the list of relations
          //substituteRelation (nodeRelation);
          // Action for undoing
          /*changeNode.setNewProperties(node,nodeRelation);
          NetworkFrame nf = (NetworkFrame) Elvira.getElviraFrame().getCurrentNetworkFrame();
          Elvira.getElviraFrame().getUndoItem().setText(changeNode.getUndoPresentationName());
          Elvira.getElviraFrame().getRedoItem().setText(changeNode.getRedoPresentationName());
          nf.getEditorPanel().getUndoManager().addEdit(changeNode);
          Elvira.getElviraFrame().enableUndo(true);*/

          return value;
        }


        /**
	 * Insert the relation given as parameter in the correct position.
	 * This position is obtained from the relation list, localizing in the
	 * Bayesian Net the relation of the node that is currently edited. When
	 * the new relation is inserted the old one is deleted.
	 *
	 * @param newRelation Relation to be inserted
         */

        private void substituteRelationOrForcedPolicy (Relation newRelation) {
        	int kind;
        	
        	
        	kind = node.getKindOfNode();
        	
        	switch(kind){
        	case Node.CHANCE:
        		Relation r = bayesNet.getRelation(node);
        	    Vector rl = bayesNet.getRelationList();
        	    int index = rl.indexOf(r);

        	    rl.insertElementAt(newRelation, index+1);
        	    rl.removeElement(r);
        	    break;
        	case Node.DECISION:
        		((IDiagram)bayesNet).getForcedPolicies().put(node,newRelation);
        		break;
        	}
         }

	/**
         * Manage the actions produced in the EditVariableDialog
	 **/
       
        
	class SymAction implements java.awt.event.ActionListener {
	    public void actionPerformed(java.awt.event.ActionEvent event) {
	        Object object = event.getSource();
		if (object == okButton)
		  okButton_actionPerformed(event);
		else if (object == cancelButton)
		  cancelButton_actionPerformed(event);
		else if (object == addButton)
		  addButton_actionPerformed(event);
		else if (object == removeButton)
		  removeButton_actionPerformed(event);
                else if (object == addParentButton)
                  addParentButton_actionPerformed(event);
                else if (object == removeParentButton)
                  removeParentButton_actionPerformed(event);
                else if (object == addFromGUIParentButton)
                  addFromGUIParentButton_actionPerformed(event);
		else if (object == upButton)
		  upButton_actionPerformed(event);
		else if (object == downButton)
		  downButton_actionPerformed(event);
                else if (object == upParentButton)
                  upParentButton_actionPerformed(event);
                else if (object == downParentButton)
                  downParentButton_actionPerformed(event);
		else if (object == applyButton)
		  applyButton_actionPerformed(event);
		else if (object == typeRelationButton)
		  typeRelationButton_actionPerformed(event);
		else if (object == okRelationDialogButton)
		  okRelationDialogButton_actionPerformed(event);
		else if (object == cancelRelationDialogButton)
		  cancelRelationDialogButton_actionPerformed(event);
		else if (object == okParentsButton)
		  okParentsButton_actionPerformed(event);
		else if (object == cancelParentsButton)
		  cancelParentsButton_actionPerformed(event);
                else if (object == editVarTabbedPane)
                  cancelButton_actionPerformed(event);
                else if (object == panelRelation)
                  cancelRelationDialogButton_actionPerformed(event);
                else if (object == buttonsRelationDialogPanel)
                  cancelRelationDialogButton_actionPerformed(event);
                else if (object == parentsPanel)
                  cancelParentsButton_actionPerformed(event);
                else if (object == buttonsParentsDialogPanel)
                  cancelParentsButton_actionPerformed(event);
                else if (object == parentsTable)
                  cancelButton_actionPerformed(event);
                else if (object == parentsDialogTable)
                  cancelParentsButton_actionPerformed(event);
	    }
	}

	private boolean acceptButton() {

	  if (debug) {
	    System.out.println("En OKBUTTON");
	    System.out.println("Size="+(int)((PotentialTable)newRelation.getValues()).getSize());
	  }

	  if (cptRadioButton.isSelected()) { /* Not to read the table */
	    optionsDisabled=true;
	    canRadioButton.setSelected(true);
	    optionsDisabled=false;
	    theTableChanged=false;
	    return true;
	  }

	  valuesTable.editingStopped(new ChangeEvent(this));
	  relationTable.editingStopped(new ChangeEvent(this));
	  String newNodeName = nameTextField.getText();

	  if (!oldNodeName.equals (newNodeName)) {
	    if (bayesNet.checkName(newNodeName)==null) {
	      ShowMessages.showMessageDialog(ShowMessages.NODE_NAME_EXISTS,
				   JOptionPane.ERROR_MESSAGE);
	      return true;
	    }
	  }

	  if (thereIsEmptyState()) {
	    Object[] options = { localize(dialogBundle,"Modify.label"),
				   localize(dialogBundle,"Ignore.label") };
	    int reply = ShowMessages.showOptionDialog(ShowMessages.EMPTY_STATES,
				  JOptionPane.WARNING_MESSAGE, options, 1);
	    if (reply==1) {
              if (getInformationFromDialog()) {
                if (newOrder)
                  if(!isTree)
                    if ((node.getKindOfNode() != Node.UTILITY)&&(node.getKindOfNode()!=Node.SUPER_VALUE))
                      reorganizeChildren(statesHasChanged);
                FontMetrics fm=Elvira.getElviraFrame().getCurrentEditorPanel().getFontMetrics(Elvira.getElviraFrame().getCurrentEditorPanel().getFont(node.getFont()));
		VisualNode.setAxis(node,node.getNodeString(byTitle),fm);
	      }
              else{
                return false;
              }
	    }
	  }
	  else {
	    if (getInformationFromDialog()) {
	      if (newOrder)
               if (!isTree)
                 if ((node.getKindOfNode() != Node.UTILITY)&&(node.getKindOfNode()!=Node.SUPER_VALUE))
                   reorganizeChildren(statesHasChanged);
               FontMetrics fm=Elvira.getElviraFrame().getCurrentEditorPanel().getFontMetrics(Elvira.getElviraFrame().getCurrentEditorPanel().getFont(node.getFont()));
               VisualNode.setAxis(node,node.getNodeString(byTitle),fm);
            }
            else{
              return false;
            }
	  }
          
          
          /* It can be necessary to do any modifications if we have a super value node */
          if (node.getKindOfNode()==Node.SUPER_VALUE) {
              if (addRadioButton.isSelected()) {
					//nodeRelation.setKind(Relation.UTILITY_COMBINATION);
                   ((UtilityPotential) nodeRelation.getValues()).setFunction(new SumFunction());
              }
              else{
                  if (multiplyRadioButton.isSelected()){
                        //nodeRelation.setKind(Relation.UTILITY_COMBINATION);
                        ((UtilityPotential) nodeRelation.getValues()).setFunction(new ProductFunction());
                  }
             }
        }
            
          
          /* nodeRelation.setComment(""); */ /* MODIFIED */ /* Why is this here */
	 // if (node.getKindOfNode() != Node.DECISION) {
            if (debug) {
                nodeRelation.print();
            }
	    substituteRelationOrForcedPolicy(nodeRelation);
	  //}
	  /*Taked away for in the case we are working with probability trees*/
          if (!isTree){
            Enumeration e;

            for (e=bayesNet.getLinkList().elements(); e.hasMoreElements(); ) {
              Color arcColor=ElviraPanel.ARC_COLOR;
              Link link = (Link) e.nextElement();

              //System.out.println(bayesNet.getRelation(link.getHead()).getValues().getClass() + " -- " +
              //bayesNet.getRelation(link.getTail()).getValues().getClass());
              if ((bayesNet.getRelation(link.getHead()).getValues() != null) &&
                  (bayesNet.getRelation(link.getTail()).getValues() != null)) {
                if ((bayesNet.getRelation(link.getHead()).getValues().getClass()!=PotentialTree.class) &&
                    (bayesNet.getRelation(link.getTail()).getValues().getClass()!=PotentialTree.class) &&
                    (bayesNet.getRelation(link.getHead()).getValues().getClass()!=PotentialContinuousPT.class) &&
                    (bayesNet.getRelation(link.getTail()).getValues().getClass()!=PotentialContinuousPT.class)&&
                    (bayesNet.getClass()!=IDiagram.class)&&
                    (bayesNet.getClass()!=IDWithSVNodes.class)){
                   if (link.getHead().getKindOfNode()==Node.CHANCE){
                    double[][][] dist=macroExplanation.greaterdist(bayesNet, link.getHead(), link.getTail());
                    if (debug) {
                        System.out.println("Distribución de "+link.getTail().getTitle()+link.getHead().getTitle());
                        macroExplanation.print(dist);
                    }

                    int res=macroExplanation.compare(dist);
                    switch (res){
                        case 0:arcColor=new Color(255,102,102);//rojo
                        break;
                        case 1:arcColor=new Color(102,153,255);//azul
                        break;
                        case 3:arcColor=new Color(204,102,255);//violeta
                        break;
                    }
                    }
                }
              }

              link.setColorLink(arcColor);
            }
          }

          ((NetworkFrame) Elvira.getElviraFrame().getCurrentNetworkFrame()).getEditorPanel().repaint();

          setTitle(localize(dialogBundle, "EditVariable.Node.label")+": "+node.getNodeString(byTitle));
          repaint();
          
          theTableChanged=false;
          return true;

        }

        /**
	 * <P> Method call when the ok Button is clicked. First, check if the
	 * states table has an empty state, and if this happen, show a
	 * warning message.</P>
	 * <P> If everything it is OK or the ignore button of the warning
	 * message is clicked the information displayed in the
	 * EditVariableDialog is saved</P>
	 */

	void okButton_actionPerformed(java.awt.event.ActionEvent event){
		//See functionsNode defined in EditorPanel
		int numberOfPurposesBeforeDefined = 9;
		
          if (functionComboBox.getSelectedIndex()<numberOfPurposesBeforeDefined){
            node.setPurpose(EditorPanel.functionsNode[functionComboBox.getSelectedIndex()]);
          }
          else if (functionComboBox.getSelectedIndex()==numberOfPurposesBeforeDefined){
            String nuevo=editFunctionText.getText();
            node.setPurpose(nuevo);
            if (debug) {
              System.out.println("Al aceptar"+nuevo);
            }
            System.out.println("Functión"+ node.getPurpose());
	    //functionsNode.add(nuevo);
          }

          if (node.getClass() == Continuous.class) {
            ((Continuous) node).setUnit(unitsComboBox.getSelectedItem().toString());
          }

	  // Get the last changes made
	  /**/
	  if (acceptButton()){
            dispose_EditVarDialog();
	  }
	}


	/**
	 * Dispose the EditVariableDialog object and do not save the
	 * information displayed on it
	 */

	void cancelButton_actionPerformed(java.awt.event.ActionEvent event)
	{
          
          dispose_EditVarDialog();
          cancelled = true;
	}

	/**
	 * Apply the modifications made to the node displayed in
	 * the EditVariableDialog
	 */

	void applyButton_actionPerformed(java.awt.event.ActionEvent event){
          if (functionComboBox.getSelectedIndex()<8){
            node.setPurpose(EditorPanel.functionsNode[functionComboBox.getSelectedIndex()]);
          }
          else if (functionComboBox.getSelectedIndex()==8){
            String nuevo=editFunctionText.getText();
            node.setPurpose(nuevo);
            if (debug) {
              System.out.println("Al aceptar"+nuevo);
            }
            System.out.println("Functión"+ node.getPurpose());
            //functionsNode.add(nuevo);
          }

          // Get the last changes made

          /*valuesTable.editingStopped(new ChangeEvent(this));

          if (relationTableChanged){
          relationTable.editingStopped(new ChangeEvent(this));
          substituteRelation(newRelation);
          }*/

          if (node.getClass() == Continuous.class) {
            ((Continuous) node).setUnit(unitsComboBox.getSelectedItem().toString());
          }

          if (getInformationFromDialog())
            fillDialog();
          
          acceptButton();
	}

	/**
	 * This class manage the events produced in the valuesComboBox.
	 * The main action for this ComboBox it is when a new value of
	 * it is selected and the correct states must appears in the
	 * valuesTable
	 */

	class SymItem implements java.awt.event.ItemListener
	{

	   /**
	    * Manage the change of state in the valuesComboBox
	    */

		public void itemStateChanged(java.awt.event.ItemEvent event)
		{
			Object object = event.getSource();
			if (object == valuesComboBox)
				valuesComboBox_itemStateChanged(event);
			else if (object == functionComboBox)
				functionComboBox_itemStateChanged(event);
                        else if (object == unitsComboBox)
                                unitsComboBox_itemStateChanged(event);
			else if (object == relevanceComboBox)
				relevanceComboBox_itemStateChanged(event);
			else if (object == valRadioButton)
				valRadioButton_itemStateChanged(event);
			else if (object == allRadioButton)
				allRadioButton_itemStateChanged(event);
			else if (object == indRadioButton)
				indRadioButton_itemStateChanged(event);
			else if (object == cptRadioButton)
				cptRadioButton_itemStateChanged(event);
			else if (object == canRadioButton)
				canRadioButton_itemStateChanged(event);
			else if (object == optimalRadioButtonDecs)
				optimalRadioButton_itemStateChanged(event);
			else if (object == detRadioButtonDecs)
				detRadioButtonDecs_itemStateChanged(event);
			else if (object == probRadioButtonDecs)
				probRadioButtonDecs_itemStateChanged(event);
			else if (object == detRadioButton)
				detRadioButton_itemStateChanged(event);
			else if (object == probRadioButton)
				probRadioButton_itemStateChanged(event);
			else if (object == henrionRadioButton)
				henrionRadioButton_itemStateChanged(event);
			else if (object == diezRadioButton)
				diezRadioButton_itemStateChanged(event);
			else if (object == probsRadioButton)
				probsRadioButton_itemStateChanged(event);
			else if (object == generalRadioButton)
			        generalRadioButton_itemStateChanged(event);
			else if (object == orRadioButton)
			        orRadioButton_itemStateChanged(event);
			else if (object == causalMaxRadioButton)
			        causalMaxRadioButton_itemStateChanged(event);
			else if (object == generalizedMaxRadioButton)
			        generalizedMaxRadioButton_itemStateChanged(event);
			else if (object == andRadioButton)
			        andRadioButton_itemStateChanged(event);
			else if (object == minRadioButton)
			        minRadioButton_itemStateChanged(event);
			else if (object == xorRadioButton)
			        xorRadioButton_itemStateChanged(event);
                        else if (object == addRadioButton)
                                addRadioButton_itemStateChanged(event);
                        else if (object == multiplyRadioButton)
                                multiplyRadioButton_itemStateChanged(event);
                        else if (object==observedBox){
                        	observedBox_itemStateChanged(event);
                        }
                       
                        		
                        
		}

	private void observedBox_itemStateChanged(ItemEvent event) {
		// TODO Auto-generated method stub
		if (!observedBox.isSelected()){
			node.setKindOfNode(Node.CHANCE);
		}
		else{
			node.setKindOfNode(Node.OBSERVED);
		}
	}

	
	
	}

        /**
	 * Set the states in the valuesTable
	 *
	 * @see loadNewRows
	 */

	void valuesComboBox_itemStateChanged(java.awt.event.ItemEvent event)
	{

		switch (valuesComboBox.getSelectedIndex()) {
		   case 0: loadNewRows (data); break;
		   case 1: loadNewRows (data2); break;
		   case 2: loadNewRows (data3); break;
		   case 3: loadNewRows (data4); break;
		   case 4: loadNewRows (data5); break;
		}

		newOrder = true;
		statesHasChanged = true;

	}

	void functionComboBox_itemStateChanged(java.awt.event.ItemEvent event){
	  if (functionComboBox.getSelectedIndex() ==8){
	    newfunctionLabel.setVisible(true);
	    editFunctionText.setVisible(true);
	    editFunctionText.setEnabled(true);
	    editFunctionText.setText("");
	    editFunctionText.setEditable(true);
	  }
	  else {
	    newfunctionLabel.setVisible(false);
	    editFunctionText.setVisible(false);
	    editFunctionText.setEnabled(false);
	    editFunctionText.setEditable(false);
	  }
	}

        void unitsComboBox_itemStateChanged(java.awt.event.ItemEvent event){
          /* TO DO */
        }

	void relevanceComboBox_itemStateChanged(java.awt.event.ItemEvent event)
	{
	   try {
	      Double.valueOf((String) relevanceComboBox.getSelectedItem());
	   }
	   catch (NumberFormatException e) {
	      ShowMessages.showMessageDialog(ShowMessages.WRONG_RELEVANCE,
                     JOptionPane.ERROR_MESSAGE);
	      relevanceComboBox.setSelectedItem(
	         String.valueOf(node.getRelevance()));

	   }
	}

	/**
	 * Set the values of the names variable in the valuesTable
	 *
	 * @param names Contains the values of that must appear in
	 * the valuesTable
	 */

	public void loadNewRows (Object[][] names) {
	   int i;
	   order = new Vector();

	   for (i=valuesTable.getRowCount(); i<names.length; i++)
	      model.addRow(names[i]);

	   for (i=valuesTable.getRowCount(); i>names.length; i--)
	      model.removeRow(i-1);

	   for (i=0; i<names.length; i++) {
	      //valuesTable.setValueAt(addQm((String)names[i][1]), i, 1);
              valuesTable.setValueAt((String)names[i][1], i, 1);
	      valuesTable.setValueAt(names[i][0], i, 0);
	      order.add(new Integer(i+1));
	   }
	   valuesTable.repaint();
	   statesHasChanged = true;
	}

        void addParentButton_actionPerformed(java.awt.event.ActionEvent event)
        {
            /* To fill */
	    parentsDialog.show();
        }

        void removeParentButton_actionPerformed(java.awt.event.ActionEvent event)
        {
            /* To fill */
            int[] theIndexes = parentsTable.getSelectedRows();

            for (int i=theIndexes.length-1; i>=0; i--) {
                try {
                    ((Network) bayesNet).removeLink(bayesNet.getNode((String) parentsTable.getValueAt(theIndexes[i],0)),node);//bayesNet.getLinkList().getLinks(node.getName(),(String) parentsTable.getValueAt(theIndexes[i],0)));
                    //bayesNet.getLinkList().removeLink(bayesNet.getLinkList().getLinks(node.getName(),(String) parentsTable.getValueAt(theIndexes[i],0)));
                } catch (InvalidEditException iee) {};
                NodeList nl = nodeRelation.getVariables();
                for (int j=0; j<parents.size(); j++) {
                    if (((Node) parents.elementAt(j)).getName().equals((String) parentsTable.getValueAt(theIndexes[i],0))) {
                        parents.removeElementAt(j);
                        break;
                    }
                }
                nl.removeNode(bayesNet.getNode((String) parentsTable.getValueAt(theIndexes[i],0)));
                Vector vl = nl.toVector();
                nodeRelation = new Relation(vl);
               // if (node.getKindOfNode() != Node.DECISION) {
                    statesHasChanged = true;
                    general = true;
                    generateNormalTable(nodeRelation);
                //}
                parentsDialogModel.addRow(parentsEmptyRow);
                parentsDialogTable.setValueAt(parentsModel.getValueAt(theIndexes[i],0),parentsDialogTable.getRowCount()-1,0);
                parentsDialogTable.setValueAt(parentsModel.getValueAt(theIndexes[i],1),parentsDialogTable.getRowCount()-1,1);
                parentsModel.removeRow(theIndexes[i]);
            }
        }

        void addFromGUIParentButton_actionPerformed(java.awt.event.ActionEvent event) {
          this.hide();
          /* TO DO: how to make only nodes selectable? */
          Elvira.getElviraFrame().enableReturnToolbar(this);
        }

	/**
	 * Add a new row in the valuesTable and modify the
	 * states (s0..sn) according to this new state
	 */

	void addButton_actionPerformed(java.awt.event.ActionEvent event)
	{
	   String stateString, valueString;
	   valuesTable.editingStopped(new ChangeEvent(this));
	   model.addRow(emptyRow);
	   if (model.getRowCount()>1)
           for (int i=model.getRowCount()-2; i>=0; i--) {
	      stateString = (String) valuesTable.getValueAt (i,0);
              valueString = (String) valuesTable.getValueAt (i,1);
	      valuesTable.setValueAt(stateString, i+1, 0);
	      valuesTable.setValueAt(valueString, i+1, 1);
	   }
           valuesTable.setValueAt (identifier+String.valueOf(model.getRowCount()-1), 0, 0);
           valuesTable.setValueAt ("", 0, 1);
	   if(node.getKindOfNode()!=Node.DECISION)
	     valuesComboBox.setSelectedIndex(5);  // index of the value Others in the ComboBox
	   newOrder = true;
           statesHasChanged = true;
	   order.insertElementAt(new Integer(model.getRowCount()), 0);
	   valuesTable.repaint();
	}

	/**
	 * Deletes the last row of the valuesTable and modify
	 * the states (s0..sn) according to this values removed
	 */

	void removeButton_actionPerformed(java.awt.event.ActionEvent event)
	{
	  String stringValue;
	  valuesTable.editingStopped(new ChangeEvent(this));
	  int row = valuesTable.getSelectedRow();

	  if (row !=-1) {
	      model.removeRow(row);
	      System.out.print(row);
	      order.removeElementAt(row);
	  }

	  for (int i=0; i<model.getRowCount(); i++) {
	      stringValue = String.valueOf (model.getRowCount()-i-1);
	      valuesTable.setValueAt(identifier+stringValue, i, 0);
	  }

	  newOrder = true;
          statesHasChanged = true;
	  valuesTable.repaint();
	}

        private void changePTableOrdering(Relation relation, Vector oldOrder, Vector newOrder) {
          PotentialTable pt = (PotentialTable) relation.getValues();
          double[] theValues = new double[(int) pt.getSize()];
          Configuration oldConfig = new Configuration(oldOrder);
          //Configuration newConfig = new Configuration(newOrder);
          Configuration newConfig = new Configuration(pt.getVariables());

          if (node.getClass() == Continuous.class) {
              return;
          }
          
          for (int i=0; i<theValues.length; i++) {
            theValues[i] = pt.getValue(i);
          }

          for (int i=0; i<theValues.length; i++) {
            for (int j=0; j<newOrder.size(); j++) {
              newConfig.putValue(((Node) oldOrder.elementAt(j)).getName(),oldConfig.getValue(((Node) oldOrder.elementAt(j)).getName()));
            }
            pt.setValue(newConfig,theValues[i]);
            oldConfig.nextConfiguration();
          }
        }

        private void changeCanTableOrdering(Relation relation, Vector oldOrder, Vector newOrder) {
          CanonicalPotential cp = (CanonicalPotential) relation.getValues();
          PotentialTable[] ptt = new PotentialTable[oldOrder.size()];
          String[] theStr = new String[oldOrder.size()];

          for (int i=0; i<oldOrder.size()-1; i++) {
            ptt[i] = (PotentialTable) cp.getArgumentAt(i);
            theStr[i] = cp.getStrArgument(i);
          }

          for (int i=0; i<newOrder.size()-1; i++) {
            int where=-1;
            for (int j=0; j<oldOrder.size()-1; j++) {
              String auS = new String();
              auS = node.getName();
              if (theStr[j].equals(auS+((Node) newOrder.elementAt(i+1)).getName())) {
                where=j;
                break;
              }
            }
            if (where != -1) {
              cp.setArgumentAt(ptt[where],i);
              cp.setStrArgumentAt(theStr[where],i);
            }
          }
        }
        
        void changeLinkList(Vector oldOrder, Vector newOrder) {
          LinkList ll = new LinkList();
          Vector v = new Vector();
          for (int i=0; i<newOrder.size()-1; i++) {
            int where=-1;
            for (int j=0; j<oldOrder.size()-1; j++) {
              if (((Link) node.getParents().elementAt(j)).getTail().getName().equals(((Node) newOrder.elementAt(i+1)).getName())) {
                where=j;
                break;
              }
            }
            if (where!=-1) {
              v.addElement(node.getParents().elementAt(where));
            }
          }
          ll.setLinks(v);
          node.setParents(ll);
          
          LinkList bll = bayesNet.getLinkList();
          int[] oldPos = new int[(int) oldOrder.size()-1];
          
          for (int i=0; i<oldOrder.size()-1; i++) {
            oldPos[i] = bll.getID(((Node) oldOrder.elementAt(i+1)).getName(), ((Node) oldOrder.elementAt(0)).getName());
          }
          
          Vector vc = new Vector();
          
          for (int i=0; i<bll.size(); i++) {
            vc.addElement(bll.getLinks().elementAt(i));
          }
          
          for (int i=0; i<newOrder.size()-1; i++) {
            vc.setElementAt((Link) v.elementAt(i),oldPos[i]);
          }
          
          bll.setLinks(vc);
        }

        void upParentButton_actionPerformed(java.awt.event.ActionEvent event)
        {
            /* To fill */
           String stringUp, stringDown;
           Vector oldOrder = new Vector(), newOrder = new Vector();
           int posUp=0, posDown=0;
           Node nodeUp=(Node) new FiniteStates(), nodeDown=(Node) new FiniteStates();
           NodeList nl=new NodeList();
           Vector theVars=new Vector();
           oldOrder.addElement(node);
           for (int i=0; i<parents.size(); i++) {
             oldOrder.addElement(parents.elementAt(i));
           }
           int[] theRows = parentsTable.getSelectedRows();
           boolean isValid = true;
           for (int i=0; i<theRows.length; i++) {
               if (theRows[i] == 0) {
                 isValid = false;
               }
           }
           if (isValid) {
             for (int i=0; i<theRows.length; i++) {
                 stringUp=(String)parentsModel.getValueAt(theRows[i],1);
                 stringDown=(String)parentsModel.getValueAt(theRows[i]-1,1);
                 parentsModel.setValueAt(stringUp,theRows[i]-1,1);
                 parentsModel.setValueAt(stringDown,theRows[i],1);
                 stringUp=(String)parentsModel.getValueAt(theRows[i],0);
                 stringDown=(String)parentsModel.getValueAt(theRows[i]-1,0);
                 parentsModel.setValueAt(stringUp,theRows[i]-1,0);
                 parentsModel.setValueAt(stringDown,theRows[i],0);
                 parentsTable.changeSelection(theRows[i]-1,0,true,false);
                 parentsTable.changeSelection(theRows[i],0,true,false);
                 /* Exchange parents... */
                 if (node.getKindOfNode() != Node.DECISION) {
                    nl = nodeRelation.getVariables();
                    nodeUp = nl.getNode(stringUp);
                    nodeDown = nl.getNode(stringDown);
                    posUp = nl.getId(stringUp);
                    posDown = nl.getId(stringDown);
                    nl.setElementAt(nodeUp,posDown);
                    nl.setElementAt(nodeDown,posUp);
                    nodeRelation.setVariables(nl);
                 }
                 if ((node.getKindOfNode() != Node.DECISION) && (nodeRelation.getValues() != null)) {
                     theVars = nodeRelation.getValues().getVariables();
                     for (int j=0; j<theVars.size(); j++) {
                        if (((Node) theVars.elementAt(j)).getName().equals(stringUp)) {
                            nodeUp=(Node)theVars.elementAt(j);
                            posUp=j;
                        }
                        else if (((Node) theVars.elementAt(j)).getName().equals(stringDown)) {
                            nodeDown=(Node)theVars.elementAt(j);
                            posDown=j;
                        }
                     }
                     theVars.setElementAt(nodeUp,posDown);
                     theVars.setElementAt(nodeDown,posUp);
                     nodeRelation.getValues().setVariables(theVars);
                 }
                 for (int j=0; j<parents.size(); j++) {
                    if (((Node) parents.elementAt(j)).getName().equals(stringUp)) {
                        nodeUp=(Node)parents.elementAt(j);
                        posUp=j;
                    }
                    else if (((Node) parents.elementAt(j)).getName().equals(stringDown)) {
                        nodeDown=(Node)parents.elementAt(j);
                        posDown=j;
                    }
                 }
                 parents.setElementAt(nodeUp,posDown);
                 parents.setElementAt(nodeDown,posUp);
             }
             parentsTable.repaint();
             newOrder.addElement(node);
             for (int i=0; i<parents.size(); i++) {
               newOrder.addElement(parents.elementAt(i));
             }
             if ((node.getKindOfNode() != Node.DECISION) && (nodeRelation.getValues() != null)) {

               //Modificado por jruiz
               if (nodeRelation.getValues().getClass() == PotentialTable.class ||
                   nodeRelation.getValues().getClass() == GeneralizedPotentialTable.class) {
                  statesHasChanged=true;
                  changePTableOrdering(nodeRelation,oldOrder,newOrder);
                  generateNormalTable(nodeRelation);
               }//Fin modificado por jruiz

               else if (nodeRelation.getValues().getClass() == CanonicalPotential.class) {
                  statesHasChanged=true;
                  changeCanTableOrdering(nodeRelation,oldOrder,newOrder);
                  generateCanonicalTable(nodeRelation);
               }
             }
             changeLinkList(oldOrder,newOrder);
           }
           /*if (nodeRelation.getValues() != null) {
             //Modificado por jruiz
             if (nodeRelation.getValues().getClass() == PotentialTable.class ||
                 nodeRelation.getValues().getClass() == GeneralizedPotentialTable.class) {
                generateNormalTable(nodeRelation);
             }//Fin modificado por jruiz
             else if (nodeRelation.getValues().getClass() == CanonicalPotential.class) {
                generateCanonicalTable(nodeRelation);
             }
           }*/
        }

        void downParentButton_actionPerformed(java.awt.event.ActionEvent event)
        {
            /* To fill */
           String stringUp, stringDown;
           Vector oldOrder = new Vector(), newOrder = new Vector();
           int posUp=parentsTable.getRowCount()-1, posDown=parentsTable.getRowCount()-1;
           Node nodeUp=new FiniteStates(), nodeDown=new FiniteStates();
           NodeList nl=new NodeList();
           Vector theVars=new Vector();
           oldOrder.addElement(node);
           for (int i=0; i<parents.size(); i++) {
             oldOrder.addElement(parents.elementAt(i));
           }
           int[] theRows = parentsTable.getSelectedRows();
           boolean isValid = true;
           for (int i=0; i<theRows.length; i++) {
               if (theRows[i] == parentsTable.getRowCount()-1) {
                 isValid = false;
               }
           }
           if (isValid) {
             for (int i=theRows.length-1; i>=0; i--) {
                 stringUp=(String)parentsModel.getValueAt(theRows[i]+1,1);
                 stringDown=(String)parentsModel.getValueAt(theRows[i],1);
                 parentsModel.setValueAt(stringUp,theRows[i],1);
                 parentsModel.setValueAt(stringDown,theRows[i]+1,1);
                 stringUp=(String)parentsModel.getValueAt(theRows[i]+1,0);
                 stringDown=(String)parentsModel.getValueAt(theRows[i],0);
                 parentsModel.setValueAt(stringUp,theRows[i],0);
                 parentsModel.setValueAt(stringDown,theRows[i]+1,0);
                 parentsTable.changeSelection(theRows[i],0,true,false);
                 parentsTable.changeSelection(theRows[i]+1,0,true,false);
                 /* Exchange parents... */
                 if (node.getKindOfNode() != Node.DECISION) {
                    nl = nodeRelation.getVariables();
                    nodeUp = nl.getNode(stringUp);
                    nodeDown = nl.getNode(stringDown);
                    posUp = nl.getId(stringUp);
                    posDown = nl.getId(stringDown);
                    nl.setElementAt(nodeUp,posDown);
                    nl.setElementAt(nodeDown,posUp);
                    nodeRelation.setVariables(nl);
                 }
                 if ((node.getKindOfNode() != Node.DECISION) && (nodeRelation.getValues() != null)) {
                     theVars = nodeRelation.getValues().getVariables();
                     for (int j=0; j<theVars.size(); j++) {
                        if (((Node) theVars.elementAt(j)).getName().equals(stringUp)) {
                            nodeUp=(Node)theVars.elementAt(j);
                            posUp=j;
                        }
                        else if (((Node) theVars.elementAt(j)).getName().equals(stringDown)) {
                            nodeDown=(Node)theVars.elementAt(j);
                            posDown=j;
                        }
                     }
                     theVars.setElementAt(nodeUp,posDown);
                     theVars.setElementAt(nodeDown,posUp);
                     nodeRelation.getValues().setVariables(theVars);
                 }
                 for (int j=0; j<parents.size(); j++) {
                    if (((Node) parents.elementAt(j)).getName().equals(stringUp)) {
                        nodeUp=(Node)parents.elementAt(j);
                        posUp=j;
                    }
                    else if (((Node) parents.elementAt(j)).getName().equals(stringDown)) {
                        nodeDown=(Node)parents.elementAt(j);
                        posDown=j;
                    }
                 }
                 parents.setElementAt(nodeUp,posDown);
                 parents.setElementAt(nodeDown,posUp);
             }
             parentsTable.repaint();
             newOrder.addElement(node);
             for (int i=0; i<parents.size(); i++) {
               newOrder.addElement(parents.elementAt(i));
             }
             if ((node.getKindOfNode() != Node.DECISION) && (nodeRelation.getValues() != null)) {

               //Modificado por jruiz
               if (nodeRelation.getValues().getClass() == PotentialTable.class ||
                   nodeRelation.getValues().getClass() == GeneralizedPotentialTable.class) {
                  statesHasChanged=true;
                  changePTableOrdering(nodeRelation,oldOrder,newOrder);
                  generateNormalTable(nodeRelation);
               }//Fin modificado por jruiz

               else if (nodeRelation.getValues().getClass() == CanonicalPotential.class) {
                  statesHasChanged=true;
                  changeCanTableOrdering(nodeRelation,oldOrder,newOrder);
                  generateCanonicalTable(nodeRelation);
               }
             }
             changeLinkList(oldOrder,newOrder);
           }
           /*if (nodeRelation.getValues() != null) {
             //Modificado por jruiz
             if (nodeRelation.getValues().getClass() == PotentialTable.class ||
                 nodeRelation.getValues().getClass() == GeneralizedPotentialTable.class) {
                generateNormalTable(nodeRelation);
             }//Fin modificado por jruiz
             else if (nodeRelation.getValues().getClass() == CanonicalPotential.class) {
                generateCanonicalTable(nodeRelation);
             }
           }*/
        }

	/**
	 * Move the row selected in the valuesTable up one position
	 * and changes the states (s0..sn) according to this modification
	 */

	void upButton_actionPerformed(java.awt.event.ActionEvent event)
	{
	   String stringUp, stringDown;
	   valuesTable.editingStopped(new ChangeEvent(this));
	   int row = valuesTable.getSelectedRow();
		if (row!=-1 && row!=0) {
		   stringUp = (String)model.getValueAt(row, 1);
		   stringDown = (String)model.getValueAt (row-1,1);
		   model.setValueAt(stringUp, row-1, 1);
		   model.setValueAt(stringDown, row, 1);
		   Integer pos = (Integer) order.elementAt(row);
		   order.removeElementAt(row);
		   order.insertElementAt(pos, row-1);
		}
	  newOrder = true;
    	  valuesTable.repaint();
	}

	/**
	 * Move the row selected in the valuesTable down one position
	 * and changes the states (s0..sn) according to this modification
	 */

	void downButton_actionPerformed(java.awt.event.ActionEvent event)
	{
	   String stringUp, stringDown;
	   valuesTable.editingStopped(new ChangeEvent(this));
	   int row = valuesTable.getSelectedRow();
		if (row!=-1 && row!=valuesTable.getRowCount()-1) {
		   stringDown = (String)model.getValueAt(row, 1);
		   stringUp = (String)model.getValueAt (row+1,1);
		   model.setValueAt(stringDown, row+1, 1);
		   model.setValueAt(stringUp, row, 1);
		   Integer pos = (Integer) order.elementAt(row);
		   order.removeElementAt(row);
		   order.insertElementAt(pos, row+1);
		}
	  newOrder = true;
	  valuesTable.repaint();
	}


	/**
	 * Used with the bundles. Find the string given as parameter in
	 * the bundle specified
	 */

        public String localize (ResourceBundle bundle, String name) {
	  return Elvira.getElviraFrame().localize(bundle, name);
        }

        /**
	 * @return True if there is an empty state into the state table
	 */

        public boolean thereIsEmptyState () {
	  for (int i=0; i<valuesTable.getRowCount(); i++){
	    if ((valuesTable.getValueAt(i,1)==null) || (valuesTable.getValueAt(i, 1).equals("")))
              return true;
	  }

	  return false;
        }

        public void lockColumns() {
	  int total = 0;
	  lockedColumnsArray = new int[parents.size()+1];
	  lockedColumns = true;
	  for (int i=0; i<parents.size(); i++) {
	    total = total + ((FiniteStates) parents.elementAt(i)).getNumStates();
	    lockedColumnsArray[i]=total;
	  }
	  lockedColumnsArray[parents.size()]=-1;
        }


	/**
	 * Asks for the kind of relation the first time a node Relation is edited
	 */

	public void showrelationDialog() {

	  /* Checking the states of node and parents to know which possibilities
	   * should be made available for relation type */

          if ((node.getKindOfNode() == Node.UTILITY)||(node.getKindOfNode()==Node.SUPER_VALUE)) {
            return;
          }
          

          boolean isRelationTree=false;
          if (node.getClass()==Continuous.class)
                isRelationTree=true;
          
          for (int i=0; i<parents.size(); i++) {
	    if ((parents.elementAt(i)).getClass()==Continuous.class) {
	      isRelationTree=true;
	    }
	   }

          if (isRelationTree){
                orRadioButton.setEnabled(false);
                andRadioButton.setEnabled(false);
                xorRadioButton.setEnabled(false);
                generalRadioButton.setEnabled(false);
                causalMaxRadioButton.setEnabled(false);
                generalizedMaxRadioButton.setEnabled(false);
                minRadioButton.setEnabled(false);
                treeRadioButton.setEnabled(true);
              
          }else{

              
                  boolean allBinary=true;

                  Vector theStates = new Vector();

                  xorRadioButton.setEnabled(false);

                  if (oldStatesNumber!=valuesTable.getRowCount()) {
                    for (int i=0; i<valuesTable.getRowCount(); i++) {
                      theStates.addElement(addQm((String)valuesTable.getValueAt(i, 1)));
                    }

                    ((FiniteStates) node).setStates(theStates);
                    //oldStatesNumber=valuesTable.getRowCount();
                  }

                  if (((FiniteStates) node).getNumStates() != 2) {
                    allBinary=false;
                  }

                  for (int i=0; i<parents.size(); i++) {
                    if (((FiniteStates) parents.elementAt(i)).getNumStates() != 2) {
                      allBinary=false;
                    }
                  }

                  for (int i=0; i<((FiniteStates) node).getChildrenNodes().size(); i++) {
                    if (((FiniteStates) node).getChildrenNodes().elementAt(i).getClass() == FiniteStates.class) {
                      if (((FiniteStates) ((FiniteStates) node).getChildrenNodes().elementAt(i)).getNumStates() != 2) {
                        allBinary=false;
                      }
                    }
                  }

                  if(parents.size() > 1){
                    if (allBinary) {
                      orRadioButton.setEnabled(true);
                      andRadioButton.setEnabled(true);
                      //xorRadioButton.setEnabled(true);
                    }
                    else {
                      orRadioButton.setEnabled(false);
                      andRadioButton.setEnabled(false);
                      //xorRadioButton.setEnabled(false);
                    }
                  }
          }
                  
          
          relationDialog.setVisible(true);
	  //editVarTabbedPane.setEnabledAt(0,false);
	  //editVarTabbedPane.setEnabledAt(1,false);
	  //editVarTabbedPane.setEnabledAt(2,false);
	  //editVarTabbedPane.setEnabledAt(3,false);
	  //okButton.setEnabled(false);
	  //applyButton.setEnabled(false);
	  //cancelButton.setEnabled(false);
	}

	/**
	 * Manage the events produced in the editVarTabbedPane
	 */

	class SymChange implements javax.swing.event.ChangeListener	{
          public void stateChanged(javax.swing.event.ChangeEvent event)		{
            Object object = event.getSource();
            valuesTable.editingStopped(new ChangeEvent(this));
            if (!isEditable) {
              typeRelationButton.setEnabled(false);
            }

            if (object == editVarTabbedPane) {
              parentsTable.clearSelection();

              if (isTree){
                if(editVarTabbedPane.getSelectedIndex() != 3){
                  if(treeChanged){
                    saveTree(nodeRelation, treeModel, myTreeModelListener);
                    treeChanged = false;
                  }
                }
              }

              if ((node.getKindOfNode()!=Node.DECISION)&&(editVarTabbedPane.getSelectedIndex() == 3) &&
                  (nodeRelation.getComment().equals("new") || (oldStatesNumber != valuesTable.getRowCount())) && node.getClass()!=Continuous.class) {
                if (node.getParents().size() > 1) {
                  orRadioButton.setEnabled(true);
                  causalMaxRadioButton.setEnabled(true);
                  generalizedMaxRadioButton.setEnabled(true);
                  andRadioButton.setEnabled(true);
                  minRadioButton.setEnabled(true);

                  System.out.println("H1"+nodeRelation.getComment()+","+oldStatesNumber+", "+valuesTable.getRowCount());
                  if (debug) {
                    System.out.println("At StateChanged");
                  }

                  /**/
                  if (!isTree)
                    generalRadioButton.setSelected(true);
                  else
                    treeRadioButton.setSelected(true);

                  if ((node.getKindOfNode() != Node.UTILITY)&&(node.getKindOfNode()!=node.SUPER_VALUE)) {
                    showrelationDialog();
                  }
                  else {
                    if (node.getKindOfNode()!=Node.SUPER_VALUE) {
                    /**/if (!isTree){
                      generateNormalTable(nodeRelation);
                      nodeRelation.setComment("");
                      nodeRelation.setKind(Relation.UTILITY);
                     }else
                      loadTree(null);
                    }
                  }
                }
                else if ((node.getParents().size() == 0) ||
                         (node.getParents().size() == 1)) {

                  /*nodeRelation.setComment("");
                  newRelation.setComment("");

           

                  general = true;
                  enableRelationOptions();
                  generateNormalTable(nodeRelation);
                  typeRelationButton.setEnabled(false);*/

                  orRadioButton.setEnabled(false);
                  causalMaxRadioButton.setEnabled(false);
                  generalizedMaxRadioButton.setEnabled(false);
                  andRadioButton.setEnabled(false);
                  minRadioButton.setEnabled(false);

                  nodeRelation.setComment("");
                  newRelation.setComment("");
                  System.out.println("H2");
                  if ((node.getKindOfNode() != Node.UTILITY) &&
                      (node.getKindOfNode() != Node.DECISION) &&
                      (node.getKindOfNode() != Node.SUPER_VALUE)) {
                    showrelationDialog();
                  }
                  else if ((node.getKindOfNode() != Node.UTILITY)&&(node.getKindOfNode()!=Node.SUPER_VALUE)) {
                    newRelation.setKind(Relation.POTENTIAL);
                    nodeRelation.setKind(Relation.POTENTIAL);
                  }
                  else if (node.getKindOfNode()==Node.UTILITY){
                    newRelation.setKind(Relation.UTILITY);
                    nodeRelation.setKind(Relation.UTILITY);
                  }
                  else if (node.getKindOfNode()==Node.SUPER_VALUE){
                      newRelation.setKind(Relation.UTILITY_COMBINATION);
                      nodeRelation.setKind(Relation.UTILITY_COMBINATION);
                  }
                  
                  //if (node.getKindOfNode() != Node.DECISION) {
                    substituteRelationOrForcedPolicy(newRelation);
                  //}
                  
                  enableRelationOptions();
                  
                  
                  
                  
                }
                /* ACTION TO ADD */
                editVarTabbedPane_stateChanged(event);
                lastTabbedPane = 3;
              }
              else if (editVarTabbedPane.getSelectedIndex() == 3) {
                /* Relation table is only generated when checking Relation Tab */
                editVarTabbedPane_stateChanged(event);
                /*  if ((node.getParents().size() == 0) ||
                (node.getParents().size() == 1)) {
                typeRelationButton.setEnabled(false);
                }*/
                lastTabbedPane = 3;
              }
              else
                lastTabbedPane = editVarTabbedPane.getSelectedIndex();
            }
          }
        }

        
        
        
        
        
        /**
	 * Generates the relationTable of the variable displayed in the
	 * EditVariableDialog
	 */
       
        void editVarTabbedPane_stateChanged(javax.swing.event.ChangeEvent event) {
            boolean condition;
        	
        	optionsDisabled=true;
            parentsTable.clearSelection();
            //condition = node.getKindOfNode()!=Node.DECISION;
            condition = true;
            
            if (condition) {
                Potential potential=nodeRelation.getValues();

                //Modificado por jruiz
                if (potential.getClass()==PotentialTable.class || potential.getClass() == GeneralizedPotentialTable.class) {
                    general=true;
                    generalRadioButton.setSelected(true);
                    if (node.getKindOfNode() == Node.UTILITY) {
                        nodeRelation.setKind(Relation.UTILITY);
                        typeRelationButton.setText(localize(dialogBundle,"EditVariable.Utility.label"));
                        typeRelationButton.disable();
                    }
                    else {
                        nodeRelation.setKind(Relation.POTENTIAL);
                        typeRelationButton.setText(localize(dialogBundle,"EditVariable.relationDialogGeneral.label"));
                    }
                }//Fin modificado por jruiz

                else if (potential.getClass()==CanonicalPotential.class) {
                    general = false;
                    
                    if (((CanonicalPotential)nodeRelation.getValues()).getFunction().getName().equals("Or")) {
                        orRadioButton.setSelected(true);
                        nodeRelation.setKind(Relation.OR);
                        typeRelationButton.setText(localize(dialogBundle,"EditVariable.relationDialogOr.label"));
                    }
                    else if (((CanonicalPotential)nodeRelation.getValues()).getFunction().getName().equals("CausalMax")) {
                        causalMaxRadioButton.setSelected(true);
                        nodeRelation.setKind(Relation.CAUSAL_MAX);
                        typeRelationButton.setText(localize(dialogBundle,"EditVariable.relationDialogCausalMax.label"));
                    }
                    else if (((CanonicalPotential)nodeRelation.getValues()).getFunction().getName().equals("GeneralizedMax")) {
                        generalizedMaxRadioButton.setSelected(true);
                        nodeRelation.setKind(Relation.GENERALIZED_MAX);
                        typeRelationButton.setText(localize(dialogBundle,"EditVariable.relationDialogGeneralizedMax.label"));
                    }
                    else if (((CanonicalPotential)nodeRelation.getValues()).getFunction().getName().equals("And")) {
                        andRadioButton.setSelected(true);
                        nodeRelation.setKind(Relation.AND);
                        typeRelationButton.setText(localize(dialogBundle,"EditVariable.relationDialogAnd.label"));
                    }
                    else if (((CanonicalPotential)nodeRelation.getValues()).getFunction().getName().equals("Min")) {
                        minRadioButton.setSelected(true);
                        nodeRelation.setKind(Relation.MIN);
                        typeRelationButton.setText(localize(dialogBundle,"EditVariable.relationDialogMin.label"));
                    }
                    else if (((CanonicalPotential)nodeRelation.getValues()).getFunction().getName().equals("Xor")) {
                          /*xorRadioButton.setSelected(true);
                          nodeRelation.setKind(Relation.XOR);
                          typeRelationButton.setText(localize(dialogBundle,"EditVariable.relationDialogXor.label"));*/
                        System.out.println("XOR canonical model not implemented!!!!!");
                    }
                }
                else if (potential.getClass()==UtilityPotential.class) {
                    String nameFunction;
                    
                    general=false;
                    nameFunction=((UtilityPotential)nodeRelation.getValues()).getFunction().getName();
                    
                    if (nameFunction.equals("Add")) {
                        addRadioButton.setSelected(true);
                        nodeRelation.setKind(Relation.UTILITY_COMBINATION);
                        typeRelationButton.setVisible(false);
                    }
                    else if (nameFunction.equals("Multiply")) {
                        multiplyRadioButton.setSelected(true);
                        nodeRelation.setKind(Relation.UTILITY_COMBINATION);
                        typeRelationButton.setVisible(false);
                    }
                    
                }
            } //if (node.getKindOfNode()!=Node.DECISION)
            
            else {
                selectAllRadioButton(true);
            }
            /* TO MODIFY */
            previousRelationType = typeRelationButton.getText();
            optionsDisabled = false;
            
            if ((node.getKindOfNode()==Node.SUPER_VALUE)&&(nodeRelation.getKind()==Relation.UTILITY_COMBINATION)){
                return;
            }
            
            //if (node.getKindOfNode()!=Node.DECISION){
                if (nodeRelation.isDeterministic()) {

                    //Modificado por jruiz
                    if (nodeRelation.getValues().getClass() == PotentialTable.class || 
                        nodeRelation.getValues().getClass() == GeneralizedPotentialTable.class) {
                        general = true;
                        generateNormalTable(nodeRelation);
                    }//Fin modificado por jruiz

                    else if (nodeRelation.getValues().getClass() != PotentialTree.class && nodeRelation.getValues().getClass() != PotentialContinuousPT.class){
                        general = false;
                        generateCanonicalTable(nodeRelation);
                    }
                    optionsDisabled = true;
                    probsRadioButton.setSelected(true);
                    panelSetEnabled(panel2,true);
                    optionsDisabled = false;
               enableRelationOptions();
               /**/
               if (isTree){
                 general = false;
                 loadTree(nodeRelation);
               }

               JComboBox comboBox = new JComboBox();

               // Add the states to the combo box
               comboBox.addItem("1.0");
               comboBox.addItem("0.0");

               tcm = relationTable.getColumnModel();

               // Set the combo box created as the cell editor
               for (int i=0; i<relationTable.getColumnCount(); i++) {
                 TableColumn column = tcm.getColumn(i);
                 column.setCellEditor(new DefaultCellEditor(comboBox));
               }

               return;
             }

             //Modificado por jruiz
             if (nodeRelation.getValues().getClass() == PotentialTable.class ||
                 nodeRelation.getValues().getClass() == GeneralizedPotentialTable.class) {
               general = true;
               generateNormalTable(nodeRelation);
             }//Fin modificado por jruiz

             else if (isTree){
               general = false;
               //loadTree(nodeRelation);
             }
             else{
               general = false;
               generateCanonicalTable(nodeRelation);
             }
           //}
        }


	/**
         * Generates the table of the relation that must appear in the
         * Dialog, with all its parents and states.
         */

	public void generateNormalTable (Relation relation) {
	  Vector leftColumn = new Vector();
	  newRelation = relation;
          PotentialTable pt=new PotentialTable();

          if (relation.getValues() != null) {
            if (relation.getValues().getClass() == PotentialTable.class){
                pt = (PotentialTable) relation.getValues();
            }

            //Introducido por jruiz
            else if (relation.getValues().getClass() == GeneralizedPotentialTable.class){
                pt = (GeneralizedPotentialTable) relation.getValues();
            }//Fin introducido por jruiz

            else if (relation.getValues().getClass() == CanonicalPotential.class) {
                pt = ((CanonicalPotential) relation.getValues()).getCPT();
            }
          }

	  int numStatesN=oldStatesNumber;
	  int newtotal=0;

	  if (debug) {
	    System.out.println("RELATION AL PRINCIPIO");
	    relation.print();
	    System.out.println("Size="+(int)((PotentialTable)newRelation.getValues()).getSize());
	  }

	  // Get the last value modified
	  valuesTable.editingStopped(new ChangeEvent(this));
	  if (editVarTabbedPane.getSelectedIndex()==3 && statesHasChanged) {
            if (node.getKindOfNode() == Node.UTILITY) {
               numStatesN=1;
               newtotal=1;
               for (int i=0; i<parents.size(); i++) {
                 if (parents.elementAt(i).getClass() == FiniteStates.class) {
                   newtotal=newtotal*((FiniteStates) parents.elementAt(i)).getNumStates();
                 }
               }
               pt = new PotentialTable(parents);
               if (newRelation.getValues() == null) {
                 newRelation.setValues(pt);
               }
            }
	    if (oldStatesNumber!=valuesTable.getRowCount()) {
	      Object[] options = { localize(dialogBundle,"Yes.label"),
				   localize(dialogBundle,"No.label") };
              if (node.getKindOfNode() != Node.UTILITY) {
                numStatesN=valuesTable.getRowCount();
                newtotal=((int)(pt.getSize()/oldStatesNumber))*valuesTable.getRowCount();
              }
	      double[] newvalues = new double[newtotal];
	      if (debug) {
	        System.out.println("newtotal="+newtotal+" valuesTable.getRowCount()="+
		   valuesTable.getRowCount()+" oldstatesnumber="+oldStatesNumber);
	      }
	      /*int reply = ShowMessages.showOptionDialog(ShowMessages.EQUIPROBABILITY,
						JOptionPane.WARNING_MESSAGE,
						options, 1);*/
	      //if (reply==0) { /*SI DECIMOS QUE SÍ*/
	      if (true) {
		for (int j=0; j<newtotal; j++) {
		  newvalues[j]=(double) 1/valuesTable.getRowCount();
		}
	      }
	      else {/* SI DECIMOS QUE NO, RELLENAMOS EL PRIMERO A 1 Y EL RESTO A 0 */
	        newvalues[0]=1;

	        for (int j=1; j<newtotal; j++) {
	          newvalues[j]=0; /* THIS IS WRONG */
	        }
	      }

	      newRelation = new Relation(relation.getVariables().toVector());
	      PotentialTable poti = new PotentialTable(relation.getValues().getVariables());
	      poti.setValues(newvalues);
	      newRelation.setValues(poti);
              relation.setValues(poti);
	      /*if (general) {
		relation.setValues(poti);
	      }*/
	      oldStatesNumber=valuesTable.getRowCount();
	    }
	    else {
	      //numStatesN=oldStatesNumber;
              numStatesN=valuesTable.getRowCount();
	    }

	    if (node.getKindOfNode()==Node.UTILITY){
	      numStatesN=1;
	    }

	    relationTableChanged = true;

	    // Initializes the probability table
	    states = new Vector();
	    if (node.getKindOfNode()==Node.UTILITY) {
	      //states.addElement(localize(dialogBundle,"EditVariable.Utility.label"));
              states.addElement(node.getName());
	    }
	    else {
	      if (valuesTable.getRowCount()<1) {
	        ShowMessages.showMessageDialog(ShowMessages.ENOUGH_STATES,
				       JOptionPane.ERROR_MESSAGE);
	        return;
	      }

	      int rowLines = valuesTable.getRowCount();

	      if ((indRadioButton.isSelected()) || (valuesMode)) {
	        rowLines--;
	      }

	      for (int i=0; i<rowLines; i++) {
	        states.addElement(addQm((String)valuesTable.getValueAt(i, 1)));
	      }
	    }

	    clearRelationTable();
	    parents = new Vector();
	    columnsNumber(1,leftColumn);

	    /* The variable positions is used to generate the headers
	       of the columns.
	       Contains a list of integers with the position of the state
	       of every variable that must appear in every column. For
	       example if we are editing the variable a and has two parents
	       b (with states (True,False)) and c (with states (Present,Absent);
	       if the positions variable has the values (0,1) it means that
	       the columns headers will be (True, Absent) */

	    //int positions[]= new int[node.getParents().size()];
	    //Changed for decisions
	    int positions[]=new int[newRelation.getVariables().size()-1];
	    
	    if (valuesMode) {
	      rows = positions.length+1;
	      leftColumn.addElement(node.getName());
	    }
	    else {
	      rows = positions.length+states.size();
	      for (int i=0; i<states.size(); i++) {
	        leftColumn.addElement(withoutQm((String)states.elementAt(i)));
	      }
	    }
	    // Set the number of rows of the table's header
	    relationModel.setNumRows(rows);
	    relationModel.addColumn("",leftColumn);

	    // Set the columns with its headers
	    NodeList nodes=newRelation.getVariables();
	    Configuration config=new Configuration(nodes);
	    config.remove(0);
	    if (newtotal==0) {
	      newtotal=(int)((PotentialTable) newRelation.getValues()).getSize();
	      if (debug) {
	        System.out.println("newtotal="+newtotal);
	      }
	    }

	    int ncolumns=newtotal/numStatesN;

	    if (debug) {
	      System.out.println("Ncolums="+ncolumns+" numStatesN="+numStatesN);
	    }

	    for (int i=0; i<ncolumns; i++) {
	      relationModel.addColumn("",setColumn(config.getVariables(),config.getValues()));
	      config.nextConfiguration();
	    }

	    tcm = relationTable.getColumnModel();

            for (int i=0; i<columns; i++) {
	      TableColumn column = tcm.getColumn(i+1);
	      column.setCellRenderer(new RowRenderer(false));
	    }

	    statesHasChanged = false;

	    // The header rows cannot be selected
	    for (int i=0; i<positions.length; i++) {
	      relationTable.setCellSelectionEnabled(false);
	    }

	    setRelationTableProperties(newRelation);
          }

	  if (debug) {
            System.out.println("RELATION AL FINAL");
            newRelation.print();
            System.out.println("Size="+(int)((PotentialTable)newRelation.getValues()).getSize());
	  }

        }

	/**
	 * Generates the table of the relation that must appear in the
	 * Dialog, with all its parents and states.
	 */

	/* MODIFYING */

	public void generateCanonicalTable (Relation relation) {
	   Vector leftColumn = new Vector();
	   int index = 1;

	   // Get the last value modified
	   valuesTable.editingStopped(new ChangeEvent(this));

	   if (editVarTabbedPane.getSelectedIndex()==3 && statesHasChanged) {

	      relationTableChanged = true;

	      // Inicializes the probability table
	      states = new Vector();

	      if (valuesTable.getRowCount()<2) {
	           ShowMessages.showMessageDialog("Not enough states",
	               JOptionPane.ERROR_MESSAGE);
	           return;
	      }

	      if (this.allRadioButton.isSelected()) {
		index = 0;
	      }

	      for (int i=0; i<valuesTable.getRowCount()-index; i++) {
	         states.addElement(addQm((String)valuesTable.getValueAt(i, 1)));
	      }

	      clearRelationTable();

	      // Calculate the number of columns that the table
	      // have. Inicializes the variable parents that contains
	      // the parents of a node

	      parents = new Vector();
	      columnsNumber(0,new Vector());

	      leftColumn.addElement("");

	      if (valuesMode) {
		rows = 3;
		leftColumn.addElement("");
		leftColumn.addElement(node.getName());
	      }
	      else {
		rows = states.size()+2;
		leftColumn.addElement(node.getName());
		for (int i=0; i<states.size(); i++) {
		  leftColumn.addElement(withoutQm((String)states.elementAt(i)));
		}
	      }

	      // Set the number of rows of the table
	      relationModel.setNumRows(rows);

	      relationModel.addColumn("",leftColumn);

	      // Set the columns with its headers
	      for (int i=0; i<columns; i++) {
		  relationModel.addColumn("",setCanonicalColumn(parents,i));
	      }

	      if (relation.getKind() != Relation.XOR) {
	        Vector residual = new Vector();
		residual.add(localize(dialogBundle,"EditVariable.Leaky.label"));
	        residual.add("-");
	        relationModel.addColumn("",residual);
	      }

	      tcm = relationTable.getColumnModel();

	      int theColumns;

	      if (nodeRelation.getKind() == Relation.XOR) {
		theColumns = columns-1;
	      }
	      else {
	        theColumns = columns;
	      }

	      for (int i=0; i<=theColumns; i++) {
		  TableColumn column = tcm.getColumn(i+1);
		  column.setCellRenderer(new RowRenderer(false));
	      }

	      statesHasChanged = false;
	      relationTable.setCellSelectionEnabled(false);
	      //relationTable.setRowSelectionAllowed(false);

	      if (index==1) {
		  states.addElement(addQm((String)valuesTable.getValueAt(valuesTable.getRowCount()-1, 1)));
	      }

              if (index==0) {
		lockColumns();
	      }
	      else {
		lockedColumns = false;
	      }

	      setRelationTableProperties(relation);
	    }
        }

	/**
	 * Calculate the number of columns that the table
	 * have. Inicializes the variable parents that contains
	 * the parents of a node
	 *
	 * @param c The inicialize number for the columns variable
	 */

	public void columnsNumber (int c, Vector leftColumn){
	   columns = c;
	   int index = 1;

	   if ((allRadioButton.isSelected()) ||
	       (nodeRelation.getKind() == Relation.GENERALIZED_MAX) ||
	       (nodeRelation.getKind() == Relation.MIN) ||
	       (nodeRelation.getKind() == Relation.XOR)) {
	      index = 0;
	   }

	   Relation relation=this.obtainRelationOfNodeOrForcedPolicyOrGenerateIt();
	   
           NodeList nodes = new NodeList();
           /*if (node.getKindOfNode() != Node.DECISION) {*/
           
              nodes=relation.getVariables().duplicate();
              nodes.removeNode(0);
           /*}
           else {
              LinkList ll=node.getParents();
              for (int i=0; i<ll.size(); i++) {
                nodes.insertNode(((Node) ((Link) ll.elementAt(i)).getTail()).copy());
              }
           }*/
	   //nodes.printNames();

	   for (int i=0; i<nodes.size(); i++) {
	      int cn = relationModel.getColumnCount();
              //MANOLO> Los nodos de utilidad no son FiniteStates
	      //FiniteStates father=(FiniteStates) nodes.elementAt(i);
              Node father= nodes.elementAt(i);

	      /* MODIFIED */
	      //parents = new Vector(); /* ????????? */
              parents.addElement(father);
	      /* END MODIFIED: this is calculated in the constructor... */
	      leftColumn.addElement(father.getNodeString(true));

	      
              
              if (nodeRelation.getKind()==Relation.UTILITY_COMBINATION)
              {
                  columns=0;
              }
              else
              {
                  if (c==0)
                     columns = columns+((FiniteStates)father).getStates().size()-index;
                  else
                     columns = columns*((FiniteStates)father).getStates().size();
              }
	   }
	}

	/**
	 * Do some important actions in the relation table:
	 * <LI>Lock the left-hand column creating a header table that
	 * contains this column
	 * <LI>Set characteristics about the selection
	 * <LI>Fill the table with the values of the relation.
	 * <LI>Set the listeners
	 */

	public void setRelationTableProperties(Relation r) {

	   firstColumn = tcm.getColumn(0);

	   headerTable.getTableHeader().setReorderingAllowed(false);
	   headerTable.setPreferredScrollableViewportSize(
	         new Dimension (
	            firstColumn.getWidth()+
	            headerTable.getColumnModel().getColumnMargin(),
	            0));

	   tcm.removeColumn(firstColumn);
	   relationScrollPane.setRowHeaderView(headerTable);
	   relationScrollPane.setCorner(JScrollPane.UPPER_LEFT_CORNER,
	                                 headerTable.getTableHeader());
	   TableColumn tc = headerTable.getColumnModel().getColumn(0);
	   tc.setCellRenderer(new RowRenderer(true));

	   relationTable.setRowSelectionAllowed(false);
	   relationTable.setColumnSelectionAllowed(false);

         //Modificado por jruiz
	   if ((node.getKindOfNode() == Node.UTILITY) || (r.getValues().getClass() == PotentialTable.class) ||
             (r.getValues().getClass() == GeneralizedPotentialTable.class)) {
	    general = true;
	   }//Fin modificado por jruiz

	   else {
	    general = false;
	   }

	   if (!valuesMode) {
	      fillValues(r);
	   }

	   relationTable.revalidate();

	   relationTable.getModel().addTableModelListener(
            new RelationTableListener());

	   relationTable.getSelectionModel().addListSelectionListener(
            new RelationSelectionListener());
        }

	/**
	 * Gets the headers of the column using the information given
	 * in the parents Vector and its values
	 *
	 * @return A Vector with the headers that will be used to create
	 * the new column
	 */

	private Vector setColumn (Vector parents, Vector numstates) {

	   Vector column = new Vector();

	   for (int i=0; i<parents.size(); i++) {
	      column.addElement(withoutQm((String)((FiniteStates)parents.elementAt(i)).getState(((Integer)numstates.elementAt(i)).intValue())));
	   }
	   return column;
	}

	private Vector setCanonicalColumn (Vector parents, int i) {
	   Vector column = new Vector();
	   boolean exit = false;
	   int numStates = 0, j = 0, index = 1;
	   if ((allRadioButton.isSelected()) ||
		(nodeRelation.getKind() == Relation.GENERALIZED_MAX) ||
		(nodeRelation.getKind() == Relation.MIN) ||
		(nodeRelation.getKind() == Relation.XOR)) {
	      index = 0;
	   }

	   while ((!exit) && (j<parents.size())) {
	      FiniteStates n = (FiniteStates) parents.elementAt(j);
	      if (i<numStates + n.getNumStates()-index) {
	         column.add(n.getName());
	         column.add(withoutQm((String)n.getState(i-numStates)));
	         exit = true;
	      }
	      else {
	         numStates = numStates + n.getNumStates()-index;
	         j++;
	      }
	   }
	   return column;
	}

	/**
	 * Used to generate the next positions array.
	 *
	 * @param parents Used to get the number of states of every parent.
	 * This will be useful to generate the next positions order.
	 * @param positions Contains the positions of the states that
	 * will be the headers of the next column in the relationTable
	 */

	private void recalculatePositions (Vector parents, int positions[], boolean inverted) {
	   boolean exit = false;
	   int i;
	   if (inverted)
	      i=parents.size()-1;
	   else
	      i=0;
	   while (!exit) {
	      FiniteStates father = (FiniteStates) parents.elementAt(i);
	      if (positions[i]+1 == father.getStates().size()) {
	         positions[i]=0;
	         if (inverted)
	            i--;
	         else
	            i++;
	      }
	      else {
	         positions[i]=positions[i]+1;
	         exit = true;
	      }
	   }
	}

	private void recalculatePositions (Vector parents, int positions[]) {
	   recalculatePositions(parents, positions, false);
	}

	/**
	 * Clear the relationTable. This must be done before the
	 * generation of a new Relation Table
	 */

	private void clearRelationTable() {
	   relationModel = new NodeTableModel();

	   relationTable = new JTable(relationModel);
		relationTable.setAutoResizeMode(javax.swing.JTable.AUTO_RESIZE_OFF);
	   relationScrollPane.getViewport().add(relationTable);
		relationTable.setBounds(0,0,347,253);

	   headerTable = new JTable(relationModel);
	   headerTable.setAutoResizeMode(JTable.AUTO_RESIZE_OFF);
	   headerTable.setAutoscrolls(false);
	}

	/**
	 * Fill the relation table with the values contained in
	 * the Relation whose first node is the node that is
	 * been editing
	 */

	/* MODIFYING... */

	private void fillValues (Relation relation) {
	   int tableColumns, tableRows, headerRows, valuesColumns;
	   int numStates;
	   if (node.getKindOfNode() != Node.UTILITY) {
	      numStates = ((FiniteStates) node).getNumStates();
	   }
	   else {
	      numStates = 1;
	   }

	   /* Create a new Relation with the names of the node and
	      its parents to localize this relation in the relationList */

	   Node n = new FiniteStates();
	   n.setName(node.getName());

	   //parents.add(n); /* MODIFIED */
	   PotentialTable pt;

  	   if (general) {
	      tableColumns = columns;
	      valuesColumns = columns;
	      tableRows = states.size();
	      //headerRows = numStates; /* Wrong */
	      headerRows = parents.size();
	      pt = (PotentialTable) relation.getValues();
	      /** REMOVED COMMENT: why this was commented? **/ /* COMMENTED AGAIN */
	      // relation.setKind(Relation.POTENTIAL);
	   }
	   else {
	      pt = new PotentialTable();
	      pt = getCanonicalValues(relation);

	      tableRows = states.size()-1;
	      valuesColumns = (int) pt.getSize()/tableRows;

	      if (relation.getKind() == Relation.XOR) { /* TO MODIFY */
		tableColumns = columns;
	      }
	      else {
	        tableColumns = columns + 1;
	      }

	      headerRows = 2;
	   }

	   if (node.getKindOfNode()==Node.UTILITY) {
	      order = new Vector();
	      order.addElement(new Integer(1));
	   }

	   if (general) {
	      for (int i=0; i<tableRows; i++) {
		double columnProbability = 0.0;
                double valuePot;
                boolean isUtilityWithoutDecimals;
		for (int j=0; j<tableColumns; j++) {
		  int position;
		  if (node.getKindOfNode() == Node.UTILITY) {
		    position = j;
		  }
		  else {
		    position = j+i*tableColumns;
		  }
		  int cell = i+headerRows;
                  valuePot=pt.getValue(position);
                  
                  //We print 0 or 123 for example when the value of the potential in an utility node is 0.0 or 123.0
                  isUtilityWithoutDecimals=((node.getKindOfNode()==Node.UTILITY)&&(valuePot-Math.floor(valuePot)==0.0));
                  
                  if (isUtilityWithoutDecimals) relationTable.setValueAt(Integer.toString((int)(Math.floor(valuePot))),cell,j);
                  else relationTable.setValueAt(Double.toString(pt.getValue(position)),cell,j);
                  
		  columnProbability = columnProbability+pt.getValue(position);

		  if (lockedColumns) {
                    double lastStateValue = Math.round((1-columnProbability)*100000);
                    lastStateValue = lastStateValue/100000;
                    relationTable.setValueAt(Double.toString(lastStateValue),
                    tableRows+numStates, j);
		  }
		}
	      }

	      return;
	   }

	   /* Da rifare tutto */

	   if (allRadioButton.isSelected()) {
	      for (int i=0; i<tableRows+1; i++) {
		for (int j=0; j<tableColumns; j++) {
		  int cell = i+headerRows;
		  boolean exit = false;
		  int par = 0;
		  int howman = 0;
		  while (!exit) {
		    if (j<(((FiniteStates) parents.elementAt(par)).getNumStates())+howman) {
		      exit = true;
		    }
		    else {
		      howman=howman+((FiniteStates) parents.elementAt(par)).getNumStates();
		      par++;
		      if (par == parents.size()) {
			exit = true;
		      }
		    }
		  }
		  int position = 0;
		  for (int k=0; k<par; k++) {
		    position = position + ((FiniteStates) parents.elementAt(k)).getNumStates()*((FiniteStates) node).getNumStates();
		  }
		  if (par != parents.size()) {
		    position = position + i * ((FiniteStates) parents.elementAt(par)).getNumStates() + j - howman;
		  }
		  else {
		    position = position + i;
		  }
		  relationTable.setValueAt(Double.toString(pt.getValue(position)),cell,j);
		}
	      }
	   }
	   else {

	      /* Da pensarci */
	      if ((relation.getKind() == Relation.GENERALIZED_MAX) ||
		  (relation.getKind() == Relation.MIN) ||
		  (relation.getKind() == Relation.XOR)) {
		for (int i=0; i<tableRows; i++) {
		  for (int j=0; j<tableColumns; j++) {
		    int cell = i + headerRows;
		    boolean exit = false;
		    int par = 0;
		    int howman = 0;
		    while (!exit) {
		      if (j<(((FiniteStates) parents.elementAt(par)).getNumStates())+howman) {
		        exit = true;
		      }
		      else {
		        howman=howman+((FiniteStates) parents.elementAt(par)).getNumStates();
		        par++;
		        if (par == parents.size()) {
			  exit = true;
		        }
		      }
		    }
		    int position = 0;
		    for (int k=0; k<par; k++) {
		      position = position + ((FiniteStates) parents.elementAt(k)).getNumStates()*((FiniteStates) node).getNumStates();
		    }
		    if (par != parents.size()) {
		      position = position + i * ((FiniteStates) parents.elementAt(par)).getNumStates() + j - howman;
		    }
		    else {
		      position = position + i;
		    }

		    relationTable.setValueAt(Double.toString(pt.getValue(position)),cell,j);
		  }
		}
	      }
	      else {
		for (int i=0; i<tableRows; i++) {
		  for (int j=0; j<tableColumns; j++) {
		    int cell = i + headerRows;
		    boolean exit = false;
		    int par = 0;
		    int howman = 0;
		    while (!exit) {
		      if (j<(((FiniteStates) parents.elementAt(par)).getNumStates()-1)+howman) {
			  exit = true;
		      }
		      else {
			howman=howman+((FiniteStates) parents.elementAt(par)).getNumStates()-1;
			par++;
			if (par == parents.size()) {
			  exit = true;
			}
		      }
		    }
		    int position = 0;
		    for (int k=0; k<par; k++) {
		      position = position + ((FiniteStates) parents.elementAt(k)).getNumStates()*((FiniteStates) node).getNumStates();
		    }
		    if (par != parents.size()) {
		      position = position + i * ((FiniteStates) parents.elementAt(par)).getNumStates() + j - howman;
		    }
		    else {
		      position = position + i;
		    }

		    relationTable.setValueAt(Double.toString(pt.getValue(position)),cell,j);
		  }
		}
	      }
	   }
	}

/*	private Relation findRelation() {
	   Vector relations = this.bayesNet.getRelationList();
	   int i = 0;
	   if (parents.size()==0) {
	      for (int j=0; j<node.getParents().size(); j++) {
	         Link l = (Link) node.getParents().elementAt(j);
	         FiniteStates father;

	         if (l.getTail()==node)
	            father = (FiniteStates) l.getHead();
	         else
	            father = (FiniteStates) l.getTail();

	         parents.addElement(father);
	      }
	   }

           if (!parents.contains(node))
	      parents.add(node);

	   Relation relation = new Relation(parents);

	   while (i<relations.size()) {
	      Relation r = (Relation) relations.elementAt(i);
	      if (relation.isTheSame(r))
	         return r;
	      else i++;
	   }
	   parents.remove(node);

	   return null;

	}*/

	/**
	 * Just to get values from canonical relation and return them in a potential table
	 */

	private PotentialTable getCanonicalValues(Relation relation) {

	  int size=0, s=0;
	  PotentialTable pt;

	  pt = new PotentialTable();
	  for (int i=0; i<((CanonicalPotential) relation.getValues()).getArgumentsSize(); i++) {
	    size=size+(int) ((PotentialTable) ((CanonicalPotential) relation.getValues()).getArgumentAt(i)).getSize();
	  }
	  double[] theValues=new double[size];
	  for (int i=0; i<((CanonicalPotential) relation.getValues()).getArgumentsSize(); i++) {
	    if (i==0) {
	      s=0;
	    }
	    else {
	      s=s+(int)((PotentialTable) ((CanonicalPotential) relation.getValues()).getArgumentAt(i-1)).getSize();
	    }
	    for (int j=0; j<(int) ((PotentialTable) ((CanonicalPotential) relation.getValues()).getArgumentAt(i)).getSize(); j++) {
	      theValues[j+s]=((PotentialTable) ((CanonicalPotential) relation.getValues()).getArgumentAt(i)).getValue(j);
	    }
	  }
	  pt.setValues(theValues);

	  return pt;
	}

	/**
	 * <P> Get the values of the Relation from the relationTable. First, to
	 * locate the relation in the relationList of the current Bayes Network,
	 * a new relation is made with the names of current node and its parents
	 * (we only need this to locate in the relation list). </P>
	 * <P> Then, values array is created. This contains the table's values
	 * ordered by columns. After this, the values variable will be set into
	 * the relation located at the begining of the method </P>
	 *
	 * @param relation
	 * @param deterministic this flag is true when the values that will
	 * be got for this method will be used for get the determinitic values
	 * of a relation.
	 */

	private boolean getValues (Relation relation, boolean deterministic) {
	   double columnProbability;
	   int tableColumns, headerRows, validRows = rows;
	   boolean isComplete = true;
	   boolean cptCalculated = false;
	   PotentialTable potCPT=null;

	   // The next variable are related with the deterministic flag and will
	   // be used for knowing if all the values of the relation are zero or one
	   boolean areAllOneOrZero = true;

	   /* Create a new Relation with the names of the node and
	      its parents to localize this relation in the relationList */

	   PotentialTable pt = new PotentialTable();

	   if (general) {
	      tableColumns = columns;
	      //headerRows = node.getParents().size();
	      headerRows = nodeRelation.getVariables().size()-1;

	      // If the All Parameters button is selected when the relation is general
	      // there is one case in which the number of rows not correspond to the
	      // real number that the table must have. In this case this number is
	      // recalculated

	      if (node.getKindOfNode() == Node.UTILITY) {
		rows = headerRows+1;
	      }
	      else {
	        if (rows-headerRows!=valuesTable.getRowCount())  {
	          rows = valuesTable.getRowCount()+headerRows;
	        }
	      }

	      //System.out.println("validRows "+validRows+" rows "+rows);

	   }
	   else {
	      tableColumns = columns;
	      relation.setKind(getKindFromTypeRelationButton());
	      if ((relation.getValues() != null) &&
		  (relation.getValues().getClass() == CanonicalPotential.class)) {
		if (((CanonicalPotential) relation.getValues()).isCPTcalculated()) {
		  cptCalculated = true;
		  potCPT = ((CanonicalPotential) relation.getValues()).getCPT();
		}
		else {
		  cptCalculated = false;
		}
	      }

	      String theHenrionVSDiez = "Diez";

	      if (((CanonicalPotential) nodeRelation.getValues()).getFunction().getName().equals("Or") ||
		  ((CanonicalPotential) nodeRelation.getValues()).getFunction().getName().equals("CausalMax")) {
	        theHenrionVSDiez = ((CanonicalPotential) nodeRelation.getValues()).isHenrionVSDiez();;
	      }
	      /*Vector vars = new Vector();
	      vars.addElement(node);
	      for (int i=0; i<parents.size(); i++) {
	        vars.addElement(parents.elementAt(i));
	      }
	      NodeList nl = new NodeList();
	      nl.setNodes(vars);*/
	      //relation.setVariables(nl);

	      relation.setVariables(nodeRelation.getVariables());

	      switch (relation.getKind()) {
	        case Relation.OR:
		  tableColumns = columns+1;
	          relation.setValues(new CanonicalPotential(nodeRelation.getValues().getVariables()));
		  ((CanonicalPotential) relation.getValues()).setFunction("Or");
	          createRelationStructure(relation, "Or", false);
		  break;
		case Relation.CAUSAL_MAX:
		  tableColumns = columns+1;
		  relation.setValues(new CanonicalPotential(nodeRelation.getValues().getVariables()));
		  ((CanonicalPotential) relation.getValues()).setFunction("CausalMax");
	          createRelationStructure(relation, "CausalMax", false);
		  break;
		case Relation.GENERALIZED_MAX:
		  tableColumns = columns+1;
		  relation.setValues(new CanonicalPotential(nodeRelation.getValues().getVariables()));
		  ((CanonicalPotential) relation.getValues()).setFunction("GeneralizedMax");
	          createRelationStructure(relation, "GeneralizedMax", false);
		  break;
		case Relation.AND:
		  tableColumns = columns+1;
		  relation.setValues(new CanonicalPotential(nodeRelation.getValues().getVariables()));
		  ((CanonicalPotential) relation.getValues()).setFunction("And");
	          createRelationStructure(relation, "And", false);
		  break;
		case Relation.MIN:
		  tableColumns = columns+1;
		  relation.setValues(new CanonicalPotential(nodeRelation.getValues().getVariables()));
		  ((CanonicalPotential) relation.getValues()).setFunction("Min");
	          createRelationStructure(relation, "Min", false);
		  break;
		case Relation.XOR:
		  tableColumns = columns;
		  relation.setValues(new CanonicalPotential(nodeRelation.getValues().getVariables()));
		  ((CanonicalPotential) relation.getValues()).setFunction("Xor");
	          createRelationStructure(relation, "Xor", false);
		  break;
	      }

	      if (((CanonicalPotential) nodeRelation.getValues()).getFunction().getName().equals("Or") ||
		  ((CanonicalPotential) nodeRelation.getValues()).getFunction().getName().equals("CausalMax")) {
	        ((CanonicalPotential) relation.getValues()).setHenrionVSDiez(theHenrionVSDiez);
	        optionsDisabled = true;
	        if (theHenrionVSDiez.equals("Henrion")) {
		  henrionRadioButton.setSelected(true);
	        }
	        else {
		  diezRadioButton.setSelected(false);
	        }
	        optionsDisabled = false;
	      }

	      if (cptCalculated) {
		((CanonicalPotential) relation.getValues()).setCPT(potCPT);
	      }

	      enableRelationOptions();
	      headerRows = 2;
	   }

	   double values[] = new double[tableColumns*(rows-headerRows)];

	   //System.out.println("Values size "+tableColumns*(rows-headerRows));

	   int j=0, position, total=0, par=0;

	   if (debug) {
	    System.out.println("headerrows "+headerRows+" validRows "+validRows);
	    System.out.println("tableColumns "+tableColumns);
	   }

	   while (j<tableColumns) {
	      columnProbability = 0.0;

	      if (!general) {
		if (validRows-headerRows!=valuesTable.getRowCount()) {
		  if ((relation.getKind() == Relation.GENERALIZED_MAX) ||
		      (relation.getKind() == Relation.MIN) ||
		      (relation.getKind() == Relation.XOR)) {
		    if (j == (total/(((FiniteStates) node).getNumStates()-1) + ((FiniteStates) parents.elementAt(par)).getNumStates())) {
		      total = total + ((FiniteStates) parents.elementAt(par)).getNumStates()*(((FiniteStates) node).getNumStates()-1);
		      par++;
	            }
		  }
		  else {
		    if (j == (total/(((FiniteStates) node).getNumStates()-1) + ((FiniteStates) parents.elementAt(par)).getNumStates()-1)) {
		      total = total + (((FiniteStates) parents.elementAt(par)).getNumStates()-1)*(((FiniteStates) node).getNumStates()-1);
		      par++;
		    }
		  }
		}
		else {
	          if (j == (total/((FiniteStates) node).getNumStates() + ((FiniteStates) parents.elementAt(par)).getNumStates())) {
		    total = total + ((FiniteStates) parents.elementAt(par)).getNumStates()*((FiniteStates) node).getNumStates();
		    par++;
	          }
		}
	      }

	      for (int i=headerRows; i<validRows;i++) {

		if (!general) {
		  /* In this case, the table may be reduced and it will be filled in other method */
		  //position = (i-headerRows)*tableColumns+j; /* TO CHANGE */
		  if (validRows-headerRows!=valuesTable.getRowCount()) {
		    if ((relation.getKind() == Relation.GENERALIZED_MAX) ||
		        (relation.getKind() == Relation.MIN) ||
			(relation.getKind() == Relation.XOR)) {
		      if (par == parents.size()) {
			position = total + (i-headerRows) + j - total/(((FiniteStates) node).getNumStates()-1);
		      }
		      else {
			position = total + (i-headerRows)*((FiniteStates) parents.elementAt(par)).getNumStates() + j - total/(((FiniteStates) node).getNumStates()-1);
		      }
		    }
		    else {
		      if (par == parents.size()) {
			position = total + (i-headerRows) + j - total/(((FiniteStates) node).getNumStates()-1);
		      }
		      else {
			position = total + (i-headerRows)*(((FiniteStates) parents.elementAt(par)).getNumStates()-1) + j - total/(((FiniteStates) node).getNumStates()-1);
		      }
		    }
		  }
		  else {
		    if (par == parents.size()) {
		      position = total + (i-headerRows) + j - total/((FiniteStates) node).getNumStates();
		    }
		    else {
		      position = total + (i-headerRows)*((FiniteStates) parents.elementAt(par)).getNumStates() + j - total/((FiniteStates) node).getNumStates();
		    }
		  }
		}
		else {
		  /* In this case, the table is complete and filled in this section of code */
		  position = (i-headerRows)*tableColumns+j;
		}

		//System.out.println("Position "+position);

		Double d = new Double(0.0);
		if (relationTable.getValueAt(i,j)!=null) {
		  String stmp = (String)relationTable.getValueAt(i, j);
		  d = Double.valueOf(stmp);
		  values[position] = d.doubleValue();
		  if ((values[position]!=1) && (values[position]!=0))
		    areAllOneOrZero = false;
		}
		else {
		  values[position] = 0.0;
		}

		columnProbability += d.doubleValue();
	      }

	      if (/*(node.getKindOfNode() != Node.DECISION) && */(node.getKindOfNode()!= Node.UTILITY) && (general)) {
	         if (validRows-headerRows!=valuesTable.getRowCount()) {
		    position = (validRows-headerRows)*tableColumns+j;
	            double roundedValue = Math.round((1-columnProbability)*100000);
	            values[position] = roundedValue/100000;
	            columnProbability = 1.0;
	         }

	         if ((columnProbability > 1.0) || (columnProbability < 0.999999)) {
	            ShowMessages.showMessageDialog(ShowMessages.PROB_NOT_ONE,
	                  JOptionPane.ERROR_MESSAGE);
	            return false;
	         }
	      }
	      j++;
	   }

	   if (debug) {
	      System.out.println("The values as read");
	      for (int i=0; i<tableColumns*(rows-headerRows); i++) {
		System.out.println("Value: "+values[i]);
	      }
	   }

	   if (validRows-headerRows!=valuesTable.getRowCount()) {
	      isComplete = false;
	   }
	   else {
	      isComplete = true;
	   }

	   if (pt==null) {
	      pt = new PotentialTable();
	      System.out.println("pt was null in getValues(...)!!!!!!");
	   }

	   if (general){
	      pt.setVariables((Vector) nodeRelation.getValues().getVariables());
	      pt.setValues(values);
	      
	   }

 	   if (!general) {
	      setCanonicalValues(relation, values, isComplete);
	      if ((cptCalculated) && (theTableChanged)) {
	        ((CanonicalPotential) relation.getValues()).updateCPT();
	      }
 	   }
	   else {
	      relation.setValues(pt);
	      relation.setVariables(nodeRelation.getVariables());
	   }

	   if (deterministic)
	      return areAllOneOrZero;

	   return true;
	}


	/**
	 * In case of a canonical model, sets the relations's values starting from
	 * a potential table
	 */

	private void setCanonicalValues (Relation relation, double[] values, boolean completeTable) {
	  if (completeTable) {
	    /* To review condition */
	    int total = 0;
	    for (int i=0; i<parents.size(); i++) {
	      for (int j=0; j<((FiniteStates) parents.elementAt(i)).getNumStates(); j++) {
		for (int k=0; k<((FiniteStates) node).getNumStates(); k++) {
		  ((PotentialTable) ((CanonicalPotential) relation.getValues()).getArgumentAt(i)).setValue(k*((FiniteStates) parents.elementAt(i)).getNumStates()+j,values[k*((FiniteStates) parents.elementAt(i)).getNumStates()+j+total]);
		}
	      }

      	      total = total + ((FiniteStates) node).getNumStates()*((FiniteStates) parents.elementAt(i)).getNumStates();

	      /* To update Relation, not only argument in CanonicalPotential */
	      Vector v=bayesNet.getRelationList();
	      RelationList rl = new RelationList();
	      rl.setRelations(v);
	      rl.getRelation(((CanonicalPotential) relation.getValues()).getStrArgument(i)).setValues((PotentialTable) ((CanonicalPotential) relation.getValues()).getArgumentAt(i));

	      //((PotentialTable) ((CanonicalPotential) relation.getValues()).getArgumentAt(i)).print();
	    }

	    if (!((CanonicalPotential) relation.getValues()).getFunction().getName().equals("Xor")) {
	      for (int i=0; i<((FiniteStates) node).getNumStates(); i++) {
		((PotentialTable) ((CanonicalPotential) relation.getValues()).getArgumentAt(parents.size())).setValue(i,values[total+i]);
	      }

	      /* To update Relation, not only argument in CanonicalPotential */
	      Vector v=bayesNet.getRelationList();
	      RelationList rl = new RelationList();
	      rl.setRelations(v);
	      rl.getRelation(((CanonicalPotential) relation.getValues()).getStrArgument(parents.size())).setValues((PotentialTable) ((CanonicalPotential) relation.getValues()).getArgumentAt(parents.size()));

	      //((PotentialTable) ((CanonicalPotential) relation.getValues()).getArgumentAt(parents.size())).print();
	    }
	  }
	  else {
	    /* OR kind */
	    if (((CanonicalPotential) relation.getValues()).getFunction().getName().equals("Or")) {
	      /* Da pensarci */
	      int total = 0;
	      for (int i=0; i<parents.size(); i++) {
		for (int j=0; j<((FiniteStates) parents.elementAt(i)).getNumStates()-1; j++) {
		  double columnProbability = 0.0;
		  for (int k=0; k<((FiniteStates) node).getNumStates()-1; k++) {
		    ((PotentialTable) ((CanonicalPotential) relation.getValues()).getArgumentAt(i)).setValue(j+k*((FiniteStates) parents.elementAt(i)).getNumStates(),values[j+k*(((FiniteStates) parents.elementAt(i)).getNumStates()-1)+total]);
		    columnProbability = columnProbability+values[j+k*(((FiniteStates) parents.elementAt(i)).getNumStates()-1)+total];
		  }
		  double lastStateValue = Math.round((1-columnProbability)*100000);
		  lastStateValue = lastStateValue/100000;
		  ((PotentialTable) ((CanonicalPotential) relation.getValues()).getArgumentAt(i)).setValue(j+((FiniteStates) parents.elementAt(i)).getNumStates()*(((FiniteStates) node).getNumStates()-1),lastStateValue);
		}
		for (int l=0; l<((FiniteStates) node).getNumStates()-1; l++) {
		  ((PotentialTable) ((CanonicalPotential) relation.getValues()).getArgumentAt(i)).setValue(((FiniteStates) parents.elementAt(i)).getNumStates()-1+l*((FiniteStates) parents.elementAt(i)).getNumStates(),0.0);
		}
		((PotentialTable) ((CanonicalPotential) relation.getValues()).getArgumentAt(i)).setValue(((FiniteStates) parents.elementAt(i)).getNumStates()-1+(((FiniteStates) parents.elementAt(i)).getNumStates()-1)*((FiniteStates) node).getNumStates(),1.0);
		total = total+(((FiniteStates) node).getNumStates()-1)*(((FiniteStates) parents.elementAt(i)).getNumStates()-1);

		/* To update Relation, not only argument in CanonicalPotential */
	        Vector v=bayesNet.getRelationList();
	        RelationList rl = new RelationList();
	        rl.setRelations(v);
	        rl.getRelation(((CanonicalPotential) relation.getValues()).getStrArgument(i)).setValues((PotentialTable) ((CanonicalPotential) relation.getValues()).getArgumentAt(i));
	      }
	      double columnProbability = 0.0;
	      for (int i=0; i<((FiniteStates) node).getNumStates()-1; i++) {
	        ((PotentialTable) ((CanonicalPotential) relation.getValues()).getArgumentAt(parents.size())).setValue(i,values[total+i]);
	        columnProbability = columnProbability+values[total+i];
	      }
	      double lastStateValue = Math.round((1-columnProbability)*100000);
	      lastStateValue = lastStateValue/100000;
	      ((PotentialTable) ((CanonicalPotential) relation.getValues()).getArgumentAt(parents.size())).setValue(((FiniteStates) node).getNumStates()-1,lastStateValue);

      	      /* To update Relation, not only argument in CanonicalPotential */
	      Vector v=bayesNet.getRelationList();
	      RelationList rl = new RelationList();
	      rl.setRelations(v);
	      rl.getRelation(((CanonicalPotential) relation.getValues()).getStrArgument(parents.size())).setValues((PotentialTable) ((CanonicalPotential) relation.getValues()).getArgumentAt(parents.size()));
	    }
	    /* END OR kind */
	    /* CAUSAL MAX kind */
	    else if (((CanonicalPotential) relation.getValues()).getFunction().getName().equals("CausalMax")) {
	      /* Da pensarci */
	      int total = 0;
	      for (int i=0; i<parents.size(); i++) {
		for (int j=0; j<((FiniteStates) parents.elementAt(i)).getNumStates()-1; j++) {
		  double columnProbability = 0.0;
		  for (int k=0; k<((FiniteStates) node).getNumStates()-1; k++) {
		    ((PotentialTable) ((CanonicalPotential) relation.getValues()).getArgumentAt(i)).setValue(j+k*((FiniteStates) parents.elementAt(i)).getNumStates(),values[j+k*(((FiniteStates) parents.elementAt(i)).getNumStates()-1)+total]);
		    columnProbability = columnProbability+values[j+k*(((FiniteStates) parents.elementAt(i)).getNumStates()-1)+total];
		  }
		  double lastStateValue = Math.round((1-columnProbability)*100000);
		  lastStateValue = lastStateValue/100000;
		  ((PotentialTable) ((CanonicalPotential) relation.getValues()).getArgumentAt(i)).setValue(j+((FiniteStates) parents.elementAt(i)).getNumStates()*(((FiniteStates) node).getNumStates()-1),lastStateValue);
		}
		for (int l=0; l<((FiniteStates) node).getNumStates()-1; l++) {
		  ((PotentialTable) ((CanonicalPotential) relation.getValues()).getArgumentAt(i)).setValue(l*((FiniteStates) parents.elementAt(i)).getNumStates()+((FiniteStates) parents.elementAt(i)).getNumStates()-1,0.0);
		}
		((PotentialTable) ((CanonicalPotential) relation.getValues()).getArgumentAt(i)).setValue(((FiniteStates) parents.elementAt(i)).getNumStates()*((FiniteStates) node).getNumStates()-1,1.0);
		total = total+(((FiniteStates) node).getNumStates()-1)*(((FiniteStates) parents.elementAt(i)).getNumStates()-1);

		/* To update Relation, not only argument in CanonicalPotential */
	        Vector v=bayesNet.getRelationList();
	        RelationList rl = new RelationList();
	        rl.setRelations(v);
	        rl.getRelation(((CanonicalPotential) relation.getValues()).getStrArgument(i)).setValues((PotentialTable) ((CanonicalPotential) relation.getValues()).getArgumentAt(i));
	      }
	      double columnProbability = 0.0;
	      for (int i=0; i<((FiniteStates) node).getNumStates()-1; i++) {
	        ((PotentialTable) ((CanonicalPotential) relation.getValues()).getArgumentAt(parents.size())).setValue(i,values[total+i]);
	        columnProbability = columnProbability+values[total+i];
	      }
	      double lastStateValue = Math.round((1-columnProbability)*100000);
	      lastStateValue = lastStateValue/100000;
	      ((PotentialTable) ((CanonicalPotential) relation.getValues()).getArgumentAt(parents.size())).setValue(((FiniteStates) node).getNumStates()-1,lastStateValue);

      	      /* To update Relation, not only argument in CanonicalPotential */
	      Vector v=bayesNet.getRelationList();
	      RelationList rl = new RelationList();
	      rl.setRelations(v);
	      rl.getRelation(((CanonicalPotential) relation.getValues()).getStrArgument(parents.size())).setValues((PotentialTable) ((CanonicalPotential) relation.getValues()).getArgumentAt(parents.size()));
	    }
	    /* END CAUSAL MAX kind */
	    /* GENERALIZED MAX kind */
	    else if (((CanonicalPotential) relation.getValues()).getFunction().getName().equals("GeneralizedMax")) {
	      /* Da pensarci: this kind requires an editable last column... */
	      int total = 0;
	      for (int i=0; i<parents.size(); i++) {
		for (int j=0; j<((FiniteStates) parents.elementAt(i)).getNumStates(); j++) {
		  double columnProbability = 0.0;
		  for (int k=0; k<((FiniteStates) node).getNumStates()-1; k++) {
		    ((PotentialTable) ((CanonicalPotential) relation.getValues()).getArgumentAt(i)).setValue(j+k*((FiniteStates) parents.elementAt(i)).getNumStates(),values[j+k*((FiniteStates) parents.elementAt(i)).getNumStates()+total]);
		    columnProbability = columnProbability+values[j+k*((FiniteStates) parents.elementAt(i)).getNumStates()+total];
		  }
		  double lastStateValue = Math.round((1-columnProbability)*100000);
		  lastStateValue = lastStateValue/100000;
		  ((PotentialTable) ((CanonicalPotential) relation.getValues()).getArgumentAt(i)).setValue(j+((FiniteStates) parents.elementAt(i)).getNumStates()*(((FiniteStates) node).getNumStates()-1),lastStateValue);
		}

		total = total+(((FiniteStates) node).getNumStates()-1)*(((FiniteStates) parents.elementAt(i)).getNumStates());

		/* To update Relation, not only argument in CanonicalPotential */
	        Vector v=bayesNet.getRelationList();
	        RelationList rl = new RelationList();
	        rl.setRelations(v);
	        rl.getRelation(((CanonicalPotential) relation.getValues()).getStrArgument(i)).setValues((PotentialTable) ((CanonicalPotential) relation.getValues()).getArgumentAt(i));
	      }
	      double columnProbability = 0.0;
	      for (int i=0; i<((FiniteStates) node).getNumStates()-1; i++) {
	        ((PotentialTable) ((CanonicalPotential) relation.getValues()).getArgumentAt(parents.size())).setValue(i,values[total+i]);
	        columnProbability = columnProbability+values[total+i];
	      }
	      double lastStateValue = Math.round((1-columnProbability)*100000);
	      lastStateValue = lastStateValue/100000;
	      ((PotentialTable) ((CanonicalPotential) relation.getValues()).getArgumentAt(parents.size())).setValue(((FiniteStates) node).getNumStates()-1,lastStateValue);

      	      /* To update Relation, not only argument in CanonicalPotential */
	      Vector v=bayesNet.getRelationList();
	      RelationList rl = new RelationList();
	      rl.setRelations(v);
	      rl.getRelation(((CanonicalPotential) relation.getValues()).getStrArgument(parents.size())).setValues((PotentialTable) ((CanonicalPotential) relation.getValues()).getArgumentAt(parents.size()));
	    }
	    /* END GENERALIZED MAX kind*/
	    /* AND kind */
	    else if (((CanonicalPotential) relation.getValues()).getFunction().getName().equals("And")) {
	      /* Da pensarci */
	      int total = 0;
	      for (int i=0; i<parents.size(); i++) {
		for (int j=0; j<((FiniteStates) parents.elementAt(i)).getNumStates()-1; j++) {
		  double columnProbability = 0.0;
		  for (int k=0; k<((FiniteStates) node).getNumStates()-1; k++) {
		    ((PotentialTable) ((CanonicalPotential) relation.getValues()).getArgumentAt(i)).setValue(j+k*((FiniteStates) parents.elementAt(i)).getNumStates(),values[j+k*(((FiniteStates) parents.elementAt(i)).getNumStates()-1)+total]);
		    columnProbability = columnProbability+values[j+k*(((FiniteStates) parents.elementAt(i)).getNumStates()-1)+total];
		  }
		  double lastStateValue = Math.round((1-columnProbability)*100000);
		  lastStateValue = lastStateValue/100000;
		  ((PotentialTable) ((CanonicalPotential) relation.getValues()).getArgumentAt(i)).setValue(j+((FiniteStates) parents.elementAt(i)).getNumStates()*(((FiniteStates) node).getNumStates()-1),lastStateValue);
		}
		for (int l=0; l<((FiniteStates) node).getNumStates()-1; l++) {
		  ((PotentialTable) ((CanonicalPotential) relation.getValues()).getArgumentAt(i)).setValue(l*((FiniteStates) parents.elementAt(i)).getNumStates()+((FiniteStates) parents.elementAt(i)).getNumStates()-1,0.0);
		}
		((PotentialTable) ((CanonicalPotential) relation.getValues()).getArgumentAt(i)).setValue(((FiniteStates) parents.elementAt(i)).getNumStates()*((FiniteStates) node).getNumStates()-1,1.0);
		total = total+(((FiniteStates) node).getNumStates()-1)*(((FiniteStates) parents.elementAt(i)).getNumStates()-1);

		/* To update Relation, not only argument in CanonicalPotential */
	        Vector v=bayesNet.getRelationList();
	        RelationList rl = new RelationList();
	        rl.setRelations(v);
	        rl.getRelation(((CanonicalPotential) relation.getValues()).getStrArgument(i)).setValues((PotentialTable) ((CanonicalPotential) relation.getValues()).getArgumentAt(i));
	      }
	      double columnProbability = 0.0;
	      for (int i=0; i<((FiniteStates) node).getNumStates()-1; i++) {
	        ((PotentialTable) ((CanonicalPotential) relation.getValues()).getArgumentAt(parents.size())).setValue(i,values[total+i]);
	        columnProbability = columnProbability+values[total+i];
	      }
	      double lastStateValue = Math.round((1-columnProbability)*100000);
	      lastStateValue = lastStateValue/100000;
	      ((PotentialTable) ((CanonicalPotential) relation.getValues()).getArgumentAt(parents.size())).setValue(((FiniteStates) node).getNumStates()-1,lastStateValue);

      	      /* To update Relation, not only argument in CanonicalPotential */
	      Vector v=bayesNet.getRelationList();
	      RelationList rl = new RelationList();
	      rl.setRelations(v);
	      rl.getRelation(((CanonicalPotential) relation.getValues()).getStrArgument(parents.size())).setValues((PotentialTable) ((CanonicalPotential) relation.getValues()).getArgumentAt(parents.size()));
	    }
	    /* END AND kind */
	    /* MIN kind */
	    else if (((CanonicalPotential) relation.getValues()).getFunction().getName().equals("Min")) {
	      /* Da pensarci: this kind requires an editable last column... */
	      int total = 0;
	      for (int i=0; i<parents.size(); i++) {
		for (int j=0; j<((FiniteStates) parents.elementAt(i)).getNumStates(); j++) {
		  double columnProbability = 0.0;
		  for (int k=0; k<((FiniteStates) node).getNumStates()-1; k++) {
		    ((PotentialTable) ((CanonicalPotential) relation.getValues()).getArgumentAt(i)).setValue(j+k*((FiniteStates) parents.elementAt(i)).getNumStates(),values[j+k*((FiniteStates) parents.elementAt(i)).getNumStates()+total]);
		    columnProbability = columnProbability+values[j+k*((FiniteStates) parents.elementAt(i)).getNumStates()+total];
		  }
		  double lastStateValue = Math.round((1-columnProbability)*100000);
		  lastStateValue = lastStateValue/100000;
		  ((PotentialTable) ((CanonicalPotential) relation.getValues()).getArgumentAt(i)).setValue(j+((FiniteStates) parents.elementAt(i)).getNumStates()*(((FiniteStates) node).getNumStates()-1),lastStateValue);
		}

		total = total+(((FiniteStates) node).getNumStates()-1)*(((FiniteStates) parents.elementAt(i)).getNumStates());

		/* To update Relation, not only argument in CanonicalPotential */
	        Vector v=bayesNet.getRelationList();
	        RelationList rl = new RelationList();
	        rl.setRelations(v);
	        rl.getRelation(((CanonicalPotential) relation.getValues()).getStrArgument(i)).setValues((PotentialTable) ((CanonicalPotential) relation.getValues()).getArgumentAt(i));
	      }
	      double columnProbability = 0.0;
	      for (int i=0; i<((FiniteStates) node).getNumStates()-1; i++) {
	        ((PotentialTable) ((CanonicalPotential) relation.getValues()).getArgumentAt(parents.size())).setValue(i,values[total+i]);
	        columnProbability = columnProbability+values[total+i];
	      }
	      double lastStateValue = Math.round((1-columnProbability)*100000);
	      lastStateValue = lastStateValue/100000;
	      ((PotentialTable) ((CanonicalPotential) relation.getValues()).getArgumentAt(parents.size())).setValue(((FiniteStates) node).getNumStates()-1,lastStateValue);

      	      /* To update Relation, not only argument in CanonicalPotential */
	      Vector v=bayesNet.getRelationList();
	      RelationList rl = new RelationList();
	      rl.setRelations(v);
	      rl.getRelation(((CanonicalPotential) relation.getValues()).getStrArgument(parents.size())).setValues((PotentialTable) ((CanonicalPotential) relation.getValues()).getArgumentAt(parents.size()));
	    }
	    /* END MIN kind */
	    /* XOR kind */
	    else if (((CanonicalPotential) relation.getValues()).getFunction().getName().equals("Xor")) {
	      /* Da pensarci: this is xor kind*/
	      int total = 0;
	      for (int i=0; i<parents.size(); i++) {
		for (int j=0; j<((FiniteStates) parents.elementAt(i)).getNumStates(); j++) {
		  double columnProbability = 0.0;
		  for (int k=0; k<((FiniteStates) node).getNumStates()-1; k++) {
		    ((PotentialTable) ((CanonicalPotential) relation.getValues()).getArgumentAt(i)).setValue(j+k*((FiniteStates) parents.elementAt(i)).getNumStates(),values[j+k*((FiniteStates) parents.elementAt(i)).getNumStates()+total]);
		    columnProbability = columnProbability+values[j+k*((FiniteStates) parents.elementAt(i)).getNumStates()+total];
		  }
		  double lastStateValue = Math.round((1-columnProbability)*100000);
		  lastStateValue = lastStateValue/100000;
		  ((PotentialTable) ((CanonicalPotential) relation.getValues()).getArgumentAt(i)).setValue(j+((FiniteStates) parents.elementAt(i)).getNumStates()*(((FiniteStates) node).getNumStates()-1),lastStateValue);
		}

		total = total+(((FiniteStates) node).getNumStates()-1)*(((FiniteStates) parents.elementAt(i)).getNumStates());

		/* To update Relation, not only argument in CanonicalPotential */
	        Vector v=bayesNet.getRelationList();
	        RelationList rl = new RelationList();
	        rl.setRelations(v);
	        rl.getRelation(((CanonicalPotential) relation.getValues()).getStrArgument(i)).setValues((PotentialTable) ((CanonicalPotential) relation.getValues()).getArgumentAt(i));
	      }
	    }
	    /* END XOR kind */
	  }
	}


	/**
	 * This method sets the PotentialTable of the relations where the
	 * the node actually edited is included. The PotentialTable will
	 * be set to 1/num_states to all its cells.
	 *
	 * @param actual if it is true the actual relation that is been
	 * edited must be reorganize too.
	 */

	public void reorganizeChildren (boolean actual) {
	   Vector relations = this.bayesNet.getRelationList();

	   int i = 0, total = 1, st = 1;
	   while (i<relations.size()) {
	      Relation r = (Relation) relations.elementAt(i);
	      if (!nodeRelation.isTheSame(r) && newOrder) {
	         if (r.getVariables().getId(node)>0) {
		   total=(int)FiniteStates.getSize(r.getValues().getVariables());
	           double values[] = new double[total];
	         
		   int theIndex=0;
		   st = ((FiniteStates) r.getValues().getVariables().elementAt(0)).getNumStates();
		   if (r.getActive()) {
	            for (int j=0; j<total; j++) {
	              values[j]=(double) 1/st;
	            }
		   }
		   else {
		    /* ADDING */
		    for (int j=0; j<total/st-1; j++)
		    {

		      for (int k=0; k<j; k++) {
		        if (k>st-1) {
		          break;
		        }
		        values[k*(total/st)+j]=0.0;
		      }

		      for (int k=j+1; k<st; k++) {
			if (k>st-1) {
			  break;
			}
			values[k*(total/st)+j]=0.0;
		      }

		      if (j>st-1) {
			values[(st-1)*(total/st)+j]=1.0;
		      }
		      else {
			values[j*(total/st)+j]=1.0;
		      }
		    }

		    for (int k=0; k<st-1; k++) {
		      values[(total/st)*(k+1)-1]=0.0;
		    }

		    values[st*(total/st)-1]=1.0;
		    /* END ADDING */
		   }
		   if (r.getValues().getClass() == PotentialTable.class) {
		    ((PotentialTable) r.getValues()).setValues(values);
		   }

               //Introducido por jruiz
		   else if (r.getValues().getClass() == GeneralizedPotentialTable.class) {
		    ((GeneralizedPotentialTable) r.getValues()).setValues(values);
		   }//Fin introducido por jruiz

		   else if (r.getValues().getClass() == CanonicalPotential.class) {
		    System.out.println("Pasamos por no actual para relación "+r.getName());
		   }
	         }
	      }
	      else if ((actual) && (node.getKindOfNode() != Node.DECISION)) {
		total=(int)FiniteStates.getSize(r.getValues().getVariables());
                if (debug) {
                  System.out.println("Total es "+total);
                }
	        double newvalues[] = new double[total];
	             
	        double oldvalues[] = ((PotentialTable) r.getValues()).getValues();
	        for (int j=0; j<total; j++) {
                  int orderPos = 0;
                  if (node.getKindOfNode() == Node.UTILITY) {
                     orderPos = j / total;
                  }
                  else {
	             orderPos = j / (total/((FiniteStates)node).getNumStates());
                  }
                  int position = 0;
                  if (node.getKindOfNode() == Node.UTILITY) {
                     position = j;
                  }
                  else {
                     position = ((Integer) order.elementAt(orderPos)).intValue()-1;
                  }
                  if (debug) {
                    System.out.println("Position "+position+" orderPos "+orderPos);
                  }
	          if (position<oldvalues.length)
	            newvalues[j]=(double) oldvalues[position];
	          else
	            newvalues[j]=(double) 0.0;
	        }
		if (r.getValues().getClass() == PotentialTable.class) {
		    ((PotentialTable) r.getValues()).setValues(newvalues);
		}

            //Introducido por jruiz
		else if (r.getValues().getClass() == GeneralizedPotentialTable.class) {
		    ((GeneralizedPotentialTable) r.getValues()).setValues(newvalues);
		}//Fin introducido por jruiz

		else if (r.getValues().getClass() == CanonicalPotential.class) {
		    System.out.println("Pasamos por actual para relación "+r.getName());
		}
	      }

	      i++;
	   }
	}

	/**
	 * This class is used for painting and colouring the table and
	 * the headers
	 */

	class RowRenderer extends DefaultTableCellRenderer {
	   // True if it is rendering the first column
	   private boolean first;
	   
	   

	   RowRenderer (boolean b) {
	      first = b;
	   }



	   public Component getTableCellRendererComponent (JTable table,
	                        Object value, boolean isSelected,
	                        boolean hasFocus,
	                        int row, int column) {
	      if (general) {
	         if (row < nodeRelation.getVariables().size()-1){
	            setBackground(Color.lightGray);
	            if (row%2==0)
	               setForeground(Color.red);
	            else
	               setForeground(Color.blue);
	         }
	         else
	            if (first) {
	               setBackground(Color.lightGray);
	               setForeground(Color.black);
	            }
	            else {
	               setBackground(Color.white);
	               setForeground(Color.black);
	            }
	      }
	      else {
	         if (first) {
	            setBackground(Color.lightGray);
	            setForeground(Color.black);
	         }
	         else if (row<2) {
	            setForeground(Color.red);
	            setBackground(Color.lightGray);
	         }
	         else {
		  setBackground(Color.white);
		  setForeground(Color.black);
	         }
	      }

	      return super.getTableCellRendererComponent(table,
	                     value, isSelected, hasFocus,
	                     row, column);
	   }
	}

	public class ParentsTableModel extends DefaultTableModel {

	  public ParentsTableModel (Object[][] data, Object[] columnNames) {
	    super(data, columnNames);
	  }

	  /**
	   * JTable uses this method to determine the default renderer/
	   * editor for each cell.  If we didn't implement this method,
	   * then the last column would contain text ("true"/"false"),
	   * rather than a check box.
	   */

	  public Class getColumnClass(int c) {
	    if(getValueAt(0,c)!=null)
	      return getValueAt(0, c).getClass();
	    else
	      return super.getColumnClass(c);
	  }

	  /**
	   * Don't need to implement this method unless your table's
	   * editable.
	   */

	  public boolean isCellEditable(int row, int col) {
	    //Note that the data/cell address is constant,
	    //no matter where the cell appears onscreen.
	    /*if (isEditable)
	      return true;
	    else
	      return false;
*/
	    return false;
	  }
	}

        /**
	 * Defines the actions that must be taken when a value...
         **/

        public class NodeTableModel extends DefaultTableModel {

          /**
           * JTable uses this method to determine the default renderer/
           * editor for each cell.  If we didn't implement this method,
           * then the last column would contain text ("true"/"false"),
           * rather than a check box.
           */

          public Class getColumnClass(int c) {
            //return getValueAt(0, c).getClass();
	    /* MODIFIED: null exception when node without parents + indRadioButton */
	    if(getValueAt(0,c)!=null)
	      return getValueAt(0, c).getClass();
	    else
	      return super.getColumnClass(c);
          }

          /**
           * Don't need to implement this method unless your table's
           * editable.
           */

          public boolean isCellEditable(int row, int col) {
            //Note that the data/cell address is constant,
            //no matter where the cell appears onscreen.
            if (isEditable) {
                if (col < 1) {
                    return false;
                }
                else {
		   //if ((typeRelationButton.getText().equals(localize(dialogBundle, "EditVariable.relationXor.label"))) &&
		   //    (nodeRelation.isDeterministic())) {
		   /*if ((node.getKindOfNode() == node.DECISION)) {
		     return false;
		   }*/
		   if ((nodeRelation.getKind() == Relation.XOR) &&
		       (nodeRelation.isDeterministic())) {
		      return false;
		   }

		   if ((nodeRelation.getValues().getClass()==CanonicalPotential.class) &&
			(cptRadioButton.isSelected())) {
		      return false;
		   }

		   if ((detRadioButton.isSelected()) && (general)) {
		      if (row > (parents.size()-1)) {
			return true;
		      }
		      else {
			return false;
		      }
		   }

		   if ((rows-row>states.size()) && (general)) {
                         return false;
		   }
                   else {
                      if ((row<2) && (!general)) {
                         return false;
                      }
                      else {
                         if (lockedColumns) {
                            int i=0;
			    if ((typeRelationButton.getText().equals(localize(dialogBundle, "EditVariable.relationDialogGeneralizedMax.label"))) ||
				(typeRelationButton.getText().equals(localize(dialogBundle, "EditVariable.relationDialogMin.label"))) ||
				(typeRelationButton.getText().equals(localize(dialogBundle, "EditVariable.relationDialogXor.label")))) {
			      return true;
			    }
                            while (i<lockedColumnsArray.length) {
                               if (lockedColumnsArray[i]==col)
                                  return false;
                               i++;
                            }
                            return true;
                         }
                         else {
                            return true;
                         }
                      }
                   }
                }
            }
            else {
	      return false;
            }
          }
        }

	public class ValuesTableModel extends DefaultTableModel {

	  public ValuesTableModel (Object[][] data, Object[] columnNames) {
	    super(data, columnNames);
	  }

	  /**
	   * JTable uses this method to determine the default renderer/
	   * editor for each cell.  If we didn't implement this method,
	   * then the last column would contain text ("true"/"false"),
	   * rather than a check box.
	   */

	  public Class getColumnClass(int c) {
	    if(getValueAt(0,c)!=null)
	      return getValueAt(0, c).getClass();
	    else
	      return super.getColumnClass(c);
	  }

	  /**
	   * Don't need to implement this method unless your table's
	   * editable.
	   */

	  public boolean isCellEditable(int row, int col) {
	    //Note that the data/cell address is constant,
	    //no matter where the cell appears onscreen.
	    if (isEditable)
	      return true;
	    else
	      return false;
	  }
	}

        /**
	 * Defines the actions that must be taken when a value
         * is entered in the relation table. In this case, check if
	 * the value entered correspond to a double.
	 */

        public class RelationTableListener implements TableModelListener {

         /**
         * Created by Francisco Escribano. Modified by Manuel Luque
	 * Defines the actions that must be taken when a value
         * is entered in the relation table. In this case, check if
	 * the value entered correspond to a double.
	 */
                 public void tableChanged(TableModelEvent e) {
                //int row = e.getFirstRow();
                int maxDecimals=10;
                double epsilon;
                
                epsilon=Math.pow(10,-(maxDecimals+2));
                
                
                int row = e.getLastRow(); /* TO TEST */
                int column = e.getColumn();
                theTableChanged = true;
                
                if (debug) {
                    System.out.println("Fila en tableChanged "+row);
                    System.out.println("Columna en tableChanged "+column);
                }
                
                String data = (String) relationModel.getValueAt(row, column);
                
                if (debug) {
                    System.out.println("Valor "+data);
                }
                
                if (data==null) {
                    TableCellEditor rowcolCellEditor =
                    (TableCellEditor) relationTable.getCellEditor(row,column-1); /* Why column-1? */
                    rowcolCellEditor.stopCellEditing(); /* This was the action lacking */
                    data = (String) rowcolCellEditor.getCellEditorValue();
                    if (debug) {
                        if (data==null)
                            System.out.println("Data null in tableChanged!!!!!!!!!!!");
                    }
                    //relationModel.setValueAt(data, row, column);
                    //System.out.println("Hemos pasado por aquí");
                }
                
                if (valuesMode==false) {
                    try {
                        Double value = new Double(data);
                        if ((value.doubleValue() < 0.0) &&  (node.getKindOfNode() != Node.UTILITY)) {
                            ShowMessages.showMessageDialog(ShowMessages.LESS_THAN_O,
                            JOptionPane.ERROR_MESSAGE);
                            relationModel.setValueAt(editingValue, row, column);
                        }
                        else if ((value.doubleValue() > 1.0) && (node.getKindOfNode() != Node.UTILITY)) {
                            ShowMessages.showMessageDialog(ShowMessages.HIGHER_THAN_ONE,
                            JOptionPane.ERROR_MESSAGE);
                            relationModel.setValueAt(editingValue, row, column);
                        }
                    }
                    catch (NumberFormatException ex) {
                        ShowMessages.showMessageDialog(ShowMessages.WRONG_CELL_VALUE,
                        JOptionPane.ERROR_MESSAGE);
                        relationModel.setValueAt(editingValue, row, column); /*¿?*/
                    }
                }
                
                if (node.getKindOfNode() == Node.UTILITY) {
                    return;
                }
                
                if (valuesMode==false) {
                    
                    int index = 0;
                    
                    if (indRadioButton.isSelected()) {
                        /* Case to review: pay attention! */
                        index = 1;
                    }
                    
                    double the_value = 0.0;
                    int theHeader;
                    
                    if (general) {
                        theHeader=parents.size();
                    }
                    else {
                        theHeader=2;
                    }
                    
                    //for (int i=theHeader; i<theHeader+((FiniteStates) node).getNumStates()-index; i++) {
                    for (int i=theHeader; i<theHeader+valuesTable.getRowCount()-index; i++) {
                        double d = new Double(relationModel.getValueAt(i,column).toString()).doubleValue();
                        the_value = the_value+d;
                    }
                    
                    if (index == 1) {
                        if (general) {
                            //System.out.println("Columns "+columns+" column "+column);
                            //the_value = the_value + ((PotentialTable) nodeRelation.getValues()).getValue((((FiniteStates) node).getNumStates()-1)*columns+column-1);
                            the_value = the_value + ((PotentialTable) nodeRelation.getValues()).getValue((valuesTable.getRowCount()-1)*columns+column-1);
                        }
                        else {
                            /* Canonical case... */
                            if ((nodeRelation.getKind() == Relation.GENERALIZED_MAX) ||
                            (nodeRelation.getKind() == Relation.MIN) ||
                            (nodeRelation.getKind() == Relation.XOR)) {
                                boolean exit = false;
                                int par = 0;
                                int total = 0;
                                
                                while (!exit) {
                                    if ((column-1) < ((FiniteStates) parents.elementAt(par)).getNumStates() + total) {
                                        exit = true;
                                    }
                                    else {
                                        total = total + ((FiniteStates) parents.elementAt(par)).getNumStates();
                                        par++;
                                    }
                                    if (par == parents.size()) {
                                        exit = true;
                                    }
                                }
                                
                                if (par == parents.size()) {
                                    the_value = the_value + ((PotentialTable) ((CanonicalPotential) nodeRelation.getValues()).getArgumentAt(par)).getValue(total-(column-1)+((FiniteStates) node).getNumStates()-1);
                                }
                                else {
                                    the_value = the_value + ((PotentialTable) ((CanonicalPotential) nodeRelation.getValues()).getArgumentAt(par)).getValue(total-(column-1)+(((FiniteStates) node).getNumStates()-1)*((FiniteStates) parents.elementAt(par)).getNumStates());
                                }
                            }
                            else {
                                boolean exit = false;
                                int par = 0;
                                int total = 0;
                                
                                while (!exit) {
                                    if ((column-1) < ((FiniteStates) parents.elementAt(par)).getNumStates()-1 + total) {
                                        exit = true;
                                    }
                                    else {
                                        total = total + ((FiniteStates) parents.elementAt(par)).getNumStates()-1;
                                        par++;
                                    }
                                    if (par == parents.size()) {
                                        exit = true;
                                    }
                                }
                                
                                if (par == parents.size()) {
                                    the_value = the_value + ((PotentialTable) ((CanonicalPotential) nodeRelation.getValues()).getArgumentAt(par)).getValue(total-(column-1)+((FiniteStates) node).getNumStates()-1);
                                }
                                else {
                                    the_value = the_value + ((PotentialTable) ((CanonicalPotential) nodeRelation.getValues()).getArgumentAt(par)).getValue(total-(column-1)+(((FiniteStates) node).getNumStates()-1)*((FiniteStates) parents.elementAt(par)).getNumStates());
                                }
                            }
                        }
                    } //end of if (index==1)
                    
                    
                    if ((Math.abs(the_value-1.0))>epsilon){
                                            
                        boolean when = true;
                        //int modifyingRow = theHeader+((FiniteStates) node).getNumStates()-1;
                        int modifyingRow = theHeader+valuesTable.getRowCount()-1;
                        double carrying = 1 - the_value;
                        
                        TableModelListener tableListener = (TableModelListener) relationModel.getListeners(TableModelListener.class)[0];
                        relationModel.removeTableModelListener(tableListener);
                        
                   
                        while (when) {
                            if (modifyingRow == row) {
                                modifyingRow--;
                            }
                            else if (modifyingRow == theHeader-1) {
                                when = false;
                            }
                            else {
                                if ((index == 1) && (modifyingRow == theHeader+((FiniteStates) node).getNumStates()-1)) {
                                    if (general) {
                                        int numStates;
                                                                                
                                        numStates=((FiniteStates) node).getNumStates();
                                        double d = ((PotentialTable) nodeRelation.getValues()).getValue((numStates-1)*columns+column-1) + carrying;
                                        
                                        if (d > 1.0) {
                                            carrying = d;
                                            modifyingRow--;
                                        }
                                        else if (d < 0.0) {
                                            carrying = d;
                                            modifyingRow--;
                                        }
                                        else {
                                            when = false;
                                        }
                                    }
                                    else {
                                        /* Canonical case... */
                                        double d;
                                        double theD;
                                        
                                        if ((nodeRelation.getKind() == Relation.GENERALIZED_MAX) ||
                                        (nodeRelation.getKind() == Relation.MIN) ||
                                        (nodeRelation.getKind() == Relation.XOR)) {
                                            boolean exit = false;
                                            int par = 0;
                                            int total = 0;
                                            
                                            while (!exit) {
                                                if ((column-1) < ((FiniteStates) parents.elementAt(par)).getNumStates() + total) {
                                                    exit = true;
                                                }
                                                else {
                                                    total = total + ((FiniteStates) parents.elementAt(par)).getNumStates();
                                                    par++;
                                                }
                                                if (par == parents.size()) {
                                                    exit = true;
                                                }
                                            }
                                            
                                            if (par == parents.size()) {
                                                theD = ((PotentialTable) ((CanonicalPotential) nodeRelation.getValues()).getArgumentAt(par)).getValue(total-(column-1)+((FiniteStates) node).getNumStates()-1);
                                                d = theD + carrying;
                                            }
                                            else {
                                                theD = ((PotentialTable) ((CanonicalPotential) nodeRelation.getValues()).getArgumentAt(par)).getValue(total-(column-1)+(((FiniteStates) node).getNumStates()-1)*((FiniteStates) parents.elementAt(par)).getNumStates());
                                                d = theD + carrying;
                                            }
                                        }
                                        else {
                                            boolean exit = false;
                                            int par = 0;
                                            int total = 0;
                                            
                                            while (!exit) {
                                                if ((column-1) < ((FiniteStates) parents.elementAt(par)).getNumStates()-1 + total) {
                                                    exit = true;
                                                }
                                                else {
                                                    total = total + ((FiniteStates) parents.elementAt(par)).getNumStates()-1;
                                                    par++;
                                                }
                                                if (par == parents.size()) {
                                                    exit = true;
                                                }
                                            }
                                            
                                            if (par == parents.size()) {
                                                theD = ((PotentialTable) ((CanonicalPotential) nodeRelation.getValues()).getArgumentAt(par)).getValue(total-(column-1)+((FiniteStates) node).getNumStates()-1);
                                                d = theD + carrying;
                                            }
                                            else {
                                                theD = ((PotentialTable) ((CanonicalPotential) nodeRelation.getValues()).getArgumentAt(par)).getValue(total-(column-1)+(((FiniteStates) node).getNumStates()-1)*((FiniteStates) parents.elementAt(par)).getNumStates());
                                                d = theD + carrying;
                                            }
                                        }
                                        
                                        if (d > 1.0) {
                                            carrying = carrying + theD;
                                            modifyingRow--;
                                        }
                                        else if (d < 0.0) {
                                            carrying = carrying + theD;
                                            modifyingRow--;
                                        }
                                        else {
                                            when = false;
                                        }
                                    } //end of else { /* Canonical case */
                                }
                                else {
                                    double d = new Double(relationModel.getValueAt(modifyingRow, column).toString()).doubleValue() + carrying;
                                                                       
                                    if (d > 1.0) {
                                        carrying = carrying + new Double(relationModel.getValueAt(modifyingRow, column).toString()).doubleValue();
                                        relationModel.setValueAt("1",modifyingRow,column);
                                        modifyingRow--;
                                    }
                                    else if (d < 0.0) {
                                        carrying = carrying + new Double(relationModel.getValueAt(modifyingRow, column).toString()).doubleValue();
                                        relationModel.setValueAt("0",modifyingRow,column);
                                        modifyingRow--;
                                    }
                                    else {
                                        double restOfSum=0;
                                        double newProb;
                                        double roundedNewProb;
                                        
                                        relationModel.setValueAt(new Double(d).toString(),modifyingRow,column);
                                        
                                        //The cells must be rounde to the desired precision and must sum 1
                                        adjustToPrecision(relationModel,epsilon,maxDecimals,theHeader,valuesTable.getRowCount(),column);
                                        when = false;
                                    }
                                }
                            }
                        }
                        relationModel.addTableModelListener(tableListener);
                    }
                }
            }
            
                 
  /**
   * Created by mluque
   * It adjusts the precision of the column 'jColumn' of the 'relationModel' with a maximum
   * of 'maxDecimals' decimals. If the sum of the probabilities is better than 1 in some moment
   * (because of
   * the rounds) this is corrected so the sum is 1.
  */
                 
public void adjustToPrecision(NodeTableModel relationModel,double epsilon,int maxDecimals,int numberOfRowsHeader,int numberOfRows,int jColumn){
    
     double restOfProb;
     double iRounded;
     double iNoRounded;
     int indexZero=numberOfRows;
     int i;
     boolean lastsMustBeZero=false;
     String stringRounded;
     
     restOfProb=1;
     double iValue;
     for (i=numberOfRowsHeader; (i<(numberOfRowsHeader+numberOfRows-1))&&(!lastsMustBeZero); i++) {
            String stringOfCell;
            stringOfCell=relationModel.getValueAt(i,jColumn).toString();
            iNoRounded=new Double(stringOfCell).doubleValue();
            iRounded=roundAndReduce(iNoRounded,epsilon,maxDecimals);
	    if (iRounded>(restOfProb+epsilon))
            {
                lastsMustBeZero=true;
                iRounded=restOfProb;
                indexZero=i;
                
                relationModel.setValueAt(Double.toString(roundAndReduce(restOfProb,epsilon,maxDecimals)),i,jColumn);
            }
            else
            {
                relationModel.setValueAt(Double.toString(roundAndReduce(iNoRounded,epsilon,maxDecimals)),i,jColumn);
                restOfProb=restOfProb-iRounded;
            }
     }
     if (!lastsMustBeZero){
         relationModel.setValueAt(Double.toString(roundAndReduce(restOfProb,epsilon,maxDecimals)),numberOfRowsHeader+numberOfRows-1,jColumn);
     }
     else{
         for (i=indexZero+1;i<(numberOfRowsHeader+numberOfRows);i++)
         {
             relationModel.setValueAt("0",i,jColumn);
         }
     }
     
}
    

        /**
        * It rounds 'x' with 'numDecimals' exact decimals.
         * If the rounded number has got some zeros at the end,
         * this function removes them (E.g.: 0.234000 -> 0.234)
        */
       
public double roundAndReduce(double x,double epsilon,int numDecimals){
        
    double lastRounded;
    double actualRounded;
    int i;
    boolean equals;
    
    lastRounded=roundWithPrecision(x,numDecimals);
    equals=true;
    for (i=numDecimals-1;(i>=0)&&equals;i--){
        actualRounded=roundWithPrecision(x,i);
        equals=((Math.abs(actualRounded-lastRounded))<epsilon);
        if (equals){
            lastRounded=actualRounded;
        }
    }
    return lastRounded;
}

       /**
        * It rounds 'x' with 'numDecimals' exact decimals.
         * If the rounded number has got some zeros at the end,
         * this function removes them (E.g.: 0.234000 -> 0.234)
        */
       
/*public String roundReduceAndToString(double x,double epsilon,int numDecimals){
        
    double lastRounded;
    double actualRounded;
    int i;
    int numDecimalsReduced=0;
    boolean equals;
    int lengthString;
    String roundedString;
        
    lastRounded=roundWithPrecision(x,numDecimals);
    equals=true;
    for (i=numDecimals-1;(i>=0)&&equals;i--){
        actualRounded=roundWithPrecision(x,i);
        equals=((Math.abs(actualRounded-lastRounded))<epsilon);
        if (equals){
            lastRounded=actualRounded;
        }
        else numDecimalsReduced=i+1;
    }
    
    if (numDecimalsReduced==0) lengthString=1;
    else lengthString=numDecimalsReduced+2;
    
    roundedString=new Double(lastRounded).toString();
    return (roundedString.substring(0,lengthString));
}*/
            
            
       /**
        * It rounds 'x' with 'numDecimals' exact decimals
        */

public double roundWithPrecision(double x,int numDecimals){
    
    double xRounded;
    double scale;
    
    scale=Math.pow(10, numDecimals);
    xRounded=Math.round(x*scale);
    xRounded=xRounded/scale;
    
    return xRounded;
}
                 
    
            
} // end of class
        /**
	 * Set the selection method that is allowed in the table
	 */

        public class RelationSelectionListener implements ListSelectionListener {

	  public void valueChanged (ListSelectionEvent e) {
	    int column = relationTable.getSelectedColumn(),
	      row = relationTable.getSelectedRow();

	    editingValue = (String) relationTable.getValueAt(row, column);
	  }
        }

        /**
	 * Class for undoing/redoing the operations that take place
	 * into the EditVariableDialog
	 */

	class ChangePropertiesEdit extends AbstractUndoableEdit {
	   String newName, oldName;
	   String newTitle, oldTitle;
	   String newComment, oldComment;
	   double newRelevance, oldRelevance;
	   String newPurpose, oldPurpose;
	   int newKind, oldKind;
	   int newType, oldType;
	   Vector oldStates, newStates;
	   Relation oldRelation, newRelation;
	   Node node;

	  /**
	   * Creates a new ChangePropertiesEdit object with the
	   * information contained in the variables given as parameter.
	   * All this information correspond to the old values (values
	   * are restored when the undo action is taken).
	   */

	  public ChangePropertiesEdit (Node n, Relation r) {
		   super();
		   oldStates = new Vector();
		   newStates = new Vector();

		   oldName = n.getName();
		   oldTitle = n.getTitle();
		   oldComment = n.getComment();
		   oldKind = n.getKindOfNode();
		   oldType = n.getTypeOfVariable();
		   oldRelevance = n.getRelevance();
		   oldPurpose = n.getPurpose();
		   if (n.getClass()==FiniteStates.class)
		      for (int i=0; i<((FiniteStates) n).getStates().size(); i++)
		         oldStates.add(((FiniteStates) n).getState(i));
                   if (r != null) {
		     oldRelation = r.copy();
                   }
	   }

	   public void setNewProperties (Node n, Relation r) {
		   newName = n.getName();
		   newTitle = n.getTitle();
		   newComment = n.getComment();
		   newKind = n.getKindOfNode();
		   newType = n.getTypeOfVariable();
		   newRelevance = n.getRelevance();
		   newPurpose = n.getPurpose();
		   if (n.getClass()==FiniteStates.class) {
		      for (int i=0; i<((FiniteStates) n).getStates().size(); i++)
		         newStates.add(((FiniteStates) n).getState(i));
		      newRelation = r.copy();
		   }
		   node = n;
	   }

	   public void fillProperties(Node n, String name, String title, String comment,
						int kind, int type, double relevance, String purpose,
						Vector states, Relation relation) {
		   n.setName(name);
		   n.setTitle(title);
                   FontMetrics fm=Elvira.getElviraFrame().getCurrentEditorPanel().getFontMetrics(Elvira.getElviraFrame().getCurrentEditorPanel().getFont(n.getFont()));
                   VisualNode.setAxis(n,n.getNodeString(byTitle),fm);
		   n.setComment(comment);
		   n.setKindOfNode(kind);
		   n.setTypeOfVariable(type);
		   n.setRelevance (relevance);
		   n.setPurpose(purpose);
		   if (n.getClass()==FiniteStates.class) {
		      ((FiniteStates) n).setStates(states);
		      int position = bayesNet.getRelationList().indexOf(nodeRelation);
		      bayesNet.getRelationList().remove(position);
		      bayesNet.getRelationList().insertElementAt(relation, position);
		   }
	   }

	   public void undo() throws CannotUndoException {
	      super.undo();
	      fillProperties (node, oldName, oldTitle, oldComment, oldKind, oldType,
				   oldRelevance, oldPurpose, oldStates, oldRelation);

	      Elvira.getElviraFrame().getCurrentEditorPanel().updateUndoRedo();
	   }

	   public void redo() throws CannotRedoException {
	      super.redo();
	      fillProperties (node, newName, newTitle, newComment, newKind, newType,
				   newRelevance, newPurpose, newStates, newRelation);
	      Elvira.getElviraFrame().getCurrentEditorPanel().updateUndoRedo();
	   }

	   public String getUndoPresentationName() {
	      return localize (menuBundle, "Edit.Undo.label")+" "+
	             localize(menuBundle, "Action.changeNode.label");
	   }

	   public String getRedoPresentationName() {
	      return localize (menuBundle, "Edit.Redo.label")+" "+
	             localize(menuBundle, "Action.changeNode.label");
	   }
	}

	/**
	 * Show/Hides the panels with the diferent options for the
	 * canonical relations
	 *
	 * @param b True if the panels must be shown and False if not
	 * @param orPanelVisible True if the panel that contains the types
	 * of the different OR relations must be shown.
	 */

	public void showOptions (boolean b, boolean orPanelVisible) {
	   if (probRadioButton.isSelected())
	      panelSetEnabled(panel2,true);
	   else {
	      panelSetEnabled(panel3,b);
	      panelSetEnabled(panel2,false);
	   }

	   panelSetEnabled(panel4,b);
	   panelSetEnabled(orTypePanel,orPanelVisible);
	}

	/**
	 * Get the kind of the relation that is being edited. To
	 * do this uses the index of the item selected in the combo box
	 */

	public int getKindFromTypeRelationButton () {

	  if (typeRelationButton.getText().equals(localize(dialogBundle,"EditVariable.relationDialogOr.label"))){
	    return Relation.OR;
	  }
	  else if (typeRelationButton.getText().equals(localize(dialogBundle,"EditVariable.relationDialogCausalMax.label"))) {
	    return Relation.CAUSAL_MAX;
	  }
	  else if (typeRelationButton.getText().equals(localize(dialogBundle,"EditVariable.relationDialogGeneralizedMax.label"))) {
	    return Relation.GENERALIZED_MAX;
	  }
	  else if (typeRelationButton.getText().equals(localize(dialogBundle,"EditVariable.relationDialogAnd.label"))) {
	    return Relation.AND;
	  }
	  else if (typeRelationButton.getText().equals(localize(dialogBundle,"EditVariable.relationDialogMin.label"))) {
	    return Relation.MIN;
	  }
          else if (typeRelationButton.getText().equals(localize(dialogBundle,"EditVariable.relationDialogXor.label"))) {
	    return Relation.XOR;
	  }
          else if (typeRelationButton.getText().equals(localize(dialogBundle,"EditVariable.relationDialogAdd.label"))) {
	    //return Relation.ADD;
	    return Relation.UTILITY_COMBINATION;
	  }
	  else if (typeRelationButton.getText().equals(localize(dialogBundle,"EditVariable.relationDialogMultiply.label"))) {
	    //return Relation.MULTIPLY;
	    return Relation.UTILITY_COMBINATION;
	  }
	  else {
	    return -1;
	  }

	}

	/**
	 * Actions executed when the values radio button is
	 * selected
	 */

	void valRadioButton_itemStateChanged(java.awt.event.ItemEvent event)
	{
	    if ((valRadioButton.isSelected()) && (!optionsDisabled) && (!valuesMode)) {
	      int i;
	      JComboBox comboBox = new JComboBox();

	      relationTable.editingStopped(new ChangeEvent(this));

	      if (detRadioButton.isSelected()) {
		panelSetEnabled(panel2,false);
	      }

	      panelSetEnabled(panel4,false);
	      valuesMode = true;

            //Modificado por jruiz
	      if (nodeRelation.getValues().getClass() ==  PotentialTable.class ||
                nodeRelation.getValues().getClass() == GeneralizedPotentialTable.class) {
		general = true;
	      }//Fin modificado por jruiz

	      else {
		general = false;
	      }

	      getValues(nodeRelation,true);
	      statesHasChanged = true;

	      if (!general) {
		generateCanonicalTable(nodeRelation);
	      }
	      else {
		generateNormalTable(nodeRelation);
	      }

	      getValuesFromProbabilities();

	      // Add the states to the combo box
	      for (i=0; i<valuesTable.getRowCount(); i++) {
		comboBox.addItem(valuesTable.getValueAt(i, 1));
		//comboBox.addItem(((FiniteStates) node).getState(i));
	      }

	      tcm = relationTable.getColumnModel();

	      // Set the combo box created as the cell editor
	      for (i=0; i<relationTable.getColumnCount(); i++) {
	         TableColumn column = tcm.getColumn(i);
	         column.setCellEditor(new DefaultCellEditor(comboBox));
	      }
	    }
	}


	/**
	 * Actions that must be taken when the all parameters
	 * radio button is selected. In this case, enable and disables
	 * some options, store the values of the table in a MaxRelation
	 * object and generate a new table with the correct values.
	 */

	void allRadioButton_itemStateChanged(java.awt.event.ItemEvent event)
	{
	  if ((allRadioButton.isSelected()) && (!optionsDisabled)) {
	    /*if (!canRadioButton.isSelected()) {
              canRadioButton.setSelected(true);
	    }*/

	    //cptRadioButton.setEnabled(false);

          //Modificado por jruiz
	    if (nodeRelation.getValues().getClass() == PotentialTable.class ||
              nodeRelation.getValues().getClass() == GeneralizedPotentialTable.class) {
              general = true;
	    }//Fin modificado por jruiz

	    else {
	      general = false;
	    }

            node.setIndependentParams(false);
	    statesHasChanged = true;
	    Relation r = new Relation();
	    relationTable.editingStopped(new ChangeEvent(this));
	    getValues(r,false);

	    if (nodeRelation.isDeterministic()) {
	      int i, reply = 1;
	      JComboBox comboBox = new JComboBox();

	      // If the Canonical model selected is the deterministic
	      // OR the values are automatically inserted in the
	      // getValuesFromProbabilities method

	      valuesMode = false;
	      statesHasChanged = true;

	      if (!general) {
		generateCanonicalTable(r);
	      }
	      else {
		generateNormalTable(r);
	      }

	      // Add the states to the combo box
	      comboBox.addItem("0.0");
	      comboBox.addItem("1.0");

	      tcm = relationTable.getColumnModel();

	      // Set the combo box created as the cell editor
	      for (i=0; i<relationTable.getColumnCount(); i++) {
	         TableColumn column = tcm.getColumn(i);
	         column.setCellEditor(new DefaultCellEditor(comboBox));
	      }

	    }
	    else {

            //Modificado por jruiz
	      if (nodeRelation.getValues().getClass() == PotentialTable.class ||
                nodeRelation.getValues().getClass() == GeneralizedPotentialTable.class) {
                generateNormalTable(r);
	      }//Fin modificado por jruiz

              else {
	        generateCanonicalTable(r);
              }
	    }
	  }
	}

	/**
	 * Actions that must be taken when the independent parameters
	 * radio button is selected. In this case, enable and disables
	 * some options, store the values of the table in a MaxRelation
	 * object and generate a new table with the correct values.
	 */

	void indRadioButton_itemStateChanged(java.awt.event.ItemEvent event)
	{
	  if ((indRadioButton.isSelected()) && (!optionsDisabled)) {
            optionsDisabled=true;
            //cptRadioButton.setEnabled(true); /* MODIFIED: commented for the moment */
            optionsDisabled=false;

          //Modificado por jruiz
	    if (nodeRelation.getValues().getClass() == PotentialTable.class ||
              nodeRelation.getValues().getClass() == GeneralizedPotentialTable.class) {
              general = true;
	    }//Fin modificado por jruiz

            else {
	      general = false;
            }

            node.setIndependentParams(true);
	    statesHasChanged = true;
	    Relation r = new Relation();
	    relationTable.editingStopped(new ChangeEvent(this));
	    getValues(r,false);

	    if (nodeRelation.isDeterministic()) {
	      int i, reply = 1;
	      JComboBox comboBox = new JComboBox();

	      // If the Canonical model selected is the deterministic
	      // OR the values are automatically inserted in the
	      // getValuesFromProbabilities method

	      if ((nodeRelation.getValues().getClass() != CanonicalPotential.class) ||
		  !((CanonicalPotential) nodeRelation.getValues()).getFunction().getName().equals("Or")) {
		if (!getValues(nodeRelation,true)) {
		  Object[] options = { localize(dialogBundle,"Yes.label"),
		                              localize(dialogBundle,"No.label") };
		  reply = ShowMessages.showOptionDialog(
	                  ShowMessages.NOT_DETERMINISTIC,
	                  JOptionPane.QUESTION_MESSAGE,
	                  options, 1);
	         }
	         else {
	            reply = 0;
	         }
	      }
	      else {
	         reply = 0;
	      }

	      valuesMode = false;
	      statesHasChanged = true;

	      if (!general) {
		generateCanonicalTable(nodeRelation);
	      }
	      else {
		generateNormalTable(nodeRelation);
	      }

	      //if (reply==0)
		//getValuesFromProbabilities();

	      comboBox.addItem("0.0");
	      comboBox.addItem("1.0");

	      tcm = relationTable.getColumnModel();

	      // Set the combo box created as the cell editor
	      for (i=0; i<relationTable.getColumnCount(); i++) {
	         TableColumn column = tcm.getColumn(i);
	         column.setCellEditor(new DefaultCellEditor(comboBox));
	      }

	    }
	    else {

            //Modificado por jruiz
	      if (nodeRelation.getValues().getClass() == PotentialTable.class ||
                nodeRelation.getValues().getClass() == GeneralizedPotentialTable.class) {
                generateNormalTable(r);
	      }//Fin modificado por jruiz

              else {
	        generateCanonicalTable(r);
              }
	    }
	  }
	}

	/**
	 * Actions that must be taken when the cpt radio button
	 * is clicked. In this case, get the values of the table
	 * and called to the expandCPT function to obtain the conditional
	 * probability table of the current values. After this, a new
	 * PotentialTable is stored in the nodeRelation variable
	 */

	void cptRadioButton_itemStateChanged(java.awt.event.ItemEvent event)
	{
	  if ((cptRadioButton.isSelected()) && (!optionsDisabled)) {
	    general = false;

	    if (indRadioButton.isSelected()) {
	      allRadioButton.setSelected(true);
	    }

	    if (valuesMode) {
	      probsRadioButton.setSelected(true);
	    }

            optionsDisabled=true;
            indRadioButton.setEnabled(false);
            allRadioButton.setSelected(true);
            optionsDisabled=false;

	    statesHasChanged = true;
	    relationTable.editingStopped(new ChangeEvent(this));
	    getValues(nodeRelation,false);

	    PotentialTable pt = ((CanonicalPotential) nodeRelation.getValues()).getCPT();

	    Relation r = nodeRelation.copy();

	    Vector v = new Vector();
	    for (int i=0; i<nodeRelation.getVariables().size(); i++) {
	      v.addElement(((FiniteStates) nodeRelation.getVariables().elementAt(i)));
	    }
	    //pt.setVariables(v);

	    if (pt!=null) {
	      r.setValues(pt);
	    }
	    else {
	      System.out.println("pt was null in cptRadioButton_item...!!!!!!!");
	    }

	    general = true;
	    lockedColumns = false;
	    //typeRelationButton.setText(localize(dialogBundle,"EditVariable.relationDialogGeneral.label"));
	    r.setKind(Relation.POTENTIAL);
	    generateNormalTable(r);
	    panelSetEnabled(panel1,false);
	    panelSetEnabled(panel2,false);
	    panelSetEnabled(panel3,false);
	    panelSetEnabled(orTypePanel,false);
	    optionsDisabled = true;
	    cptRadioButton.setEnabled(false);
	    optionsDisabled = false;
	  }
	}

	/**
	 * Actions that must be taken when the canonical parameters
	 * radio button is selected. In this case, is not necessary to
	 * make any change to the values, because it gets the values stored
	 * in the orValues variable (that is why the general flag is set
	 * to true.
	 */

	void canRadioButton_itemStateChanged(java.awt.event.ItemEvent event)
	{
	  if ((canRadioButton.isSelected()) && (!optionsDisabled)) {
	    /*general = true;
	    optionsDisabled=true;
	    indRadioButton.setEnabled(true);
	    indRadioButton.setSelected(true);
	    allRadioButton.setEnabled(true);
	    optionsDisabled=false;*/

	    optionsDisabled = true;
	    cptRadioButton.setEnabled(true);
	    optionsDisabled = false;

	    statesHasChanged = true;
	    relationTable.editingStopped (new ChangeEvent(this));
	    /*getValues(nodeRelation,false);*/

	    /*int s = ((FiniteStates)node).getNumStates();

	    if ((nodeRelation.getClass()==MaxRelation.class) &&
	        (diezRadioButton.isSelected())) {
	      ((MaxRelation)nodeRelation).general2Max(s,parents);
	      ((MaxRelation)nodeRelation).henrion2Diez(s-1);
	    }*/

	    /*general = false;*/
	    generateCanonicalTable(nodeRelation);
	    panelSetEnabled(panel1,true);
	    panelSetEnabled(panel2,true);
	    if (nodeRelation.isDeterministic()) {
	      panelSetEnabled(panel3,true);
	    }
	    if ((nodeRelation.getKind() == Relation.OR) ||
	        (nodeRelation.getKind() == Relation.CAUSAL_MAX) ||
		(nodeRelation.getKind() == Relation.GENERALIZED_MAX)) {

		panelSetEnabled(orTypePanel,true);
	    }
	  }
	}

	/**
	 * Actions that must be taken when the deterministic radio
	 * button is clicked: if the table does not contain deterministic
	 * probabilities the method asked if the user whan to obtain the
	 * states that best fits to the values that are in it. If this happens
	 * a new table is generated with this values, and a new cell editor,
	 * that contains a combo box with the posible states are added.
	 */

	void changeInDetButton(JRadioButton detButton,JRadioButton probButton)
	{
	   if ((detButton.isSelected()) && (!optionsDisabled)) {
	      nodeRelation.setDeterministic(true);
	      relationTable.editingStopped(new ChangeEvent(this));
	      panelSetEnabled(panel3,true);

            //Modificado por jruiz
	      if (nodeRelation.getValues().getClass() == PotentialTable.class ||
                nodeRelation.getValues().getClass() == GeneralizedPotentialTable.class) {
		general = true;
	      }//Fin modificado por jruiz

	      else {
		general = false;
	      }

	      if (indRadioButton.isSelected() == true) {
	        allRadioButton.setSelected(true);
	      }

	      if (probButton.isSelected()) {
		panelSetEnabled(panel2,true);
	      }
	      else {
		panelSetEnabled(panel2,false);
	      }

	      if (general) {
	        panelSetEnabled(panel4,false);
	        panelSetEnabled(orTypePanel,false);
	      }
	      else {
		panelSetEnabled(panel4,true);
		if ((nodeRelation.getKind() == Relation.OR) ||
		    (nodeRelation.getKind() == Relation.GENERALIZED_MAX) ||
		    (nodeRelation.getKind() == Relation.CAUSAL_MAX)) {
		  panelSetEnabled(orTypePanel,true);
		}
		else {
		  panelSetEnabled(orTypePanel,false);
		}
	      }

	      int i, reply = 1;
	      JComboBox comboBox = new JComboBox();

	      // If the Canonical model selected is the deterministic
	      // OR the values are automatically inserted in the
	      // getValuesFromProbabilities method

	      if (nodeRelation.getValues().getClass() != CanonicalPotential.class) {
		  //!((CanonicalPotential) nodeRelation.getValues()).getFunction().getName().equals("Or")) {
		if (!getValues(nodeRelation,true)) {
		  Object[] options = { localize(dialogBundle,"Yes.label"),
		                              localize(dialogBundle,"No.label") };
		  reply = ShowMessages.showOptionDialog(
	                  ShowMessages.NOT_DETERMINISTIC,
	                  JOptionPane.QUESTION_MESSAGE,
	                  options, 1);
	         }
	         else {
	            reply = 0;
	         }
	      }
	      else {
	         reply = 0;
	      }

	      valuesMode = true;
	      valRadioButton.setSelected(true);
	      statesHasChanged = true;

	      if (!general) {
		generateCanonicalTable(nodeRelation);
	      }
	      else {
		generateNormalTable(nodeRelation);
	      }

	      if (reply==0) {
		getValuesFromProbabilities();
	      }

	      // Add the states to the combo box
	      for (i=0; i<valuesTable.getRowCount(); i++) {
		comboBox.addItem(valuesTable.getValueAt(i, 1));
		//comboBox.addItem(((FiniteStates) node).getState(i));
	      }

	      tcm = relationTable.getColumnModel();

	      // Set the combo box created as the cell editor
	      for (i=0; i<relationTable.getColumnCount(); i++) {
		TableColumn column = tcm.getColumn(i);
		column.setCellEditor(new DefaultCellEditor(comboBox));
	      }
	   }
	}

	
	void detRadioButton_itemStateChanged(java.awt.event.ItemEvent event)
	{
/*	   if ((detRadioButton.isSelected()) && (!optionsDisabled)) {
	      nodeRelation.setDeterministic(true);
	      relationTable.editingStopped(new ChangeEvent(this));
	      panelSetEnabled(panel3,true);

            //Modificado por jruiz
	      if (nodeRelation.getValues().getClass() == PotentialTable.class ||
                nodeRelation.getValues().getClass() == GeneralizedPotentialTable.class) {
		general = true;
	      }//Fin modificado por jruiz

	      else {
		general = false;
	      }

	      if (indRadioButton.isSelected() == true) {
	        allRadioButton.setSelected(true);
	      }

	      if (probRadioButton.isSelected()) {
		panelSetEnabled(panel2,true);
	      }
	      else {
		panelSetEnabled(panel2,false);
	      }

	      if (general) {
	        panelSetEnabled(panel4,false);
	        panelSetEnabled(orTypePanel,false);
	      }
	      else {
		panelSetEnabled(panel4,true);
		if ((nodeRelation.getKind() == Relation.OR) ||
		    (nodeRelation.getKind() == Relation.GENERALIZED_MAX) ||
		    (nodeRelation.getKind() == Relation.CAUSAL_MAX)) {
		  panelSetEnabled(orTypePanel,true);
		}
		else {
		  panelSetEnabled(orTypePanel,false);
		}
	      }

	      int i, reply = 1;
	      JComboBox comboBox = new JComboBox();

	      // If the Canonical model selected is the deterministic
	      // OR the values are automatically inserted in the
	      // getValuesFromProbabilities method

	      if (nodeRelation.getValues().getClass() != CanonicalPotential.class) {
		  //!((CanonicalPotential) nodeRelation.getValues()).getFunction().getName().equals("Or")) {
		if (!getValues(nodeRelation,true)) {
		  Object[] options = { localize(dialogBundle,"Yes.label"),
		                              localize(dialogBundle,"No.label") };
		  reply = ShowMessages.showOptionDialog(
	                  ShowMessages.NOT_DETERMINISTIC,
	                  JOptionPane.QUESTION_MESSAGE,
	                  options, 1);
	         }
	         else {
	            reply = 0;
	         }
	      }
	      else {
	         reply = 0;
	      }

	      valuesMode = true;
	      valRadioButton.setSelected(true);
	      statesHasChanged = true;

	      if (!general) {
		generateCanonicalTable(nodeRelation);
	      }
	      else {
		generateNormalTable(nodeRelation);
	      }

	      if (reply==0) {
		getValuesFromProbabilities();
	      }

	      // Add the states to the combo box
	      for (i=0; i<valuesTable.getRowCount(); i++) {
		comboBox.addItem(valuesTable.getValueAt(i, 1));
		//comboBox.addItem(((FiniteStates) node).getState(i));
	      }

	      tcm = relationTable.getColumnModel();

	      // Set the combo box created as the cell editor
	      for (i=0; i<relationTable.getColumnCount(); i++) {
		TableColumn column = tcm.getColumn(i);
		column.setCellEditor(new DefaultCellEditor(comboBox));
	      }
	   }*/
		changeInDetButton(detRadioButton,probRadioButton);
	}

	/**
	 * Get the states values that the cells of the relation table
	 * contains and transform it in the probability value
	 *
	 * @param nodeRelation Relation in which the probabilities obtained
	 * are stored
	 */

	public void transformToProbabilities (Relation nodeRelation) {
	   double values[];
	   int cols;

	   // Get the number of states that are use in the table and
	   // the its number of cells
	   int row = relationTable.getRowCount()-1,
	       position, size,
	       validStates=((FiniteStates) node).getNumStates();

         //Modificado por jruiz
         if (nodeRelation.getValues().getClass() == PotentialTable.class) {
             size = ((PotentialTable) nodeRelation.getValues()).getValues().length;
         } else if (nodeRelation.getValues().getClass() == GeneralizedPotentialTable.class) {
             size = ((GeneralizedPotentialTable) nodeRelation.getValues()).getValues().length;
         } else {
	      //validStates--;
	      //size = (columns+1)*validStates;
	      size = 0;
	      for (int i=0; i<((CanonicalPotential) nodeRelation.getValues()).getArgumentsSize(); i++) {
		size = size + (int) ((PotentialTable) ((CanonicalPotential) nodeRelation.getValues()).getArgumentAt(i)).getSize();
	      }
	   }//Fin modificado por jruiz

	   if (debug) {
	      System.out.println("En transformToProbabilities Nuevo size="+size);
	   }

	   values = new double[size];

	   // Get the number of columns of the table
	   if (!general) {
	    if (nodeRelation.getKind() == Relation.XOR) {
	      //cols = columns;
	      cols = size/validStates;
	    }
	    else {
	      //cols = columns+1;
	      cols = size/validStates;
	    }
	   }
	   else {
	      cols = columns;
	   }

	   // For every column get the state value that contains
	   // and using its position into the states' vector, fill
	   // the values array

	   for (int i=0; i<cols; i++) {
	      String s = (String) relationTable.getValueAt(row, i);
	      position = setPosition(s,validStates);

	      if (position!=-1) {
		 if (general) {
		    values[position*columns+i]=1.0;
		 }
		 else {
		    int par = 0;
		    int total = 0;
		    boolean exit = false;

		    while (!exit) {
		      if (i<(((FiniteStates) parents.elementAt(par)).getNumStates())+total) {
		        exit = true;
		      }
		      else {
		        total=total+((FiniteStates) parents.elementAt(par)).getNumStates();
		        par++;
		        if (par == parents.size()) {
			  exit = true;
		        }
		      }
		    }
		    if (par == parents.size()) {
		      values[total*validStates+position]=1.0;
		    }
		    else {
		      values[total*validStates+position*((FiniteStates) parents.elementAt(par)).getNumStates()+(i-total)]=1.0;
		    }
		 }
	      }
	   }

	   // Set the values obtained into a new PotentialTable
	   PotentialTable pt = new PotentialTable();
	   pt.setValues(values);
	   pt.setVariables((Vector) nodeRelation.getValues().getVariables());

	   if (nodeRelation.getValues().getClass() == CanonicalPotential.class) {
	      setCanonicalValues(nodeRelation, values, true);
	   }

         //Modificado por jruiz
	   else if (nodeRelation.getValues().getClass() == PotentialTable.class ||
                  nodeRelation.getValues().getClass() == GeneralizedPotentialTable.class){
	      nodeRelation.setValues(pt);
	   }//Fin modificado por jruiz

	   /* Same kind of modification as in getValues...? Seems of no use here */
	   //nodeRelation.setVariables(nodeRelation.getVariables());
	}

	/**
	 * Obtain the position of the string given as parameter into
	 * the vector that contains the states of the node.
	 *
	 * @param value state name whose position are going to be obtained
	 * @param rows number of rows of states that are showed in the table
	 * @return The position of the string value into the states' vector
	 * or -1 if this string cannot be found.
	 */

	public int setPosition (String value, int rows) {
	   int i=0;
	   String stateName;
	   while (i<rows) {
	      stateName = (String) valuesTable.getValueAt(i,1);
	      if (stateName.equalsIgnoreCase(value))
	         return i;
	      i++;
	   }
	   return -1;
	}

	/**
	 * Set the deterministic values that best fits to the
	 * probabilities that are stored in the nodeRelation variable.
	 * The values obtained are displayed into the relation table
	 * and are not stored.
	 */

	public void getValuesFromProbabilities() {
	   int cols = columns; /* To REVIEW */
	   int numStates = ((FiniteStates) node).getNumStates();
	   //Vector v = ((FiniteStates) node).getStates();
	   Vector v = new Vector();
	   double values[], max, total;

	   for (int i=0; i<valuesTable.getRowCount(); i++) {
	      v.addElement(valuesTable.getValueAt(i,1));
	   }

	   // Get the number of states that are use in the table and
	   // its number of columns

         //Introducido por jruiz
	   if (nodeRelation.getValues().getClass() != PotentialTable.class &&
             nodeRelation.getValues().getClass() != GeneralizedPotentialTable.class) {
	      /* MODIFYING */
	      if (!(nodeRelation.getKind()==Relation.XOR)) { /* To REVIEW */
	        cols++;
	      }

	      int sub_total = 0;
	      for (int i=0; i<parents.size(); i++) {
		sub_total = sub_total + ((FiniteStates) parents.elementAt(i)).getNumStates()*((FiniteStates) node).getNumStates();
	      }

	      if (!(nodeRelation.getKind()==Relation.XOR)) {
		sub_total = sub_total + ((FiniteStates) node).getNumStates();
	      }
	      values = new double[sub_total];
	      //System.out.println("Size "+(((FiniteStates) node).getNumStates()*cols));
	      sub_total = 0;
	      for (int i=0; i<parents.size(); i++) {
		for (int j=0; j<((FiniteStates) node).getNumStates(); j++) {
		  for (int k=0; k<((FiniteStates) parents.elementAt(i)).getNumStates(); k++) {
		    //System.out.println("Position "+(k+j*((FiniteStates) parents.elementAt(i)).getNumStates()+sub_total));
		    values[k+j*((FiniteStates) parents.elementAt(i)).getNumStates()+sub_total]=
		      ((PotentialTable) ((CanonicalPotential) nodeRelation.getValues()).getArgumentAt(i)).getValue(k+j*((FiniteStates) parents.elementAt(i)).getNumStates());
		  }
		}
		sub_total = sub_total + ((FiniteStates) parents.elementAt(i)).getNumStates()*((FiniteStates) node).getNumStates();
	      }

	      if (!(nodeRelation.getKind()==Relation.XOR)) {
		for (int i=0; i<((FiniteStates) node).getNumStates(); i++) {
		  values[sub_total+i]=
		    ((PotentialTable) ((CanonicalPotential) nodeRelation.getValues()).getArgumentAt(parents.size())).getValue(i);
		}
	      }
	      /* END MODIFYING */
	   } else if(nodeRelation.getValues().getClass() == GeneralizedPotentialTable.class) {
	      values = ((GeneralizedPotentialTable) nodeRelation.getValues()).getValues();
	   } else {
	      values = ((PotentialTable) nodeRelation.getValues()).getValues();
         }//Fin introducido por jruiz

	   // For every column, looks for the cell that contain the
	   // highest probability. The states corresponding to this value
	   // will be set as the deterministic value.

	   for (int i=0; i<cols; i++) {
	      int maxPosition = 0;

	      if (nodeRelation.getValues().getClass() != CanonicalPotential.class) {
	         max = 0.0;
	         total = 0.0;
	         for (int j=0; j<numStates; j++) {
	            if (values[i+j*cols]>max) {
	               max = values[i+j*cols];
	               total = total + max;
	               maxPosition = j;
	            }
	         }
	      }
	      else {
		max = 0.0;
		total = 0.0;
		boolean exit = false;
		int par = 0;
	        int sub_total = 0;

		while (!exit) {
		  if (i<sub_total+((FiniteStates) parents.elementAt(par)).getNumStates()) {
		    exit = true;
		  }
		  else {
		    sub_total = sub_total+((FiniteStates) parents.elementAt(par)).getNumStates();
		    par++;
		  }

		  if (par==parents.size()) {
		    exit = true;
		  }
		}

		for (int j=0; j<((FiniteStates) node).getNumStates(); j++) {
		  if (par==parents.size()){
		    if (values[j+sub_total*((FiniteStates) node).getNumStates()]>max) {
		      max = values[j+sub_total*((FiniteStates) node).getNumStates()];
		      total = total + max;
		      maxPosition = j;
		    }
		  }
		  else {
		    if (values[i-sub_total+j*((FiniteStates) parents.elementAt(par)).getNumStates()+sub_total*((FiniteStates) node).getNumStates()]>max) {
		      max = values[i-sub_total+j*((FiniteStates) parents.elementAt(par)).getNumStates()+sub_total*((FiniteStates) node).getNumStates()];
		      total = total + max;
		      maxPosition = j;
		    }
		  }
		}
	      }

	      relationTable.setValueAt(v.elementAt(maxPosition), rows-1, i);
	   }
	}

	/**
	 * This method will be exectued when the probability radio
	 * button is selected. When this happens, its obtain the
	 * probabilities for the deterministics values, generate the
	 * correct table, and set a null cell editor.
	 */

	void probRadioButton_itemStateChanged(java.awt.event.ItemEvent event)
	{
	/*   if ((probRadioButton.isSelected()) && (!optionsDisabled)) {
	      relationTable.editingStopped(new ChangeEvent(this));
	      panelSetEnabled(panel3,false);
	      panelSetEnabled(panel2,true);

	      if (!general) {
		 panelSetEnabled(panel4,true);
	      }

	      if ((nodeRelation.getValues().getClass() == CanonicalPotential.class) &&
		  ((((CanonicalPotential) nodeRelation.getValues()).getFunction().getName().equals("Or")) ||
		  ((CanonicalPotential) nodeRelation.getValues()).getFunction().getName().equals("CausalMax"))) {
		 panelSetEnabled(orTypePanel,true);
	      }

	      if (valuesMode) {
                transformToProbabilities(nodeRelation);
	      }

	      valuesMode = false;
	      nodeRelation.setDeterministic(false);
	      statesHasChanged = true;

	      if (!general) {
		generateCanonicalTable(nodeRelation);
	      }
	      else {
		generateNormalTable(nodeRelation);
	      }

	      tcm = relationTable.getColumnModel();

	      for (int i=0; i<relationTable.getColumnCount(); i++) {
	         TableColumn column = tcm.getColumn(i);
	         column.setCellEditor(null);
	      }
	   }*/
		changeInProbButton(probRadioButton);
	}

	void changeInProbButton(JRadioButton probButton){
			//Relation rel;
			int kind;
			
			kind = this.node.getKindOfNode();
						
			if (kind == Node.CHANCE){
				//rel = nodeRelation;
			}
			else if (kind == Node.DECISION){
				//rel = ((IDiagram)(this.bayesNet)).getForcedPolicies().get(node);
			}
			else{
				System.out.println("Error in method changeInProbButton of class EditVariableDialog. Node should be chance or decision");
			}
		
		
		   if ((probButton.isSelected()) && (!optionsDisabled)) {
			      relationTable.editingStopped(new ChangeEvent(this));
			      panelSetEnabled(panel3,false);
			      panelSetEnabled(panel2,true);

			      if (!general) {
				 panelSetEnabled(panel4,true);
			      }

			      if ((nodeRelation!=null)&&((nodeRelation.getValues().getClass() == CanonicalPotential.class) &&
				  ((((CanonicalPotential) nodeRelation.getValues()).getFunction().getName().equals("Or")) ||
				  ((CanonicalPotential) nodeRelation.getValues()).getFunction().getName().equals("CausalMax")))) {
				 panelSetEnabled(orTypePanel,true);
			      }

			      if (valuesMode) {
		                transformToProbabilities(nodeRelation);
			      }

			      valuesMode = false;
			      nodeRelation.setDeterministic(false);
			      statesHasChanged = true;

			      if (!general) {
				generateCanonicalTable(nodeRelation);
			      }
			      else {
				generateNormalTable(nodeRelation);
			      }

			      tcm = relationTable.getColumnModel();

			      for (int i=0; i<relationTable.getColumnCount(); i++) {
			         TableColumn column = tcm.getColumn(i);
			         column.setCellEditor(null);
			      }
			   }
	}
	
	void optimalRadioButton_itemStateChanged(java.awt.event.ItemEvent event){
		if (optimalRadioButtonDecs.isSelected()){
			showPanelsActivatedButtonOptimal(true);
		}
	}
	
	/**
	 * This method will be exectued when the probability radio
	 * button is selected. When this happens, its obtain the
	 * probabilities for the deterministics values, generate the
	 * correct table, and set a null cell editor.
	 */

	void probRadioButtonDecs_itemStateChanged(java.awt.event.ItemEvent event)
	{
		if (probRadioButtonDecs.isSelected()){
			showPanelsActivatedButtonOptimal(false);
			
		}
		changeInProbButton(probRadioButtonDecs);
	
	}	
	
	
	
	void detRadioButtonDecs_itemStateChanged(java.awt.event.ItemEvent event)
	{
		if (detRadioButtonDecs.isSelected()){
			showPanelsActivatedButtonOptimal(false);
			
		}
		changeInDetButton(detRadioButtonDecs,probRadioButtonDecs);
	}
	
	
	
	/**
	 *
	 * @param b
	 */
	private void showPanelsActivatedButtonOptimal(boolean b) {
		// TODO Auto-generated method stub
		   typeRelationButton.setVisible(!b);
           typeRelationLabel.setVisible(!b);
           panel1.setVisible(false);
           panel2.setVisible(!b);
           panel3.setVisible(!b);
           panel4.setVisible(!b);
           orTypePanel.setVisible(!b);
           //relationScrollPane.setVisible(!b);
           tablePanel.setVisible(!b);
           panelSVNode.setVisible(false);
           
           //panelOptProbDet.setVisible(true);
           
           
	}

	/**
	 * Invoked when the Henrion's radio button is selected. This method
	 * transform the Diez's parameter displayed in the table into the
	 * Henrion parameter's.
	 */

	void henrionRadioButton_itemStateChanged(java.awt.event.ItemEvent event)
	{
	   if ((henrionRadioButton.isSelected()) && (!optionsDisabled)) {
	      relationTable.editingStopped(new ChangeEvent(this));
	      getValues(nodeRelation, false);

	      optionsDisabled = true;
	      henrionRadioButton.setSelected(true);
	      optionsDisabled = false;

	      if ((((CanonicalPotential) nodeRelation.getValues()).isHenrionVSDiez().equals("Diez")) ||
		  (((CanonicalPotential) nodeRelation.getValues()).isHenrionVSDiez().equals(""))) {
	        ((CanonicalPotential) nodeRelation.getValues()).diez2Henrion(((FiniteStates) node).getNumStates());
		((CanonicalPotential) nodeRelation.getValues()).setHenrionVSDiez("Henrion");
	      }

            //Modificado por jruiz
	      if (nodeRelation.getValues().getClass() == PotentialTable.class ||
                nodeRelation.getValues().getClass() == GeneralizedPotentialTable.class){
		general = true;
	      }//Fin modificado por jruiz

	      else {
		general = false;
	      }

	      fillValues(nodeRelation);
	   }
	}

	/**
	 * Invoked when the Diez's radio button is selected. This method
	 * transform the Henrion's parameter displayed in the table into the
	 * Diez parameter's.
	 */

	void diezRadioButton_itemStateChanged(java.awt.event.ItemEvent event)
	{
	   if ((diezRadioButton.isSelected()) && (!optionsDisabled)) {
	      relationTable.editingStopped(new ChangeEvent(this));
	      getValues(nodeRelation, false);

	      optionsDisabled = true;
	      diezRadioButton.setSelected(true);
	      optionsDisabled = false;

	      if (((CanonicalPotential) nodeRelation.getValues()).isHenrionVSDiez().equals("Henrion")) {
                ((CanonicalPotential) nodeRelation.getValues()).henrion2Diez(((FiniteStates) node).getNumStates());
		((CanonicalPotential) nodeRelation.getValues()).setHenrionVSDiez("Diez");
	      }

            //Modificado por jruiz
	      if (nodeRelation.getValues().getClass() == PotentialTable.class ||
                nodeRelation.getValues().getClass() == GeneralizedPotentialTable.class){
		general = true;
	      }//Fin modificado por jruiz

	      else {
		general = false;
	      }

	      fillValues(nodeRelation);
	  }
	}

	/**
	 * Check that the nodes contained in the vector parents and the
	 * node given as parameter are have two states
	 */

	public boolean nodesAreBinary (Vector parents) {
	   boolean notBinary = false, notPresentAbsent = false;
	   int reply = 0, i=0;

	   if (states.size()!=2)
	      notBinary = true;

          while ((!notBinary) && (!notPresentAbsent) && (i<parents.size())) {
	    FiniteStates fn = (FiniteStates) parents.elementAt(i);
	    if ((fn.getNumStates()!=2) && (fn.getStates()!=null))
              notBinary = true;
	    else {
              String state1, state2;
              if (!fn.getName().equals(node.getName())) {
               state1 = fn.getState(0);
               state2 = fn.getState(1);
              }
              else {
               state1 = (String) states.elementAt(0);
               state2 = (String) states.elementAt(1);
              }

              if ((state1!=(String) data[0][1]) ||
                (state2!=(String) data[1][1])) {
               if ((state1!=(String) data2[0][1]) ||
                  (state2!=(String) data2[1][1])) {
                  if ((state1!=(String) data3[0][1]) ||
                     (state2!=(String) data3[1][1])) {
                        notPresentAbsent = true;
                  }
               }
              }
	    }
	    i++;
	  }

	  if (notBinary) {
	    ShowMessages.showMessageDialog(ShowMessages.OR_ONLY_BINARY, JOptionPane.ERROR_MESSAGE);
	    typeRelationButton.setText(previousRelationType);
	    return false;
	  }

	  if (notPresentAbsent) {
		   Object[] options = { localize(dialogBundle,"Yes.label"),
		                        localize(dialogBundle,"No.label") };
	    reply = ShowMessages.showOptionDialog(ShowMessages.OR_PRESENT_ABSENT,
                                       JOptionPane.WARNING_MESSAGE,
                                       options, 1);
	    if (reply == 1) {
	      typeRelationButton.setText(previousRelationType);
              return false;
	    }
	  }

	  return true;
	}

	private void selectAllRadioButton (boolean b) {
	   optionsDisabled = true;
	   allRadioButton.setSelected(b);
	   optionsDisabled = false;
	}

	/**
	 * Controls the action performed whe the button to choose the
	 * type of relation is selected
	 */

	void typeRelationButton_actionPerformed(java.awt.event.ActionEvent event)
	{
	   if (optionsDisabled)
	      return;

	   statesHasChanged = true;
	   relationTable.editingStopped(new ChangeEvent(this));

         //Modificado por jruiz
	   if (nodeRelation.getValues().getClass() == PotentialTable.class ||
             nodeRelation.getValues().getClass() == GeneralizedPotentialTable.class) {
	    general = true;
	   }//Fin modificado por jruiz

	   else {
	    general = false;
	   }

	   previousRelationType = typeRelationButton.getText();
       
       if (nodeRelation.getValues().getClass()== UtilityPotential.class)
       {
           //The kind of the Relation is Add or Multiply
	   		if (utilityCombinationGroup.getSelection()==addRadioButton)
	   		{
	   			((UtilityPotential)(nodeRelation.getValues())).setFunction("Sum");
				typeRelationButton.setText(localize(dialogBundle,"EditVariable.relationDialogAdd.label"));
	   		}
	   		else if (utilityCombinationGroup.getSelection()==multiplyRadioButton)
			{
				((UtilityPotential)(nodeRelation.getValues())).setFunction("Product");
				typeRelationButton.setText(localize(dialogBundle,"EditVariable.relationDialogMultiply.label"));
			}
			else
			{
				System.out.println("Error! There are only two buttons: \"Sum\" and \"Product\"");
				return;
			}
	   }
		else
           showrelationDialog();
	}

	void setValuesModeEdition(boolean valMode) {
	  if (valMode) {
	    getValuesFromProbabilities();
	    JComboBox comboBox = new JComboBox();
	    for (int i=0; i<valuesTable.getRowCount(); i++) {
	      comboBox.addItem(valuesTable.getValueAt(i, 1));
	      //comboBox.addItem(((FiniteStates) node).getState(i));
	    }

	    tcm = relationTable.getColumnModel();

	    // Set the combo box created as the cell editor
	    for (int i=0; i<relationTable.getColumnCount(); i++) {
	      TableColumn column = tcm.getColumn(i);
	      column.setCellEditor(new DefaultCellEditor(comboBox));
	    }
	  }
	}

	void okParentsButton_actionPerformed (java.awt.event.ActionEvent event) {

	   /* To set */
	   int[] theList = parentsDialogTable.getSelectedRows();
	   /*Vector theNames = new Vector();
           for (int i=0; i<theList.length; i++) {
             for (int j=0; j<bayesNet.getNodeList().size(); j++) {
		if (((Node) bayesNet.getNodeList().elementAt(j)).getTitle().equals(parentsDialogTable.getValueAt(theList[i],0))) {
		   theNames.add(((Node) bayesNet.getNodeList().elementAt(j)).getName());
	           break;
                }
             }
           }*/
	   for (int i=0; i<theList.length; i++) {
             //LinkList llp = node.getParents();
             //LinkList llc = bayesNet.getNode((String) parentsDialogTable.getValueAt(theList[i],0)).getChildren();
	     try {
	       bayesNet.createLink(bayesNet.getNode((String) parentsDialogTable.getValueAt(theList[i],0)),node);
             } catch (InvalidEditException iee) {};
             parents.add(bayesNet.getNode((String) parentsDialogTable.getValueAt(theList[i],0)));
             //Link theLink = new Link(node,bayesNet.getNode((String) parentsDialogTable.getValueAt(theList[i],0)));
             //llp.insertLink(theLink);
             //llc.insertLink(theLink);
             //((Node) node).setParents(llp);
             //((Node) bayesNet.getNode((String) parentsDialogTable.getValueAt(theList[i],0))).setChildren(llc);
             /* parent node and present node have to be updated */
             /* Perhaps not: only relation.... */
             if (node.getKindOfNode() != Node.DECISION) {
                NodeList nl = nodeRelation.getVariables();
                Vector vl = nl.toVector();
                vl.add(bayesNet.getNode((String) parentsDialogTable.getValueAt(theList[i],0)));
                nodeRelation = new Relation(vl);
             }
           }
           if (node.getKindOfNode() != Node.DECISION) {
             statesHasChanged = true;
             general = true;
             generateNormalTable(nodeRelation);
           }
           for (int i=0; i<theList.length; i++) {
             parentsModel.addRow(parentsEmptyRow);
             parentsTable.setValueAt(parentsDialogTable.getValueAt(theList[i],0),parentsTable.getRowCount()-1, 0);
             parentsTable.setValueAt(parentsDialogTable.getValueAt(theList[i],1),parentsTable.getRowCount()-1, 1);
           }
           for (int i=theList.length-1; i>=0; i--) {
	     parentsDialogModel.removeRow(theList[i]);
           }
           parentsDialogTable.clearSelection();
	   parentsDialog.dispose();
	}

	void cancelParentsButton_actionPerformed (java.awt.event.ActionEvent event) {
	   /* To set */
           parentsDialogTable.clearSelection();
	   parentsDialog.dispose();

	}

        public void returnButton_actionPerformed (java.awt.event.ActionEvent event) {
          Elvira.getElviraFrame().disableReturnToolbar();
          Selection sel = Elvira.getElviraFrame().getCurrentEditorPanel().getSelection();
          for (int i=0; i<sel.numberOfNodes(); i++) {
            for (int j=0; j<parentsDialogTable.getRowCount(); j++) {
              if (((String) parentsDialogTable.getValueAt(j,0)).equals(sel.getNode(i).getName())) {
                parentsDialogTable.changeSelection(j,0,true,false);
              }
            }
          }
          okParentsButton_actionPerformed((java.awt.event.ActionEvent) null);
          this.show();
        }

	/**
	 * Actions taken when the relationDialog OK button is pressed
	 */
//****************************************************************************************************
//****************************************************************************************************
//****************************************************************************************************        
	void okRelationDialogButton_actionPerformed (java.awt.event.ActionEvent event) {

	    nodeRelation.setComment("");
	    relationDialog.dispose();
	    lastTabbedPane = 3;
	    String theLabel="";
	    /*For the edition of probability trees*/
	    if (treeRadioButton.isSelected()){
              isTree = true;
              //System.out.println("Arbol seleccionado. Anterior = " + previousRelationType);
//              if (!theLabel.equals(previousRelationType)) {
                System.out.println("Cambiamos relationTypePanel a treePanel");
              /*  GridBagConstraints c = ((GridBagLayout) treePanel.getLayout()).getConstraints(relationTypePanel);
                c = setGridBagConstraints (0,0,2,1,0.7,0.15);
                ((GridBagLayout)treePanel.getLayout()).setConstraints(relationTypePanel, c);
                treePanel.add(relationTypePanel);
  //           }else{*/
                  typeRelationButton.setText(
                  localize(dialogBundle,"EditVariable.relationDialogProbabilityTree.label"));
                  typeRelationButton.setVisible(true);
                  typeRelationLabel.setVisible(true);
                  GridBagConstraints c = ((GridBagLayout) treePanel.getLayout()).getConstraints(relationTypePanel);
                  c = setGridBagConstraints (0,0,2,1,0.7,0.15);
                  ((GridBagLayout)treePanel.getLayout()).setConstraints(relationTypePanel, c);
                  treePanel.add(relationTypePanel);                  
                  ((CardLayout)relationPanelCard.getLayout()).show(relationPanelCard,"TREE");                  
    //         }
            }
            else{
              isTree = false;
              ((CardLayout)relationPanelCard.getLayout()).show(relationPanelCard,"TABLE");
              theLabel = localize(dialogBundle,"EditVariable.relationDialogProbabilityTree.label");
              //System.out.println("Otro tipo. Anterior = " + previousRelationType);
              if (theLabel.equals(previousRelationType)) {
                //System.out.println("Cambiamos relationTypePanel a relationPanel");
                GridBagConstraints c = ((GridBagLayout) relationPanel.getLayout()).getConstraints(relationTypePanel);
                c = setGridBagConstraints (0,0,2,1,0.7,0.15);
                ((GridBagLayout)relationPanel.getLayout()).setConstraints(relationTypePanel, c);
                relationPanel.add(relationTypePanel);

                oldStatesNumber = -1;
              }
            }
            /**/

	    if (generalRadioButton.isSelected() == true) {
	      theLabel = localize(dialogBundle,"EditVariable.relationDialogGeneral.label");
	      if (theLabel.equals(previousRelationType)) {
		general = true;
		nodeRelation.setComment("");
		if (!nodeRelation.isDeterministic()) {
		  generateNormalTable(nodeRelation);
		}
		else {
		  if (valuesMode) {
		    transformToProbabilities(nodeRelation);
		    generateNormalTable(nodeRelation);
		    setValuesModeEdition(valuesMode);
		  }
		  else {
		    getValues(nodeRelation,true);
		    generateNormalTable(nodeRelation);
		  }
		}
		return;
	      }

	      if (oldStatesNumber != valuesTable.getRowCount()) {
		oldStatesNumber = valuesTable.getRowCount();
		int newtotal = valuesTable.getRowCount();
		for (int i=0; i<parents.size(); i++) {
		   newtotal=newtotal*((FiniteStates) parents.elementAt(i)).getNumStates();
		}
		general = true;
	        PotentialTable poti = new PotentialTable(nodeRelation.getValues().getVariables());
		nodeRelation = new Relation(nodeRelation.getVariables().toVector());
	        double[] newvalues = new double[(int) newtotal];
		for (int j=0; j<newtotal; j++) {
		  newvalues[j]=(double) 1/valuesTable.getRowCount();
		}
	        poti.setValues(newvalues);
	        nodeRelation.setValues(poti);
		typeRelationButton.setText(theLabel);
		previousRelationType = theLabel;
	        oldStatesNumber = valuesTable.getRowCount();
		lockedColumns = false;
		nodeRelation.setKind(Relation.POTENTIAL);
	        nodeRelation.setComment("");
	        enableRelationOptions();
	        generateNormalTable(nodeRelation);
	        setValuesModeEdition(valuesMode);
		return;
	      }

	      lockedColumns = false;
	      if (!nodeRelation.isDeterministic()) {
		if (!cptRadioButton.isSelected()) {
		  getValues(nodeRelation,false);
		}
	      }
	      else {
		if (valuesMode) {
		  transformToProbabilities(nodeRelation);
		}
		else {
		  getValues(nodeRelation,true);
		}
	      }
	      for (int i=0; i<((CanonicalPotential) nodeRelation.getValues()).getArguments().size(); i++) {
		String relName = ((CanonicalPotential) nodeRelation.getValues()).getStrArgument(i);
	        for (int k=0; k<bayesNet.getRelationList().size(); k++) {
		  if (bayesNet.getRelationList().elementAt(k) != null) {
		    if (((Relation) bayesNet.getRelationList().elementAt(k)).getName().equals(relName)) {
		      bayesNet.getRelationList().removeElementAt(k);
		    }
		  }
	        }
	      }
	      PotentialTable pt = (PotentialTable) ((CanonicalPotential) nodeRelation.getValues()).getCPT();
	      pt.setVariables(((CanonicalPotential) nodeRelation.getValues()).getVariables());
	      general = true;
	      nodeRelation.setKind(Relation.POTENTIAL);
	      nodeRelation.setComment("");
	      nodeRelation.setValues(pt);
	      enableRelationOptions();
	      generateNormalTable(nodeRelation);
	      setValuesModeEdition(valuesMode);
	    }
	    else if (orRadioButton.isSelected() == true) {
	      theLabel = localize(dialogBundle,"EditVariable.relationDialogOr.label");
	      if ((theLabel.equals(previousRelationType)) && !(statesHasChanged)) {
		return;
	      }
	      if (!nodeRelation.isDeterministic()) {
		//getValues(nodeRelation,false);
	      }
	      else {
		if (!valuesMode) {
		  getValues(nodeRelation,true);
		}
		else {
		  transformToProbabilities(nodeRelation);
		}
	      }
	      nodeRelation.setKind(Relation.OR);
	      nodeRelation.setValues(new CanonicalPotential(nodeRelation.getValues().getVariables()));
	      enableRelationOptions();
	      ((CanonicalPotential) nodeRelation.getValues()).setFunction("Or");
	      createRelationStructure(nodeRelation, "Or", true);
	      generateCanonicalTable(nodeRelation);
	      setValuesModeEdition(valuesMode);
	    }
	    else if (causalMaxRadioButton.isSelected() == true) {
	      theLabel = localize(dialogBundle,"EditVariable.relationDialogCausalMax.label");
	      if ((theLabel.equals(previousRelationType)) && !(statesHasChanged)) {
		return;
	      }
	      nodeRelation.setKind(Relation.CAUSAL_MAX);
	      nodeRelation.setValues(new CanonicalPotential(nodeRelation.getValues().getVariables()));
	      enableRelationOptions();
	      ((CanonicalPotential) nodeRelation.getValues()).setFunction("CausalMax");
	      createRelationStructure(nodeRelation, "CausalMax", true);
	      generateCanonicalTable(nodeRelation);
	      setValuesModeEdition(valuesMode);
	    }
	    else if (generalizedMaxRadioButton.isSelected () == true) {
	      theLabel = localize(dialogBundle,"EditVariable.relationDialogGeneralizedMax.label");
	      if ((theLabel.equals(previousRelationType)) && !(statesHasChanged)) {
		return;
	      }
	      nodeRelation.setKind(Relation.GENERALIZED_MAX);
	      nodeRelation.setValues(new CanonicalPotential(nodeRelation.getValues().getVariables()));
	      enableRelationOptions();
	      ((CanonicalPotential) nodeRelation.getValues()).setFunction("GeneralizedMax");
	      createRelationStructure(nodeRelation, "GeneralizedMax", true);
	      generateCanonicalTable(nodeRelation);
	      setValuesModeEdition(valuesMode);
	    }
	    else if (andRadioButton.isSelected() == true) {
	      theLabel = localize(dialogBundle,"EditVariable.relationDialogAnd.label");
	      if ((theLabel.equals(previousRelationType)) && !(statesHasChanged)) {
		return;
	      }
	      nodeRelation.setKind(Relation.AND);
	      nodeRelation.setValues(new CanonicalPotential(nodeRelation.getValues().getVariables()));
	      enableRelationOptions();
	      ((CanonicalPotential) nodeRelation.getValues()).setFunction("And");
	      createRelationStructure(nodeRelation, "And", true);
	      generateCanonicalTable(nodeRelation);
	      setValuesModeEdition(valuesMode);
	    }
	    else if (minRadioButton.isSelected() == true) {
	      theLabel = localize(dialogBundle,"EditVariable.relationDialogMin.label");
	      if ((theLabel.equals(previousRelationType)) && !(statesHasChanged)) {
		return;
	      }
	      nodeRelation.setKind(Relation.MIN);
	      nodeRelation.setValues(new CanonicalPotential(nodeRelation.getValues().getVariables()));
	      enableRelationOptions();
	      ((CanonicalPotential) nodeRelation.getValues()).setFunction("Min");
	      createRelationStructure(nodeRelation, "Min", true);
	      generateCanonicalTable(nodeRelation);
	      setValuesModeEdition(valuesMode);
	    }
	    else if (xorRadioButton.isSelected() == true) {
	      /*theLabel = localize(dialogBundle,"EditVariable.relationDialogXor.label");
	      if ((theLabel.equals(previousRelationType)) && !(statesHasChanged)) {
		return;
	      }
	      nodeRelation.setKind(Relation.XOR);
	      nodeRelation.setDeterministic(true);
	      nodeRelation.setValues(new CanonicalPotential(nodeRelation.getValues().getVariables()));
	      enableRelationOptions();
	      ((CanonicalPotential) nodeRelation.getValues()).setFunction("Xor");
	      createRelationStructure(nodeRelation, "Xor", true);
	      valuesMode = false;
	      //getValuesFromProbabilities(); ¿?
	      generateCanonicalTable(nodeRelation);
	      //setValuesModeEdition(valuesMode); ¿?*/
	      //System.out.println("XOR canonical model not implemented!!!!!");
	    }

	    if (oldStatesNumber != valuesTable.getRowCount()) {
	      oldStatesNumber = valuesTable.getRowCount();
	    }
	    optionsDisabled = true;
	    canRadioButton.setSelected(true);
	    optionsDisabled = false;
	    typeRelationButton.setText(theLabel);
	    newRelation = nodeRelation;
	    previousRelationType = theLabel;
	    //if (node.getKindOfNode() != Node.DECISION) {
	      substituteRelationOrForcedPolicy(newRelation);
	    //}

	    /* TO VERIFY */
	    if (debug) {
	      if (!general) {
		System.out.println("Relations in bayesNet...");
		RelationList rl = new RelationList();
		rl.setRelations(bayesNet.getRelationList());
		rl.print();
		System.out.println("Relation as modified...");
		nodeRelation.print();
		System.out.println("Relations stored in arguments in nodeRelation: ");
		System.out.println("Number of relations: "+((CanonicalPotential) nodeRelation.getValues()).getArgumentsSize());
		for (int i=0; i<((CanonicalPotential) nodeRelation.getValues()).getArgumentsSize(); i++) {
		  System.out.println(((CanonicalPotential) nodeRelation.getValues()).getStrArgument(i));
		  ((PotentialTable) ((CanonicalPotential) nodeRelation.getValues()).getArgumentAt(i)).print();
		}
	      }
	    }
	    /* END TO VERIFY */
	}

	void cancelRelationDialogButton_actionPerformed (java.awt.event.ActionEvent event) {
	    relationDialog.dispose();
	    editVarTabbedPane.setSelectedIndex(lastTabbedPane);
	}

	/**
	 * Makes the necessary tasks to set the canonical model into the values
	 * field and so on
	 */

	void createRelationStructure(Relation relation, String whatKind, boolean isNew) {
	    Relation r;
	    String s;
	    RelationList rl = new RelationList();
	    Vector v, relist = new Vector();
	    PotentialTable pottable;

	    relist.add(relation);

	    for (int i=0; i<parents.size(); i++) {
	      r = new Relation();
	      r.setActive(false);
	      v = new Vector();
	      v.addElement(node);
	      //v.addElement((Node) parents.elementAt(i));
	      boolean exit = false;
	      int ind = 0;
	      while (!exit) {
		if (((FiniteStates) parents.elementAt(i)).getName().equals(((FiniteStates) nodeRelation.getValues().getVariables().elementAt(ind)).getName())) {
		  exit = true;
		}
		else {
		  ind++;
		}
	      }
	      v.addElement(nodeRelation.getValues().getVariables().elementAt(ind));
	      pottable = new PotentialTable(v);

	      /* OR kind */
	      if (whatKind.equals("Or")) {

		if (((FiniteStates) node).getNumStates() != 2)
		  System.out.println("Node should be binary!!! States: "+((FiniteStates) node).getNumStates());

		if (((FiniteStates) parents.elementAt(i)).getNumStates() != 2)
		  System.out.println("Parent nodes should be binary!!! States: "+((FiniteStates) parents.elementAt(i)).getNumStates()+" for parent "+i);

		for (int k=0; k<((FiniteStates) parents.elementAt(i)).getNumStates()-1; k++)
		{

		  for (int j=0; j<k; j++) {
		    if (j>((FiniteStates) node).getNumStates()-1) {
		      break;
		    }
		    pottable.setValue(j*((FiniteStates) parents.elementAt(i)).getNumStates()+k, 0.0);
		  }

		  for (int j=k+1; j<((FiniteStates) node).getNumStates(); j++) {
		    if (j>((FiniteStates) node).getNumStates()-1) {
		      break;
		    }
		    pottable.setValue(j*((FiniteStates) parents.elementAt(i)).getNumStates()+k, 0.0);
		  }

		  if (k>(((FiniteStates) node).getNumStates()-1)) {
		    pottable.setValue((((FiniteStates) node).getNumStates()-1)*((FiniteStates) parents.elementAt(i)).getNumStates()+k,1.0);
		  }
		  else {
		    pottable.setValue(k*((FiniteStates) parents.elementAt(i)).getNumStates()+k, 1.0);
		  }
		}

		for (int j=0; j<((FiniteStates) node).getNumStates()-1; j++) {
		  pottable.setValue((((FiniteStates) parents.elementAt(i)).getNumStates())*(j+1)-1,0.0);
		}

		pottable.setValue(((FiniteStates) node).getNumStates()*(((FiniteStates) parents.elementAt(i)).getNumStates())-1,1.0);
	      }
	      /* END OR kind */
	      /* CAUSAL MAX kind */
	      else if (whatKind.equals("CausalMax")) {

		for (int k=0; k<((FiniteStates) parents.elementAt(i)).getNumStates()-1; k++)
		{

		  for (int j=0; j<k; j++) {
		    if (j>((FiniteStates) node).getNumStates()-1) {
		      break;
		    }
		    pottable.setValue(j*((FiniteStates) parents.elementAt(i)).getNumStates()+k, 0.0);
		  }

		  for (int j=k+1; j<((FiniteStates) node).getNumStates(); j++) {
		    if (j>((FiniteStates) node).getNumStates()-1) {
		      break;
		    }
		    pottable.setValue(j*((FiniteStates) parents.elementAt(i)).getNumStates()+k, 0.0);
		  }

		  if (k>(((FiniteStates) node).getNumStates()-1)) {
		    pottable.setValue((((FiniteStates) node).getNumStates()-1)*((FiniteStates) parents.elementAt(i)).getNumStates()+k,1.0);
		  }
		  else {
		    pottable.setValue(k*((FiniteStates) parents.elementAt(i)).getNumStates()+k, 1.0);
		  }
		}

		for (int j=0; j<((FiniteStates) node).getNumStates()-1; j++) {
		  pottable.setValue((((FiniteStates) parents.elementAt(i)).getNumStates())*(j+1)-1,0.0);
		}

		pottable.setValue(((FiniteStates) node).getNumStates()*(((FiniteStates) parents.elementAt(i)).getNumStates())-1,1.0);
	      }
	      /* END CAUSAL MAX kind */
	      /* GENERALIZED MAX kind */
	      else if (whatKind.equals("GeneralizedMax")) {

		for (int k=0; k<((FiniteStates) parents.elementAt(i)).getNumStates()-1; k++)
		{

		  for (int j=0; j<k; j++) {
		    if (j>((FiniteStates) node).getNumStates()-1) {
		      break;
		    }
		    pottable.setValue(j*((FiniteStates) parents.elementAt(i)).getNumStates()+k, 0.0);
		  }

		  for (int j=k+1; j<((FiniteStates) node).getNumStates(); j++) {
		    if (j>((FiniteStates) node).getNumStates()-1) {
		      break;
		    }
		    pottable.setValue(j*((FiniteStates) parents.elementAt(i)).getNumStates()+k, 0.0);
		  }

		  if (k>(((FiniteStates) node).getNumStates()-1)) {
		    pottable.setValue((((FiniteStates) node).getNumStates()-1)*((FiniteStates) parents.elementAt(i)).getNumStates()+k,1.0);
		  }
		  else {
		    pottable.setValue(k*((FiniteStates) parents.elementAt(i)).getNumStates()+k, 1.0);
		  }
		}

		for (int j=0; j<((FiniteStates) node).getNumStates()-1; j++) {
		  pottable.setValue((((FiniteStates) parents.elementAt(i)).getNumStates())*(j+1)-1,0.0);
		}

		pottable.setValue(((FiniteStates) node).getNumStates()*(((FiniteStates) parents.elementAt(i)).getNumStates())-1,1.0);
	      }
	      /* END GENERALIZED MAX kind */
	      /* AND kind */
	      else if (whatKind.equals("And")) {

		if (((FiniteStates) node).getNumStates() != 2)
		  System.out.println("Node should be binary!!! States: "+((FiniteStates) node).getNumStates());

		if (((FiniteStates) parents.elementAt(i)).getNumStates() != 2)
		  System.out.println("Parent nodes should be binary!!! States: "+((FiniteStates) parents.elementAt(i)).getNumStates()+" for parent "+i);

		for (int k=0; k<((FiniteStates) parents.elementAt(i)).getNumStates()-1; k++)
		{

		  for (int j=0; j<k; j++) {
		    if (j>((FiniteStates) node).getNumStates()-1) {
		      break;
		    }
		    pottable.setValue(j*((FiniteStates) parents.elementAt(i)).getNumStates()+k, 0.0);
		  }

		  for (int j=k+1; j<((FiniteStates) node).getNumStates(); j++) {
		    if (j>((FiniteStates) node).getNumStates()-1) {
		      break;
		    }
		    pottable.setValue(j*((FiniteStates) parents.elementAt(i)).getNumStates()+k, 0.0);
		  }

		  if (k>(((FiniteStates) node).getNumStates()-1)) {
		    pottable.setValue((((FiniteStates) node).getNumStates()-1)*((FiniteStates) parents.elementAt(i)).getNumStates()+k,1.0);
		  }
		  else {
		    pottable.setValue(k*((FiniteStates) parents.elementAt(i)).getNumStates()+k, 1.0);
		  }
		}

		for (int j=0; j<((FiniteStates) node).getNumStates()-1; j++) {
		  pottable.setValue((((FiniteStates) parents.elementAt(i)).getNumStates())*(j+1)-1,0.0);
		}

		pottable.setValue(((FiniteStates) node).getNumStates()*(((FiniteStates) parents.elementAt(i)).getNumStates())-1,1.0);
	      }
	      /* END AND kind */
	      /* MIN kind */
	      else if (whatKind.equals("Min")) {

		for (int k=0; k<((FiniteStates) parents.elementAt(i)).getNumStates()-1; k++)
		{

		  for (int j=0; j<k; j++) {
		    if (j>((FiniteStates) node).getNumStates()-1) {
		      break;
		    }
		    pottable.setValue(j*((FiniteStates) parents.elementAt(i)).getNumStates()+k, 0.0);
		  }

		  for (int j=k+1; j<((FiniteStates) node).getNumStates(); j++) {
		    if (j>((FiniteStates) node).getNumStates()-1) {
		      break;
		    }
		    pottable.setValue(j*((FiniteStates) parents.elementAt(i)).getNumStates()+k, 0.0);
		  }

		  if (k>(((FiniteStates) node).getNumStates()-1)) {
		    pottable.setValue((((FiniteStates) node).getNumStates()-1)*((FiniteStates) parents.elementAt(i)).getNumStates()+k,1.0);
		  }
		  else {
		    pottable.setValue(k*((FiniteStates) parents.elementAt(i)).getNumStates()+k, 1.0);
		  }
		}

		for (int j=0; j<((FiniteStates) node).getNumStates()-1; j++) {
		  pottable.setValue((((FiniteStates) parents.elementAt(i)).getNumStates())*(j+1)-1,0.0);
		}

		pottable.setValue(((FiniteStates) node).getNumStates()*(((FiniteStates) parents.elementAt(i)).getNumStates())-1,1.0);
	      }
	      /* END MIN kind */
	      /* XOR kind */
	      else if (whatKind.equals("Xor")) {

		for (int k=0; k<((FiniteStates) parents.elementAt(i)).getNumStates()-1; k++)
		{

		  for (int j=0; j<k; j++) {
		    if (j>((FiniteStates) node).getNumStates()-1) {
		      break;
		    }
		    pottable.setValue(j*((FiniteStates) parents.elementAt(i)).getNumStates()+k, 0.0);
		  }

		  for (int j=k+1; j<((FiniteStates) node).getNumStates(); j++) {
		    if (j>((FiniteStates) node).getNumStates()-1) {
		      break;
		    }
		    pottable.setValue(j*((FiniteStates) parents.elementAt(i)).getNumStates()+k, 0.0);
		  }

		  if (k>(((FiniteStates) node).getNumStates()-1)) {
		    pottable.setValue((((FiniteStates) node).getNumStates()-1)*((FiniteStates) parents.elementAt(i)).getNumStates()+k,1.0);
		  }
		  else {
		    pottable.setValue(k*((FiniteStates) parents.elementAt(i)).getNumStates()+k, 1.0);
		  }
		}

		for (int j=0; j<((FiniteStates) node).getNumStates()-1; j++) {
		  pottable.setValue((((FiniteStates) parents.elementAt(i)).getNumStates())*(j+1)-1,0.0);
		}

		pottable.setValue(((FiniteStates) node).getNumStates()*(((FiniteStates) parents.elementAt(i)).getNumStates())-1,1.0);
	      }
	      /* END XOR kind */

	      r.setVariables(v);
	      r.setValues(pottable); /* TO MODIFY: how to set the table? */
	      s = node.getName()+((FiniteStates) parents.elementAt(i)).getName();
	      r.setName(s);
	      ((CanonicalPotential) relation.getValues()).addArgument(s);
	      //((CanonicalPotential) relation.getValues()).setArgumentAt(pottable,i);
	      relist.add(r);
	      if (isNew) {
	        bayesNet.getRelationList().add(r); /* To review */
	      }
	    }

	    if (!whatKind.equals("Xor"))
	    {
	      /* Leaky */
	      r = new Relation();
	      r.setActive(false);
	      v = new Vector();
	      v.addElement(node);
	      pottable = new PotentialTable(v);
	      switch (relation.getKind()) {
		case Relation.OR:
		case Relation.CAUSAL_MAX:
		case Relation.GENERALIZED_MAX:
		  for (int i=0; i<((FiniteStates) node).getNumStates()-1; i++) {
		    pottable.setValue(i,0.0); /* Temporarily */
		  }
		  pottable.setValue(((FiniteStates) node).getNumStates()-1,1.0);
		  break;
		case Relation.AND:
		case Relation.MIN:
		  for (int i=1; i<((FiniteStates) node).getNumStates()-1; i++) {
		    pottable.setValue(i,0.0);
		  }
		  pottable.setValue(0,1.0);
		  break;
	      }
	      r.setVariables(v);
	      r.setValues(pottable); /* TO MODIFY: how to set the table? */
	      s = node.getName()+"Residual";
	      r.setName(s);
	      ((CanonicalPotential) relation.getValues()).addArgument(s);
	      //((CanonicalPotential) relation.getValues()).setArgumentAt(pottable,parents.size());
	      relist.add(r);
	      if (isNew) {
	        bayesNet.getRelationList().add(r); /* To review */
	      }
	    }

	    rl.setRelations(relist);
	    rl.repairPotFunctions(); /* To review */
	    if (debug) {
	      System.out.println("RelationList size: "+bayesNet.getRelationList().size());
	    }
	    /* ADDED */
	    /*Vector vars = new Vector();
	    vars.addElement(node);
	    for (int i=0; i<parents.size(); i++) {
	      vars.addElement(parents.elementAt(i));
	    }
	    relation.setVariables((Vector) vars);*/
	    /* END ADDED */

	    /* FOR VERIFICATION */
	    if (debug) {
	      System.out.println("Relations stored in provisional RelationList: ");
	      rl.print();
	      System.out.println("Relations stored in arguments: ");
	      System.out.println("Number of relations: "+((CanonicalPotential) relation.getValues()).getArgumentsSize());
	      for (int i=0; i<((CanonicalPotential) relation.getValues()).getArgumentsSize(); i++) {
	        System.out.println(((CanonicalPotential) relation.getValues()).getStrArgument(i));
	        ((PotentialTable) ((CanonicalPotential) relation.getValues()).getArgumentAt(i)).print();
	      }
	      //System.out.println("Variables stored in relation: ");
	      //relation.getVariables().print();
	    }
	    /* END FOR VERIFICATION */
	}

	/**
	 * Set the initial values for the relation options. This method
	 * will be called when the typeRelationButton change its value
	 */

	public void resetOptions(boolean b) {
	   optionsDisabled = true;

	   probRadioButton.setSelected(true);
	   if (b)
	      allRadioButton.setSelected(true);
	   else
	      indRadioButton.setSelected(true);
	   valRadioButton.setSelected(true);
	   canRadioButton.setSelected(true);
	   diezRadioButton.setSelected(true);
	   lockedColumns = false;
	   valuesMode = false;

	   optionsDisabled = false;
	}

	/**
	 * This method will be exectued when the probabilities radio
	 * button is selected. When this happens, it obtains the
	 * probabilities for the deterministics values, generate the
	 * correct table, and set a null cell editor.
	 */

	void probsRadioButton_itemStateChanged(java.awt.event.ItemEvent event)
	{
	   if ((probsRadioButton.isSelected()) && (!optionsDisabled)) {
	      relationTable.editingStopped(new ChangeEvent(this));

	      if (detRadioButton.isSelected()) {
		panelSetEnabled(panel2,true);

		int i;
	        JComboBox comboBox = new JComboBox();

	        //getValues(nodeRelation,true);

                transformToProbabilities(nodeRelation);
	        valuesMode = false;
	        statesHasChanged = true;

	        if (!general) {
		  generateCanonicalTable(nodeRelation);
	        }
	        else {
		  generateNormalTable(nodeRelation);
	        }

	        //getValuesFromProbabilities();

	        // Add the states to the combo box
		comboBox.addItem("0.0");
		comboBox.addItem("1.0");

	        tcm = relationTable.getColumnModel();

	        // Set the combo box created as the cell editor
	        for (i=0; i<relationTable.getColumnCount(); i++) {
	          TableColumn column = tcm.getColumn(i);
	          column.setCellEditor(new DefaultCellEditor(comboBox));
	        }
	      }
	      else {
                transformToProbabilities(nodeRelation);
	        valuesMode = false;
	        statesHasChanged = true;

	        //if (detRadioButton.isSelected())
	        //  panel2.setVisible(true);

	        if (!general)
		  generateCanonicalTable(nodeRelation);
	        else
		  generateNormalTable(nodeRelation);

	        tcm = relationTable.getColumnModel();

	        for (int i=0; i<relationTable.getColumnCount(); i++) {
	          TableColumn column = tcm.getColumn(i);
	          column.setCellEditor(null);
	        }
	      }
	   }
	}

	/* TO SET */

	void generalRadioButton_itemStateChanged(java.awt.event.ItemEvent event) {

	}

	void orRadioButton_itemStateChanged(java.awt.event.ItemEvent event) {

	}

	void causalMaxRadioButton_itemStateChanged(java.awt.event.ItemEvent event) {

	}

	void generalizedMaxRadioButton_itemStateChanged(java.awt.event.ItemEvent event) {

	}

	void andRadioButton_itemStateChanged(java.awt.event.ItemEvent event) {

	}

	void minRadioButton_itemStateChanged(java.awt.event.ItemEvent event) {

	}

	void xorRadioButton_itemStateChanged(java.awt.event.ItemEvent event) {

	}
        
        void addRadioButton_itemStateChanged(java.awt.event.ItemEvent event) {
            /*Probando esta línea*/ //nodeRelation.setKind(Relation.ADD);
            //((UtilityPotential) nodeRelation.getValues()).setFunction("Add");
        }
        
        void multiplyRadioButton_itemStateChanged(java.awt.event.ItemEvent event) {
            /*Probando esta línea*/ //nodeRelation.setKind(Relation.MULTIPLY);
            //((UtilityPotential) nodeRelation.getValues()).setFunction("Multiply");
        }

	/* END TO SET */

	/**
	 * To enable/disable radio buttons for the different panels in Relation Dialog
	 */

	void panelSetEnabled (javax.swing.JPanel thePanel, boolean enabled) {
	  int i, noc;

	  noc = thePanel.getComponentCount();

	  for (i=0; i<noc; i++) {
	    ((javax.swing.JRadioButton) thePanel.getComponent(i)).setEnabled(enabled);
	  }
	}

	/*TreeModelListener Added to implement the Probability Tree edition*/
	/**
	 * Manages the edition of probabitity trees
	 * also has auxiliar functions used by the saveTree and loadTree functions
	 */

	class MyTreeModelListener implements TreeModelListener{
		DefaultTreeModel treeModel;
		JComboBox combo;
		Vector listaVar;

		/**
		*  Creation method
		*/

		public MyTreeModelListener(DefaultTreeModel tree, JComboBox cb, Vector parents){
			treeModel = tree;
			combo = cb;
			listaVar = parents;
		}

		/**
		 * Checks if a variable is already present in the path back to the root of the tree
		 */

		private boolean previamenteSeleccionado(String variable, DefaultMutableTreeNode tnode){
			TreeNode[] vector = tnode.getPath();
			boolean encontrado = false;

	    		for(int i = 0 ;!encontrado && i < vector.length -1; i++){
					//(System.out.println(quitaComentarios((DefaultMutableTreeNode)vector[i]));
					if(quitaComentarios((DefaultMutableTreeNode)vector[i]).equals(variable))
						encontrado = true;
				}
				return encontrado;
		}

		/**
		 * From a node it takes away auxiliar commentaries and returns the variable or the value, that the node idenfifies
		 */

		public String quitaComentarios(DefaultMutableTreeNode nodo){
			String nombreNodo = nodo.toString();
			int aRecortar = 0;
			FiniteStates Padre;
			//System.out.println("Recortando \""+ nodo.toString() +"\" ->");
			if (!nodo.equals(treeModel.getRoot())){
				Padre = buscaVariable(quitaComentarios((DefaultMutableTreeNode)nodo.getParent()));
				if (opcionEdicionTree == 1)
					aRecortar = Padre.getState(nodo.getParent().getIndex(nodo)).length() + 2;
				else if (opcionEdicionTree == 2)
					aRecortar = Padre.getState(nodo.getParent().getIndex(nodo)).length() + Padre.getName().length();
				else if (opcionEdicionTree == 3)
					aRecortar = Padre.getState(nodo.getParent().getIndex(nodo)).length();
				//System.out.println(Padre.getState(nodo.getParent().getIndex(nodo)) +" - " +nodo.getParent().getIndex(nodo));
				//System.out.println("Longitud estado="+Padre.getState(nodo.getParent().getIndex(nodo)).length()+" + Longitud padre="
				//		+ Padre.getName().length());

				nombreNodo = nombreNodo.substring(aRecortar + 4);
				//System.out.println("se nos queda en : " + nombreNodo);
				return nombreNodo;
			}else{
				return nombreNodo;
			}
		}

		/**
		 * Checks if a string belongs to the list of elements present in the ComboBox that is the editor of the JTree
		 */

		private boolean estaEnLista(String elemento){
			boolean esta = false;
			int i = 0;
			while ((!esta) & (i < combo.getItemCount())){
				if(0 == elemento.compareTo((String)combo.getItemAt(i))){
					esta = true;
				}else{
					i++;
				}
			}
			return esta;
		}

		/**
		 * Searches for the bayesian network Node that corresponds to the name "seleccionada"
		 */

		public FiniteStates buscaVariable(String seleccionada){
			int i = 0;
			//System.out.println("Buscando... " + seleccionada);
			if (((FiniteStates)node).getName().compareTo(seleccionada) == 0){
				return (FiniteStates) node;
			}else{
				while(((FiniteStates)parents.elementAt(i)).getName().compareTo(seleccionada) != 0) i++;
				return (FiniteStates) parents.elementAt(i);
			}
		}

		/**
		 * Function called when a new value for a node has been accepted
		 */

		public void treeNodesChanged(TreeModelEvent e){

			// We set the feedback of the node to "" since is has been accepted
			feedBackTree.setText("");

			if (e.getPath() == null){
				treeModel.reload();
				return;
			}

			String nombreNodo, seleccionado;
			Double valor;
			DefaultMutableTreeNode tnode = (DefaultMutableTreeNode) (e.getTreePath().getLastPathComponent());
			DefaultMutableTreeNode childNode = new DefaultMutableTreeNode();
			FiniteStates varSeleccionada, grandfather;
			/*
                         * If the event lists children then the changed node is the child of
                         * the node we've already gotten. Otherwise, the changed node and the
                         * specified node are the same.
                         */
			 try{
				 int index = e.getChildIndices()[0];
				 tnode = (DefaultMutableTreeNode) (tnode.getChildAt(index));
			 }catch (NullPointerException exc){}

			 nombreNodo = String.valueOf(tnode.getUserObject());
			 if((nombreNodo.length() >0) &&(nombreNodo.charAt(0) == '(')){
				 nombreNodo = quitaComentarios(tnode);
			 }
			 treeChanged = true;
			 seleccionado = nombreNodo;

			 try{
				 // Hemos introducido un valor numérico
				 valor = Double.valueOf(nombreNodo);
				 tnode.removeAllChildren();
				 treeModel.reload(tnode);

				 if((valor.doubleValue() >= 0) && (valor.doubleValue() <= 1)){
					 if(tnode.getParent() != null){
						grandfather = buscaVariable(quitaComentarios((DefaultMutableTreeNode)tnode.getParent()));
						if (opcionEdicionTree == 1)
							tnode.setUserObject(quitaComentarios((DefaultMutableTreeNode)tnode.getParent()) + "=" +
						 			grandfather.getState(tnode.getParent().getIndex(tnode)) + " -> " + nombreNodo);
						else if (opcionEdicionTree == 2)
						 tnode.setUserObject("(" + quitaComentarios((DefaultMutableTreeNode)tnode.getParent()) + "=" +
						 			grandfather.getState(tnode.getParent().getIndex(tnode)) + ") " + nombreNodo);
						else if (opcionEdicionTree == 3)
						 tnode.setUserObject("(" + "=" +
						 			grandfather.getState(tnode.getParent().getIndex(tnode)) + ") " + nombreNodo);

						treeModel.reload(tnode);
					 }
				 }else{
					 ShowMessages.showMessageDialog(ShowMessages.PROB_NOT_ONE, JOptionPane.ERROR_MESSAGE);
					 if(tnode.getParent() != null){
						 grandfather = buscaVariable(quitaComentarios((DefaultMutableTreeNode)tnode.getParent()));
						 if (opcionEdicionTree == 1)
							 tnode.setUserObject(quitaComentarios((DefaultMutableTreeNode)tnode.getParent()) + "=" +
						 			grandfather.getState(tnode.getParent().getIndex(tnode)) + " -> ");
						 else if (opcionEdicionTree == 2)
							 tnode.setUserObject("(" + quitaComentarios((DefaultMutableTreeNode)tnode.getParent()) + "=" +
						 			grandfather.getState(tnode.getParent().getIndex(tnode)) + ") ");
						 else if (opcionEdicionTree == 3)
							 tnode.setUserObject("(" + "=" +
						 			grandfather.getState(tnode.getParent().getIndex(tnode)) + ") ");
					 }else{
						 tnode.setUserObject("");
					}
				 }
			 }catch(NumberFormatException q){
				 // Hemos introducido una variable
				 if(estaEnLista(seleccionado)){
					 //El valor del string seleccionado se corresponde con un nodo
					 if(!previamenteSeleccionado(seleccionado, tnode)){
						 tnode.removeAllChildren();
						 treeModel.reload(tnode);
						 varSeleccionada = buscaVariable(seleccionado);
						 for ( int i = 0 ; i < varSeleccionada.getNumStates() ; i++){
							 if (opcionEdicionTree == 1)
								 childNode = new DefaultMutableTreeNode(nombreNodo + "=" +
							 			varSeleccionada.getState(i) + " -> ");
							 else if (opcionEdicionTree == 2)
								 childNode = new DefaultMutableTreeNode("(" + nombreNodo + "=" +
							 				varSeleccionada.getState(i) + ") ");
							 else if (opcionEdicionTree == 3)
								 childNode = new DefaultMutableTreeNode("(" + "=" +
							 				varSeleccionada.getState(i) + ") ");
							 treeModel.insertNodeInto(childNode, tnode, tnode.getChildCount());
							 tree.scrollPathToVisible(new TreePath(childNode.getPath()));
						 }
						 if(tnode.getParent() != null){
							 grandfather = buscaVariable(quitaComentarios((DefaultMutableTreeNode)tnode.getParent()));
							 if (opcionEdicionTree == 1)
								 tnode.setUserObject(quitaComentarios((DefaultMutableTreeNode)tnode.getParent()) + "=" +
							 				grandfather.getState(tnode.getParent().getIndex(tnode)) + " -> " + nombreNodo);
							 else if (opcionEdicionTree == 2)
								 tnode.setUserObject("(" + quitaComentarios((DefaultMutableTreeNode)tnode.getParent()) + "=" +
							 				grandfather.getState(tnode.getParent().getIndex(tnode)) + ") " + nombreNodo);
							 else if (opcionEdicionTree == 3)
								 tnode.setUserObject("(" + "=" +
							 				grandfather.getState(tnode.getParent().getIndex(tnode)) + ") " + nombreNodo);
							 treeModel.reload(tnode);
						 }
					 }else{
						 ShowMessages.showMessageDialog(ShowMessages.PATH_REDUNDANT, JOptionPane.ERROR_MESSAGE);
						 tnode.removeAllChildren();
						 if(tnode.getParent() != null){
							 grandfather = buscaVariable(quitaComentarios((DefaultMutableTreeNode)tnode.getParent()));
							 if (opcionEdicionTree == 1)
								 tnode.setUserObject(quitaComentarios((DefaultMutableTreeNode)tnode.getParent()) + "=" +
							 				grandfather.getState(tnode.getParent().getIndex(tnode)) + " -> ");
							 else if (opcionEdicionTree == 2)
								 tnode.setUserObject("(" + quitaComentarios((DefaultMutableTreeNode)tnode.getParent()) + "=" +
							 				grandfather.getState(tnode.getParent().getIndex(tnode)) + ") ");
							 else if (opcionEdicionTree == 3)
								 tnode.setUserObject("(" + "=" +
							 				grandfather.getState(tnode.getParent().getIndex(tnode)) + ") ");
						 }else{
							 tnode.setUserObject("0");
						 }
						 treeModel.reload(tnode);
					 }
				 }else{
					 //No se ha introdudido una cadena que se corresponda con un nodo
					 tnode.removeAllChildren();
					 if(tnode.getParent() != null){
						 grandfather = buscaVariable(quitaComentarios((DefaultMutableTreeNode)tnode.getParent()));
						 if (opcionEdicionTree == 1)
							 tnode.setUserObject(quitaComentarios((DefaultMutableTreeNode)tnode.getParent()) + "=" +
							 				grandfather.getState(tnode.getParent().getIndex(tnode)) + " -> ");
						 else if (opcionEdicionTree == 2)
							 tnode.setUserObject("(" + quitaComentarios((DefaultMutableTreeNode)tnode.getParent()) + "=" +
						 				grandfather.getState(tnode.getParent().getIndex(tnode)) + ") ");
						 else if (opcionEdicionTree == 3)
							 tnode.setUserObject("(" + "=" +
						 				grandfather.getState(tnode.getParent().getIndex(tnode)) + ") ");
						 treeModel.reload(tnode);
					 }else{
						 tnode.setUserObject("0");
						 treeModel.reload(tnode);
					 }
				 }
			 }
		}
		public void treeNodesInserted(TreeModelEvent e){
		}
		public void treeNodesRemoved(TreeModelEvent e){
		}
		public void treeStructureChanged(TreeModelEvent e){
		}
	}

	/**
	 * 	Action Listener configured in the ComboBox editor for the JTree used to
	 *   setup the parameters that MiCaretListener uses
	 */

	public class MiActionListener implements ActionListener{
		JTextField tf;
		public void actionPerformed (ActionEvent e){
			tf = ((JTextField)comboNodes.getEditor().getEditorComponent());
			//System.out.println("Evento : seleccionamos " + tf.getText() + " en " + tf.getCaretPosition() + " de " + tf.getText().length());
			tf.setToolTipText(tf.getText());
			longitudTexto = tf.getText().length();
			edicionCorrecta = false;
		}
	}

	/**
	 *  	Class created to control that the caret of a JTextField stays at the end of the editing text. It is used for
	 *  the edition of the text of the nodes of the JTree.
	 *	 It also controls the feedBack TextField
	 */

	public class MiCaretListener implements CaretListener{
		public void caretUpdate(CaretEvent e){
			int posicionAct = e.getDot();
			JTextField tf = (JTextField) e.getSource();
			//System.out.println("Evento de posición = " + posicionAct);
			if((posicionAct > 0 ) && (posicionAct < longitudTexto)){
				try{
					tf.setCaretPosition(longitudTexto);
				}catch (IllegalArgumentException i){
				}
				//System.out.println("...cambiamos a = " + tf.getCaretPosition());
			}
			posicionAct = tf.getCaretPosition();
			if((posicionAct > 0 ) && (posicionAct < longitudTexto) && (!edicionCorrecta))
				tf.setCaretColor(Color.red);
			else
				tf.setCaretColor(Color.black);

			//System.out.println("...posicion final = " + tf.getCaretPosition());

			if (posicionAct == 0)
				edicionCorrecta = true;

			if (tree.isEditing()){
				int i;
				Object [] treePath = tree.getEditingPath().getPath();
				String texto = new String("");

				for(i = 0; i < treePath.length -1 ; i++){
					texto += treePath[i].toString() + " -> ";
				}

				texto += treePath[i].toString();

				feedBackTree.setText(texto);
			}

		}
	}

	/**/
	/**
	* Function used by loadTree to recursively load the ProbabilityTree into the JTree window
	* for editing Probability Trees
	*/

	private void generateTreeModelRecursive(ProbabilityTree ptree, DefaultTreeModel treeModel, DefaultMutableTreeNode treeNode){

	   DefaultMutableTreeNode child = new DefaultMutableTreeNode();
	   for(int i = 0 ; i < ptree.getChild().size() ; i++){
	      if (ptree.getChild(i).isProbab()){
				if (opcionEdicionTree == 1)
					child = new DefaultMutableTreeNode(ptree.getVar().getName() + "=" + ptree.getVar().getState(i) + " -> " +
							String.valueOf(ptree.getChild(i).getProb()));
								 //childNode = new DefaultMutableTreeNode(nombreNodo + "=" +
							 		//	varSeleccionada.getState(i) + " -> ");
				else if (opcionEdicionTree == 2)
					child = new DefaultMutableTreeNode("(" + ptree.getVar().getName() + "=" + ptree.getVar().getState(i) + ") " +
							String.valueOf(ptree.getChild(i).getProb()));
							//	 childNode = new DefaultMutableTreeNode("(" + nombreNodo + "=" +
							 //				varSeleccionada.getState(i) + ") ");
				else if (opcionEdicionTree == 3)
					child = new DefaultMutableTreeNode("(" + "=" + ptree.getVar().getState(i) + ") " +
							String.valueOf(ptree.getChild(i).getProb()));
				treeModel.insertNodeInto(child, treeNode, treeNode.getChildCount());
				tree.scrollPathToVisible(new TreePath(child.getPath()));
	         treeModel.reload(child);
	      }else{
				if (opcionEdicionTree == 1)
					child = new DefaultMutableTreeNode(ptree.getVar().getName() + "=" + ptree.getVar().getState(i) + " -> " +
							String.valueOf(ptree.getChild(i).getVar().getName()));
				else if (opcionEdicionTree == 2)
					child = new DefaultMutableTreeNode("(" + ptree.getVar().getName() + "=" + ptree.getVar().getState(i) + ") " +
							String.valueOf(ptree.getChild(i).getVar().getName()));
				else if (opcionEdicionTree == 3)
					child = new DefaultMutableTreeNode("(" + "=" + ptree.getVar().getState(i) + ") " +
							String.valueOf(ptree.getChild(i).getVar().getName()));
				//child = new DefaultMutableTreeNode(ptree.getVar().getState(i) + " - " + String.valueOf(ptree.getChild(i).getVar().getName()));
	         treeModel.insertNodeInto(child, treeNode, treeNode.getChildCount());
				generateTreeModelRecursive(ptree.getChild(i), treeModel, child);
	      }
	   }
	}

	/**
	* Function used to load the ProbabilityTree into the JTree window for editing Probabitity Trees
	*/

	private void loadTree(Relation R){

		if (R != null){
			PotentialTree potTree = (PotentialTree) R.getValues();
			ProbabilityTree ptree = potTree.getTree();
			DefaultMutableTreeNode root;
			if (!ptree.isProbab()){
				root = new DefaultMutableTreeNode(ptree.getVar().getName());
				treeModel.setRoot(root);
				generateTreeModelRecursive(ptree, treeModel, root);
			}else{
				root = new DefaultMutableTreeNode(String.valueOf(ptree.getProb()));
				treeModel.setRoot(root);
			}
		}else{
			DefaultMutableTreeNode root = new DefaultMutableTreeNode("");
			treeModel.setRoot(root);
		}
	}

	/**
	* Function used to save the edition of the Probability Tree into the relation of the node
	*/

	private int saveTree(Relation R, DefaultTreeModel treeModel, MyTreeModelListener miTreeModelListener){

	  	ProbabilityTree pTree;
		PotentialTree potTree;
		Double value;
		String nombreNodo, nombreHijo;
	   DefaultMutableTreeNode root, hijo;
		FiniteStates var;
		int correcto = 0;

		root = (DefaultMutableTreeNode)treeModel.getRoot();
		nombreNodo = root.toString();
		//System.out.println("Nombre del nodo = " + nombreNodo);
		try{
			value = Double.valueOf(nombreNodo);
			pTree = new ProbabilityTree(value.doubleValue());
		}catch (NumberFormatException q){
			var = miTreeModelListener.buscaVariable(nombreNodo);
			pTree = new ProbabilityTree(var);
			for(int i = 0 ; i < var.getNumStates(); i++){
				hijo = (DefaultMutableTreeNode) root.getChildAt(i);
				//System.out.println("Nodo "+hijo.toString()+" hijo de "+ root.toString());
				if(miTreeModelListener.quitaComentarios(hijo).equals("")){
					correcto = 1;
				}else{
					correcto = saveProbabilityTreeRecursive(treeModel, pTree, hijo, i, miTreeModelListener);
				}
			}
		}
		if (correcto == 0){
			potTree = new PotentialTree(pTree);
			R.setValues(potTree);
		}

		return correcto;
	}
	/**/


        private void createContinuousValuesPanel(){

	        //GridBagLayout gridbagvalue = new GridBagLayout();
		//cValuesPanel.setLayout(gridbagvalue);


            
            	cValuesPanel.setLayout(null);
		cValuesPanel.setBounds(100,100,311,311);
		cValuesPanel.setVisible(false);
		
                
                cValuesPanel.setBorder(BorderFactory.createTitledBorder(
                                    localize(dialogBundle,"EditVariable.CBorderText.label")));

                int dx=100;
                int dy=50;
                //Labels
        	minCVLabel.setText(
		      localize(dialogBundle,"EditVariable.MinCVLabel.label"));
		cValuesPanel.add(minCVLabel);
		minCVLabel.setBounds(82+dx,33+dy,93,20);


        	maxCVLabel.setText(
		      localize(dialogBundle,"EditVariable.MaxCVLabel.label"));
		cValuesPanel.add(maxCVLabel);
		maxCVLabel.setBounds(82+dx,63+dy,93,20);
                
        	precisionCVLabel.setText(
		      localize(dialogBundle,"EditVariable.PrecisionCVLabel.label"));
		cValuesPanel.add(precisionCVLabel);
		precisionCVLabel.setBounds(82+dx,93+dy,93,20);

        	undefValCVLabel.setText(
		      localize(dialogBundle,"EditVariable.UndefValCVLabel.label"));
		cValuesPanel.add(undefValCVLabel);
		undefValCVLabel.setBounds(40+dx,123+dy,193,20);
                
        	unitCVLabel.setText(
		      localize(dialogBundle,"EditVariable.UnitCVLabel.label"));
		cValuesPanel.add(unitCVLabel);
		unitCVLabel.setBounds(70+dx,153+dy,150,20);
                
                
                //TextField
 		cValuesPanel.add(minCVText);
		minCVText.setBounds(202+dx,33+dy,93,20);


		cValuesPanel.add(maxCVText);
		maxCVText.setBounds(202+dx,63+dy,93,20);
                
		cValuesPanel.add(precisionCVText);
		precisionCVText.setBounds(202+dx,93+dy,93,20);

		cValuesPanel.add(undefValCVText);
		undefValCVText.setBounds(202+dx,123+dy,93,20);
                
		cValuesPanel.add(unitCVText);
		unitCVText.setBounds(202+dx,153+dy,93,20);
       
        
        
        
        }




}

