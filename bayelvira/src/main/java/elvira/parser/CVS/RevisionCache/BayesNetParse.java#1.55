/* Generated By:JavaCC: Do not edit this line. BayesNetParse.java */
package elvira.parser;



import java.util.Vector;

import java.util.Enumeration;

import java.util.Hashtable;

import elvira.Node;

import elvira.NodeList;

import elvira.FiniteStates;

import elvira.Continuous;

import elvira.Configuration;

import elvira.potential.*;

import elvira.Relation;

import elvira.Link;

import elvira.LinkList;

import elvira.ValuesSet;

import elvira.LogicalNode;

import elvira.tools.LinearFunction;
import elvira.tools.QuadraticFunction;
import java.io.*;

import elvira.sensitivityAnalysis.GeneralizedPotentialTable;//Introducido por jruiz





public class BayesNetParse implements BayesNetParseConstants {

 public String Type;

 public String Name;

 public String KindOfGraph;

 public String Title;

 public String Comment;

 public String Author;

 public String WhoChanged;

 public String WhenChanged;

 public String VisualPrecision;

 public String version;

 public boolean locked;

 public Hashtable networkPropertyList;

 public Hashtable NodeDefaultProperties;

 public Hashtable RelationDefaultProperties;

 public Vector Consistency;

 public NodeList Nodes;

 public LinkList Links;

 public Vector Relations;

 public FiniteStates DefaultFinite;

 public Continuous DefaultContinuous;

 //MixedNode DefaultMixed;

 public Relation DefaultRelation;

 public Link DefaultLink;

 public int defaultnodetype;

 public boolean statesdecl;

 public ValuesSet DefaultValuesSet;









  public static void main(String args[]) throws ParseException

   ,IOException {

    FileInputStream f;



    f = new FileInputStream("ejemplo.elv");



    BayesNetParse parser = new BayesNetParse(f);

    parser.initialize();



    parser.CompilationUnit();







  }



  public void initialize() {

    String DefaultStates[]= {"absent","present"};



   Name =  new String("");

   KindOfGraph =  null;

   Title =  new String("");

   Comment =  new String("");

   Author =  new String("");

   WhoChanged =  new String("");

   WhenChanged =  new String("");

   version =  new String("1.0");

   networkPropertyList=new Hashtable();



   Consistency = new Vector();

    Nodes = new NodeList();

    Links = new LinkList();

    Relations = new Vector();

    DefaultFinite = new FiniteStates("Default",DefaultStates);

    DefaultContinuous = new Continuous();

    DefaultContinuous.setTitle("");

    DefaultContinuous.setComment("");

    DefaultRelation = new Relation();

    DefaultRelation.setKind(Relation.CONDITIONAL_PROB);

    DefaultFinite.setTitle("");

    DefaultFinite.setComment("");

    DefaultLink = new Link(true);



//    parser.DefaultContinuous = new ContinuousNode();

//    parser.DefaultMixed = new MixedNode();

     defaultnodetype=1;

 }

  final public void CompilationUnit() throws ParseException {
    NetworkDeclaration();
    jj_consume_token(0);
  }

  final public void NetworkDeclaration() throws ParseException {
 Token T;
    NetworkClass();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case WORD:
      T = jj_consume_token(WORD);
      break;
    case STRING:
      T = jj_consume_token(STRING);
      break;
    default:
      jj_la1[0] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
 Name=(T.toString());
    jj_consume_token(98);
    NetworkContent();
    jj_consume_token(99);
  }

  final public void NetworkClass() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case GRAPH:
      jj_consume_token(GRAPH);
             Type="graph";
      break;
    case NETWORK:
      jj_consume_token(NETWORK);
              Type="network";
      break;
    case BNET:
      jj_consume_token(BNET);
           Type="bnet";
      break;
    case IDIAGRAM:
      jj_consume_token(IDIAGRAM);
               Type="iDiagram";
      break;
    case IDWITHSVNODES:
      jj_consume_token(IDWITHSVNODES);
                    Type="iDWithSVNodes";
      break;
    case DAN:
      jj_consume_token(DAN);
          Type="dan";
      break;
    case UID:
      jj_consume_token(UID);
           Type="uid";
      break;
    default:
      jj_la1[1] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public void NetworkContent() throws ParseException {
    label_1:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case TITLE:
      case KINDOFGRAPH:
      case COMMENT:
      case AUTHOR:
      case WHOCHANGED:
      case WHENCHANGED:
      case VISUALPRECISION:
      case VERSION:
      case LOCKED:
      case CONSISTENCY:
      case NODE:
      case LINK:
      case RELATION:
      case DEFVALUE:
      case EVERY:
      case WORD:
        ;
        break;
      default:
        jj_la1[2] = jj_gen;
        break label_1;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case TITLE:
      case KINDOFGRAPH:
      case COMMENT:
      case AUTHOR:
      case WHOCHANGED:
      case WHENCHANGED:
      case VISUALPRECISION:
      case VERSION:
      case LOCKED:
      case CONSISTENCY:
      case DEFVALUE:
      case EVERY:
      case WORD:
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case TITLE:
        case KINDOFGRAPH:
        case COMMENT:
        case AUTHOR:
        case WHOCHANGED:
        case WHENCHANGED:
        case VISUALPRECISION:
        case VERSION:
        case LOCKED:
        case CONSISTENCY:
        case WORD:
          Property();
          break;
        case DEFVALUE:
        case EVERY:
          DefaultDeclaration();
          break;
        default:
          jj_la1[3] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        jj_consume_token(100);
        break;
      case NODE:
      case LINK:
      case RELATION:
        ElementDeclaration();
        break;
      default:
        jj_la1[4] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
  }

  final public void DefaultDeclaration() throws ParseException {
 Node N;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case DEFVALUE:
      jj_consume_token(DEFVALUE);
      break;
    case EVERY:
      jj_consume_token(EVERY);
      break;
    default:
      jj_la1[5] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    if (jj_2_1(3)) {
      jj_consume_token(NODE);
      jj_consume_token(NODETYPE);
      jj_consume_token(EQUAL);
      jj_consume_token(FINITE);
                                                       defaultnodetype=1;
    } else if (jj_2_2(3)) {
      jj_consume_token(NODE);
      if (defaultnodetype==1) {

      } else {
        jj_consume_token(-1);
        throw new ParseException();
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case TITLE:
      case COMMENT:
      case NODEKIND:
      case POSX:
      case POSY:
      case RELEVANCE:
      case PURPOSE:
      case WORD:
        NodeProperty(DefaultFinite);
        break;
      case NODETYPE:
      case NUMSTATES:
      case STATES:
        FiniteProperty(DefaultFinite);
        break;
      default:
        jj_la1[6] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case NODE:
        jj_consume_token(NODE);
        jj_consume_token(NODETYPE);
        jj_consume_token(EQUAL);
        jj_consume_token(CONTINUOUS);
                                              defaultnodetype=2;
        break;
      default:
        jj_la1[10] = jj_gen;
        if (jj_2_3(3)) {
          jj_consume_token(NODE);
          if (defaultnodetype==2) {

          } else {
            jj_consume_token(-1);
            throw new ParseException();
          }
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case TITLE:
          case COMMENT:
          case NODEKIND:
          case POSX:
          case POSY:
          case RELEVANCE:
          case PURPOSE:
          case WORD:
            NodeProperty(DefaultContinuous);
            break;
          case NODETYPE:
          case UNIT:
          case MIN:
          case MAX:
            ContinuousProperty(DefaultContinuous);
            break;
          default:
            jj_la1[7] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
        } else if (jj_2_4(3)) {
          jj_consume_token(NODE);
          jj_consume_token(OPEN_PAREN);
          jj_consume_token(FINITE);
          jj_consume_token(CLOSE_PAREN);
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case TITLE:
          case COMMENT:
          case NODEKIND:
          case POSX:
          case POSY:
          case RELEVANCE:
          case PURPOSE:
          case WORD:
            NodeProperty(DefaultFinite);
            break;
          case NODETYPE:
          case NUMSTATES:
          case STATES:
            FiniteProperty(DefaultFinite);
            break;
          default:
            jj_la1[8] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
        } else {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case NODE:
            jj_consume_token(NODE);
            jj_consume_token(OPEN_PAREN);
            jj_consume_token(CONTINUOUS);
            jj_consume_token(CLOSE_PAREN);
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case TITLE:
            case COMMENT:
            case NODEKIND:
            case POSX:
            case POSY:
            case RELEVANCE:
            case PURPOSE:
            case WORD:
              NodeProperty(DefaultContinuous);
              break;
            case NODETYPE:
            case UNIT:
            case MIN:
            case MAX:
              ContinuousProperty(DefaultContinuous);
              break;
            default:
              jj_la1[9] = jj_gen;
              jj_consume_token(-1);
              throw new ParseException();
            }
            break;
          case RELATION:
            jj_consume_token(RELATION);
            RelationProperty(DefaultRelation);
            break;
          default:
            jj_la1[11] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
        }
      }
    }
  }

  final public void Property() throws ParseException {
 Token T,NProp=null,VProp;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case TITLE:
      jj_consume_token(TITLE);
      jj_consume_token(EQUAL);
      T = jj_consume_token(STRING);
                              Title=T.image.substring(1,T.image.length()-1);
      break;
    case COMMENT:
      jj_consume_token(COMMENT);
      jj_consume_token(EQUAL);
      T = jj_consume_token(STRING);
                                Comment=T.image.substring(1,T.image.length()-1);
      break;
    default:
      jj_la1[15] = jj_gen;
      if (jj_2_5(3)) {
        jj_consume_token(CONSISTENCY);
        jj_consume_token(EQUAL);
        jj_consume_token(OPEN_PAREN);
        jj_consume_token(CLOSE_PAREN);
      } else {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case CONSISTENCY:
          jj_consume_token(CONSISTENCY);
          jj_consume_token(EQUAL);
          jj_consume_token(OPEN_PAREN);
          ListWords(Consistency);
          jj_consume_token(CLOSE_PAREN);
          break;
        case AUTHOR:
          jj_consume_token(AUTHOR);
          jj_consume_token(EQUAL);
          T = jj_consume_token(STRING);
                                 Author=T.image.substring(1,T.image.length()-1);
          break;
        case WHOCHANGED:
          jj_consume_token(WHOCHANGED);
          jj_consume_token(EQUAL);
          T = jj_consume_token(STRING);
                                     WhoChanged=T.image.substring(1,T.image.length()-1);
          break;
        case WHENCHANGED:
          jj_consume_token(WHENCHANGED);
          jj_consume_token(EQUAL);
          T = jj_consume_token(STRING);
                                      WhenChanged=T.image.substring(1,T.image.length()-1);
          break;
        case KINDOFGRAPH:
          jj_consume_token(KINDOFGRAPH);
          jj_consume_token(EQUAL);
          T = jj_consume_token(STRING);
                                      KindOfGraph=T.image.substring(1,T.image.length()-1);
          break;
        case LOCKED:
          jj_consume_token(LOCKED);
          jj_consume_token(EQUAL);
          T = jj_consume_token(BOOLEAN);
         if (T.image.equals("true")){locked=true;}

         else {locked=false;}
          break;
        case VERSION:
          jj_consume_token(VERSION);
          jj_consume_token(EQUAL);
          T = jj_consume_token(FLOAT);
                              version = T.image;
          break;
        case VISUALPRECISION:
          jj_consume_token(VISUALPRECISION);
          jj_consume_token(EQUAL);
          T = jj_consume_token(STRING);
                                        VisualPrecision=T.image.substring(1,T.image.length()-1);
          break;
        case WORD:
          NProp = jj_consume_token(WORD);
          jj_consume_token(EQUAL);
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case STRINGDECIMAL:
          case STRING:
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case STRING:
              VProp = jj_consume_token(STRING);
              break;
            case STRINGDECIMAL:
              VProp = jj_consume_token(STRINGDECIMAL);
      networkPropertyList.put(NProp.image,VProp.image);
              break;
            default:
              jj_la1[12] = jj_gen;
              jj_consume_token(-1);
              throw new ParseException();
            }
            break;
          case BOOLEAN:
          case DECIMAL_LITERAL:
          case WORD:
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case BOOLEAN:
              VProp = jj_consume_token(BOOLEAN);
              break;
            case WORD:
              VProp = jj_consume_token(WORD);
              break;
            case DECIMAL_LITERAL:
              VProp = jj_consume_token(DECIMAL_LITERAL);
              break;
            default:
              jj_la1[13] = jj_gen;
              jj_consume_token(-1);
              throw new ParseException();
            }

            break;
          default:
            jj_la1[14] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
          break;
        default:
          jj_la1[16] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
    }
  }

  final public void ElementDeclaration() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case NODE:
      NodeDeclaration();
      break;
    case LINK:
      LinkDeclaration();
      break;
    case RELATION:
      RelationDeclaration();
      break;
    default:
      jj_la1[17] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public void NodeDeclaration() throws ParseException {
 Token T;
    jj_consume_token(NODE);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case WORD:
      T = jj_consume_token(WORD);
      break;
    case STRING:
      T = jj_consume_token(STRING);
      break;
    case PARAMETER_WORD:
      T = jj_consume_token(PARAMETER_WORD);
      break;
    default:
      jj_la1[18] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    if (jj_2_6(1)) {
      DefaultNodeDeclaration(T);
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case OPEN_PAREN:
        jj_consume_token(OPEN_PAREN);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case FINITE:
          FiniteDeclaration(T);
          break;
        case CONTINUOUS:
          ContinuousDeclaration(T);
          break;
        default:
          jj_la1[19] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        break;
      default:
        jj_la1[20] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
  }

  final public void DefaultNodeDeclaration(Token T) throws ParseException {
    if (defaultnodetype==1) {
      FiniteBody(T);
    } else if (defaultnodetype==2) {
      ContinuousBody(T);
    } else {
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public void FiniteDeclaration(Token T) throws ParseException {
    jj_consume_token(FINITE);
    jj_consume_token(CLOSE_PAREN);
    FiniteBody(T);
  }

  final public void ContinuousDeclaration(Token T) throws ParseException {
    jj_consume_token(CONTINUOUS);
    jj_consume_token(CLOSE_PAREN);
    ContinuousBody(T);
  }

  final public void FiniteBody(Token T) throws ParseException {
FiniteStates N;

N= (FiniteStates) DefaultFinite.copy();

N.setName(T.image);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case 98:
      jj_consume_token(98);
      FiniteNodeProperties(N);
      jj_consume_token(99);
      break;
    case 100:
      jj_consume_token(100);
      break;
    default:
      jj_la1[21] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
                                              Nodes.insertNode(N);
  }

  final public void ContinuousBody(Token T) throws ParseException {
Continuous N;

N= (Continuous) DefaultContinuous.copy();

N.setName(T.image);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case 98:
      jj_consume_token(98);
      ContinuousNodeProperties(N);
      jj_consume_token(99);
      break;
    case 100:
      jj_consume_token(100);
      break;
    default:
      jj_la1[22] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
                                                  Nodes.insertNode(N);
  }

  final public void FiniteNodeProperties(Node N) throws ParseException {
    label_2:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case TITLE:
      case COMMENT:
      case NODETYPE:
      case NODEKIND:
      case NUMSTATES:
      case POSX:
      case POSY:
      case STATES:
      case RELEVANCE:
      case PURPOSE:
      case WORD:
        ;
        break;
      default:
        jj_la1[23] = jj_gen;
        break label_2;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case TITLE:
      case COMMENT:
      case NODEKIND:
      case POSX:
      case POSY:
      case RELEVANCE:
      case PURPOSE:
      case WORD:
        NodeProperty(N);
        break;
      case NODETYPE:
      case NUMSTATES:
      case STATES:
        FiniteProperty(N);
        break;
      default:
        jj_la1[24] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      jj_consume_token(100);
    }
  }

  final public void ContinuousNodeProperties(Continuous N) throws ParseException {
    label_3:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case TITLE:
      case COMMENT:
      case NODETYPE:
      case NODEKIND:
      case UNIT:
      case POSX:
      case POSY:
      case MIN:
      case MAX:
      case RELEVANCE:
      case PURPOSE:
      case WORD:
        ;
        break;
      default:
        jj_la1[25] = jj_gen;
        break label_3;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case TITLE:
      case COMMENT:
      case NODEKIND:
      case POSX:
      case POSY:
      case RELEVANCE:
      case PURPOSE:
      case WORD:
        NodeProperty(N);
        break;
      case NODETYPE:
      case UNIT:
      case MIN:
      case MAX:
        ContinuousProperty(N);
        break;
      default:
        jj_la1[26] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      jj_consume_token(100);
    }
  }

  final public void NodeProperty(Node N) throws ParseException {
 Token T,NProp,VProp;

 Double D;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case TITLE:
      jj_consume_token(TITLE);
      jj_consume_token(EQUAL);
      T = jj_consume_token(STRING);
                               N.setTitle(T.image.substring(1,T.image.length()-1));
      break;
    case COMMENT:
      jj_consume_token(COMMENT);
      jj_consume_token(EQUAL);
      T = jj_consume_token(STRING);
                                N.setComment(T.image.substring(1,T.image.length()-1));
      break;
    case NODEKIND:
      jj_consume_token(NODEKIND);
      jj_consume_token(EQUAL);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case CHANCE:
        T = jj_consume_token(CHANCE);
        break;
      case OBSERVED:
        T = jj_consume_token(OBSERVED);
        break;
      case DECISION:
        T = jj_consume_token(DECISION);
        break;
      case UTILITY:
        T = jj_consume_token(UTILITY);
        break;
      case SUPER_VALUE:
        T = jj_consume_token(SUPER_VALUE);
        break;
      default:
        jj_la1[27] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
                                                                                                  N.setKindOfNode(T.image);
      break;
    case POSX:
      jj_consume_token(POSX);
      jj_consume_token(EQUAL);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case INTEGER:
        T = jj_consume_token(INTEGER);
        break;
      case DECIMAL_LITERAL:
        T = jj_consume_token(DECIMAL_LITERAL);
        break;
      default:
        jj_la1[28] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
                                                       N.setPosX( Integer.valueOf(T.image).intValue() );
      break;
    case POSY:
      jj_consume_token(POSY);
      jj_consume_token(EQUAL);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case INTEGER:
        T = jj_consume_token(INTEGER);
        break;
      case DECIMAL_LITERAL:
        T = jj_consume_token(DECIMAL_LITERAL);
        break;
      default:
        jj_la1[29] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
                                                       N.setPosY( Integer.valueOf(T.image).intValue() );
      break;
    case RELEVANCE:
      jj_consume_token(RELEVANCE);
      jj_consume_token(EQUAL);
      T = jj_consume_token(FLOAT);
                                N.setRelevance(Double.valueOf(T.image).doubleValue());
      break;
    case PURPOSE:
      jj_consume_token(PURPOSE);
      jj_consume_token(EQUAL);
      T = jj_consume_token(STRING);
                               N.setPurpose(T.image.substring(1,T.image.length()-1));
      break;
    case WORD:
      NProp = jj_consume_token(WORD);
      jj_consume_token(EQUAL);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case STRINGDECIMAL:
      case STRING:
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case STRING:
          VProp = jj_consume_token(STRING);
          break;
        case STRINGDECIMAL:
          VProp = jj_consume_token(STRINGDECIMAL);
      N.putProperty(NProp.image,VProp.image);
          break;
        default:
          jj_la1[30] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        break;
      case DECIMAL_LITERAL:
        VProp = jj_consume_token(DECIMAL_LITERAL);

        break;
      default:
        jj_la1[31] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      break;
    default:
      jj_la1[32] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public void FiniteProperty(Node N) throws ParseException {
 Token T;

 Vector V;

 FiniteStates M;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case STATES:
  M = (FiniteStates) N;
      jj_consume_token(STATES);
      jj_consume_token(EQUAL);
                      V= new Vector();
      jj_consume_token(OPEN_PAREN);
      ListWords(V);
      jj_consume_token(CLOSE_PAREN);
                                                             M.setStates(V);
      break;
    case NODETYPE:
    case NUMSTATES:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case NODETYPE:
        jj_consume_token(NODETYPE);
        jj_consume_token(EQUAL);
        T = jj_consume_token(FINITE);
                                       N.setTypeOfVariable(T.image);
        break;
      case NUMSTATES:
        jj_consume_token(NUMSTATES);
        jj_consume_token(EQUAL);
        T = jj_consume_token(DECIMAL_LITERAL);
        break;
      default:
        jj_la1[33] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      break;
    default:
      jj_la1[34] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public void ContinuousProperty(Continuous N) throws ParseException {
 Token T;

 Double D;

 String S;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case NODETYPE:
      jj_consume_token(NODETYPE);
      jj_consume_token(EQUAL);
      T = jj_consume_token(CONTINUOUS);
                                         N.setTypeOfVariable(T.image);
      break;
    case UNIT:
    case MIN:
    case MAX:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case MIN:
        jj_consume_token(MIN);
        jj_consume_token(EQUAL);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case DECIMAL_LITERAL:
          T = jj_consume_token(DECIMAL_LITERAL);
          break;
        case INTEGER:
          T = jj_consume_token(INTEGER);
          break;
        case FLOAT:
          T = jj_consume_token(FLOAT);
          break;
        case FLOATSCI:
          T = jj_consume_token(FLOATSCI);
          break;
        default:
          jj_la1[35] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
                                                                                    D=new Double(T.image);N.setMin(D.doubleValue());
        break;
      case MAX:
        jj_consume_token(MAX);
        jj_consume_token(EQUAL);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case DECIMAL_LITERAL:
          T = jj_consume_token(DECIMAL_LITERAL);
          break;
        case INTEGER:
          T = jj_consume_token(INTEGER);
          break;
        case FLOAT:
          T = jj_consume_token(FLOAT);
          break;
        case FLOATSCI:
          T = jj_consume_token(FLOATSCI);
          break;
        default:
          jj_la1[36] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
                                                                                   D=new Double(T.image);N.setMax(D.doubleValue());
        break;
      case UNIT:
        jj_consume_token(UNIT);
        jj_consume_token(EQUAL);
        T = jj_consume_token(STRING);
                                S=new String(T.image);N.setUnit(S);
        break;
      default:
        jj_la1[37] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      break;
    default:
      jj_la1[38] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public void LinkDeclaration() throws ParseException {
 Token T; Link K; Node P;
    jj_consume_token(LINK);
         K = new Link(true);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case WORD:
    case STRING:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case WORD:
        T = jj_consume_token(WORD);
        break;
      case STRING:
        T = jj_consume_token(STRING);
        break;
      default:
        jj_la1[39] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
                                 K.setTail (Nodes.getNode(T.image));
      break;
    case PARAMETER_WORD:
      T = jj_consume_token(PARAMETER_WORD);
                        K.setTail (Nodes.getNode(T.image));
      break;
    default:
      jj_la1[40] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case WORD:
    case STRING:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case WORD:
        T = jj_consume_token(WORD);
        break;
      case STRING:
        T = jj_consume_token(STRING);
        break;
      default:
        jj_la1[41] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
                                 K.setHead (Nodes.getNode(T.image));
      break;
    case PARAMETER_WORD:
      T = jj_consume_token(PARAMETER_WORD);
                        K.setHead (Nodes.getNode(T.image));
      break;
    default:
      jj_la1[42] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case 98:
      jj_consume_token(98);
      LinkProperties(K);
      jj_consume_token(99);
      break;
    case 100:
      jj_consume_token(100);
      break;
    default:
      jj_la1[43] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  Links.insertLink(K);
  }

  final public void LinkProperties(Link K) throws ParseException {
    label_4:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMENT:
      case DIRECTED:
        ;
        break;
      default:
        jj_la1[44] = jj_gen;
        break label_4;
      }
      LinkProperty(K);
      jj_consume_token(100);
    }
  }

  final public void LinkProperty(Link K) throws ParseException {
 Token T;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case DIRECTED:
      jj_consume_token(DIRECTED);
      jj_consume_token(EQUAL);
      T = jj_consume_token(BOOLEAN);
       if(T.image.equals("true")) { K.setDirected(true);}

       else {K.setDirected(false);}
      break;
    case COMMENT:
      jj_consume_token(COMMENT);
      jj_consume_token(EQUAL);
      T = jj_consume_token(STRING);
                                K.setComment(T.image.substring(1,T.image.length()-1));
      break;
    default:
      jj_la1[45] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public void RelationDeclaration() throws ParseException {
 Token T;

 Vector C;

 Relation R;
    jj_consume_token(RELATION);
              R = DefaultRelation.copy(); C = new Vector();
    ListWords(C);
   R.setVariablesFromNames(C,Nodes);

   if(R.withUtilityNode())

   {

    //R.setVariables(R.chanceAndDecisionNodesUtilityRelationOfUtilityRelation());

    R.setKind(R.UTILITY);

   }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case 100:
      jj_consume_token(100);
      break;
    case 98:
      jj_consume_token(98);
      RelationProperties(R);
      jj_consume_token(99);
      break;
    default:
      jj_la1[46] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
                                          Relations.addElement(R);
  }

  final public void RelationProperties(Relation R) throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case COMMENT:
    case DETERMINISTIC:
    case HENRIONVSDIEZ:
    case VALUES:
    case ACTIVE:
    case RELATIONNAME:
    case RELATIONKIND:
      label_5:
      while (true) {
        RelationProperty(R);
        jj_consume_token(100);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case COMMENT:
        case DETERMINISTIC:
        case HENRIONVSDIEZ:
        case VALUES:
        case ACTIVE:
        case RELATIONNAME:
        case RELATIONKIND:
          ;
          break;
        default:
          jj_la1[47] = jj_gen;
          break label_5;
        }
      }
      break;
    case 100:
      jj_consume_token(100);
      break;
    default:
      jj_la1[48] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

//Modificado por jruiz
  final public void RelationProperty(Relation R) throws ParseException {
 Token T;

 Potential pot=null;

Relation Final=null;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case COMMENT:
      jj_consume_token(COMMENT);
      jj_consume_token(EQUAL);
      T = jj_consume_token(STRING);
                                R.setComment(T.image.substring(1,T.image.length()-1));
      break;
    case VALUES:
      jj_consume_token(VALUES);
      jj_consume_token(EQUAL);
                    //if(R.getKind()==Relation.UTILITY)

                      //Final=DefaultRelation.copy();

                      //Final.setVariables(R.getParents());

                      //Final.setKind(Relation.UTILITY);

                    //}

                    //else

                      Final=R;
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case TABLE:
        pot = TableDeclaration(Final);
        break;
      case GENERALIZEDTABLE:
        pot = GeneralizedTableDeclaration(Final);
        break;
      case TABLEINTERVAL:
        pot = IntervalTableDeclaration(Final);
        break;
      case TREE:
        pot = TreeDeclaration(Final);
        break;
      case TREEINTERVAL:
        pot = IntervalTreeDeclaration(Final);
        break;
      case CONVEXSET:
        pot = ConvexSetDeclaration(Final);
        break;
      case CREDALSETTREE:
        pot = ConvexSetTreeDeclaration(Final);
        break;
      case FUNCTION:
        pot = FunctionDeclaration(Final);
        break;
      case CONTINUOUS_TREE:
        pot = ContinuousTreeDeclaration(Final);
        break;
      case LOGICALEXPRESSION:
        pot = ConstraintDeclaration(Final);
        break;
      default:
        jj_la1[49] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
                                                     R.setValues(pot);
      break;
    case ACTIVE:
      jj_consume_token(ACTIVE);
      jj_consume_token(EQUAL);
      T = jj_consume_token(BOOLEAN);
                             if (T.image.equals("false")){R.setActive(false);}
      break;
    case DETERMINISTIC:
      jj_consume_token(DETERMINISTIC);
      jj_consume_token(EQUAL);
      T = jj_consume_token(BOOLEAN);
  if (T.image.equals("true"))

    R.setDeterministic(true);

  else

    R.setDeterministic(false);
      break;
    case RELATIONNAME:
      jj_consume_token(RELATIONNAME);
      jj_consume_token(EQUAL);
      T = jj_consume_token(WORD);
                                R.setName(T.image);
      break;
    case RELATIONKIND:
      jj_consume_token(RELATIONKIND);
      jj_consume_token(EQUAL);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case POTENTIAL:
        T = jj_consume_token(POTENTIAL);
        break;
      case CONDITIONAL_PROB:
        T = jj_consume_token(CONDITIONAL_PROB);
        break;
      case UTILITY:
        T = jj_consume_token(UTILITY);
        break;
      case CONSTRAINT:
        T = jj_consume_token(CONSTRAINT);
        break;
      case UTILITY_COMBINATION:
        T = jj_consume_token(UTILITY_COMBINATION);
        break;
      default:
        jj_la1[50] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
  //if (!((String) T.image).equals("utility-combination"))
  //{
    R.setKind((String)(T.image));
  //}
  //else R.setKind("Sum");

      break;
    case HENRIONVSDIEZ:
      jj_consume_token(HENRIONVSDIEZ);
      jj_consume_token(EQUAL);
      T = jj_consume_token(STRING);
        if (R.getValues().getClass() == CanonicalPotential.class) {
                if (((CanonicalPotential) R.getValues()).getFunction().getName().equals("Or") ||
                        ((CanonicalPotential) R.getValues()).getFunction().getName().equals("CausalMax")) {
                  ((CanonicalPotential) R.getValues()).setHenrionVSDiez(T.image.substring(1,T.image.length()-1));
                }
        }
      break;
    default:
      jj_la1[51] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  if (R.getComment().equals("new")) { R.setComment("");}
  }

  final public Potential ConstraintDeclaration(Relation R) throws ParseException {
 Token T;

 Vector C;

 Vector LN;

 LogicalExpression LE;
    jj_consume_token(LOGICALEXPRESSION);
                       LE=new LogicalExpression();
    jj_consume_token(OPEN_PAREN);
    ConstraintBody(LE);
    jj_consume_token(CLOSE_PAREN);
                                  {if (true) return (Potential)LE;}
    throw new Error("Missing return statement in function");
  }

  final public Potential FunctionDeclaration(Relation R) throws ParseException {
  Token Q;

  Potential F;
    jj_consume_token(FUNCTION);
    Q = jj_consume_token(WORD);
               if (((String) Q.image).equals("Or") ||
                    ((String) Q.image).equals("CausalMax") ||
                    ((String) Q.image).equals("GeneralizedMax") ||
                    ((String) Q.image).equals("And") ||
                    ((String) Q.image).equals("Min") ||
                    ((String) Q.image).equals("Xor")) {
                F = new CanonicalPotential(R.getVariables());
                ((CanonicalPotential) F).setFunction(Q.image);
                R.setKind((String) Q.image);
   }
   else if (((String) Q.image).equals("Sum") ||
                    ((String) Q.image).equals("Product"))
        {
                F = new UtilityPotential(R.getParents());
                ((UtilityPotential) F).setFunction(Q.image);
                //R.setKind((String) Q.image);


        }
   else {
    F = new PotentialFunction(R.getVariables());
    ((PotentialFunction) F).setFunction(Q.image);}
    jj_consume_token(OPEN_PAREN);
    label_6:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case FLOAT:
      case WORD:
        ;
        break;
      default:
        jj_la1[52] = jj_gen;
        break label_6;
      }
      ArgumentInclusion(F);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        jj_consume_token(COMMA);
        break;
      default:
        jj_la1[53] = jj_gen;
        ;
      }
    }
    jj_consume_token(CLOSE_PAREN);
    {if (true) return F;}
    throw new Error("Missing return statement in function");
  }

  final public void ArgumentInclusion(Potential F) throws ParseException {
  Token Q;

  Double D;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case FLOAT:
      Q = jj_consume_token(FLOAT);
               D=new Double(Q.image);
  ((PotentialFunction) F).addArgument(D.doubleValue());
      break;
    case WORD:
      Q = jj_consume_token(WORD);
      ((PotentialFunction) F).addArgument(Q.image);
      break;
    default:
      jj_la1[54] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public PotentialTable TableDeclaration(Relation R) throws ParseException {
 PotentialTable T;

 int i;
    jj_consume_token(TABLE);
   if (R.getKind()==Relation.UTILITY) T = new PotentialTable(R.chanceAndDecisionNodesOfUtilityRelation());
   else T = new PotentialTable(R.getVariables());
   T.setValue(-1.0);
    jj_consume_token(OPEN_PAREN);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case DEFVALUE:
    case OPEN_COR:
      ListAssignments(T);
      break;
    default:
      jj_la1[55] = jj_gen;
      ListFloats(T);
    }
    jj_consume_token(CLOSE_PAREN);
   {if (true) return T;}
    throw new Error("Missing return statement in function");
  }

  final public void ListFloats(PotentialTable Table) throws ParseException {
 Token T;

 int i;

 Double D;
   i=0;
    label_7:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case DECIMAL_LITERAL:
      case INTEGER:
      case FLOATSCI:
      case FLOAT:
        ;
        break;
      default:
        jj_la1[56] = jj_gen;
        break label_7;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case DECIMAL_LITERAL:
        T = jj_consume_token(DECIMAL_LITERAL);
        break;
      case INTEGER:
        T = jj_consume_token(INTEGER);
        break;
      case FLOAT:
        T = jj_consume_token(FLOAT);
        break;
      case FLOATSCI:
        T = jj_consume_token(FLOATSCI);
        break;
      default:
        jj_la1[57] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
   D= new Double(T.image);Table.setValue(i,D.doubleValue());i++;
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        jj_consume_token(COMMA);
        break;
      default:
        jj_la1[58] = jj_gen;
        ;
      }
    }
  }

//Introducido por jruiz
  final public PotentialTable GeneralizedTableDeclaration(Relation R) throws ParseException {
 GeneralizedPotentialTable T;

 int i;
    jj_consume_token(GENERALIZEDTABLE);
   if (R.getKind()==Relation.UTILITY) T = new GeneralizedPotentialTable(R.chanceAndDecisionNodesOfUtilityRelation());
   else T = new GeneralizedPotentialTable(R.getVariables());
   T.setValue(-1.0);T.setRange(null);T.setName(null);
    jj_consume_token(OPEN_PAREN);
    ListGeneralizedValues(T);
    jj_consume_token(CLOSE_PAREN);
   if (R.getKind()!=Relation.UTILITY) T.complementValues();
   {if (true) return T;}
    throw new Error("Missing return statement in function");
  }

  final public PotentialIntervalTable IntervalTableDeclaration(Relation R) throws ParseException {
 PotentialTable Min=null;
 PotentialTable Max=null;
 PotentialIntervalTable intervalTable;
 Vector defaults=new Vector();
 double defMin, defMax;
 int defCont;
 int i;
    jj_consume_token(TABLEINTERVAL);
        Min = new PotentialTable(R.getVariables());
        Min.setValue(-1.0);
        Max = new PotentialTable(R.getVariables());
        Max.setValue(-1.0);
    jj_consume_token(OPEN_PAREN);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case DEFINTERVALVALUE:
    case OPEN_COR:
      ConfIntervalTableDeclaration(Min,Max,defaults);
      break;
    case DEFINTERVALVALUES:
    case OPEN_PAREN:
    case DECIMAL_LITERAL:
    case INTEGER:
    case FLOATSCI:
    case FLOAT:
      PosIntervalTableDeclaration(Min,Max,defaults);
      break;
    default:
      jj_la1[59] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    jj_consume_token(CLOSE_PAREN);
         intervalTable=new PotentialIntervalTable(Min,Max);

         // Look if it is requiered to add default values

         if (defaults.size() != 0){
            intervalTable.setDefaultValues(defaults);
            defaults.removeAllElements();
         }

         {if (true) return intervalTable;}
    throw new Error("Missing return statement in function");
  }

  final public PTreeCredalSet ConvexSetTreeDeclaration(Relation R) throws ParseException {
  PTreeCredalSet pTreeCredalSet;
    jj_consume_token(CREDALSETTREE);
    jj_consume_token(OPEN_PAREN);
    // Create a new PTreeCredalSet with the set of variables used for
    // the relation

    pTreeCredalSet=new PTreeCredalSet((R.getVariables()).getNodes());
    BodyConvexSetTree(pTreeCredalSet,pTreeCredalSet.getTree());
    jj_consume_token(CLOSE_PAREN);
    {if (true) return pTreeCredalSet;}
    throw new Error("Missing return statement in function");
  }

  final public PotentialConvexSet ConvexSetDeclaration(Relation R) throws ParseException {
 PotentialConvexSet CS;
 PotentialTable table;
 Vector C;
    jj_consume_token(CONVEXSET);
     C=new Vector();
    jj_consume_token(OPEN_PAREN);
    label_8:
    while (true) {
      table = TableDeclaration(R);
     C.addElement(table);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case TABLE:
        ;
        break;
      default:
        jj_la1[60] = jj_gen;
        break label_8;
      }
    }
    jj_consume_token(CLOSE_PAREN);
     CS=new PotentialConvexSet(R.getVariables(),C);
     //R.setVariables(CS.getVariables());
     {if (true) return CS;}
    throw new Error("Missing return statement in function");
  }

  final public void ListAssignments(PotentialTable T) throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case OPEN_COR:
      label_9:
      while (true) {
        Assignment(T);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case COMMA:
          jj_consume_token(COMMA);
          break;
        default:
          jj_la1[61] = jj_gen;
          ;
        }
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case OPEN_COR:
          ;
          break;
        default:
          jj_la1[62] = jj_gen;
          break label_9;
        }
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case DEFVALUE:
        DefaultAssignment();
        break;
      default:
        jj_la1[63] = jj_gen;
        ;
      }
      label_10:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case OPEN_COR:
          ;
          break;
        default:
          jj_la1[64] = jj_gen;
          break label_10;
        }
        Assignment(T);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case COMMA:
          jj_consume_token(COMMA);
          break;
        default:
          jj_la1[65] = jj_gen;
          ;
        }
      }
      break;
    case DEFVALUE:
      DefaultAssignment();
      label_11:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case OPEN_COR:
          ;
          break;
        default:
          jj_la1[66] = jj_gen;
          break label_11;
        }
        Assignment(T);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case COMMA:
          jj_consume_token(COMMA);
          break;
        default:
          jj_la1[67] = jj_gen;
          ;
        }
      }
      break;
    default:
      jj_la1[68] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public void Assignment(PotentialTable Table) throws ParseException {
 Vector V;

 Configuration C;

 Double D;

 Token T;
    jj_consume_token(OPEN_COR);
    V = ListWordIntegers(Table);
    jj_consume_token(CLOSE_COR);
    jj_consume_token(EQUAL);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case DECIMAL_LITERAL:
      T = jj_consume_token(DECIMAL_LITERAL);
      break;
    case INTEGER:
      T = jj_consume_token(INTEGER);
      break;
    case FLOAT:
      T = jj_consume_token(FLOAT);
      break;
    case FLOATSCI:
      T = jj_consume_token(FLOATSCI);
      break;
    default:
      jj_la1[69] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    D= new Double(T.image);

    C = new Configuration(Table.getVariables(), V);

    Table.setValue(C,D.doubleValue());
  }

  final public void ConfIntervalTableDeclaration(PotentialTable min, PotentialTable max,Vector defaults) throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case DEFINTERVALVALUE:
      InitialDefConfIntervalTableDeclaration(min,max,defaults);
      break;
    case OPEN_COR:
      NonInitialDefConfIntervalTableDeclaration(min,max,defaults);
      break;
    default:
      jj_la1[70] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public void InitialDefConfIntervalTableDeclaration(PotentialTable min, PotentialTable max,Vector defaults) throws ParseException {
    DefaultIntervalAssignment(defaults);
    label_12:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case OPEN_COR:
        ;
        break;
      default:
        jj_la1[71] = jj_gen;
        break label_12;
      }
      ConfIntervalAssignment(min,max);
    }
  }

  final public void NonInitialDefConfIntervalTableDeclaration(PotentialTable min, PotentialTable max, Vector defaults) throws ParseException {
    label_13:
    while (true) {
      ConfIntervalAssignment(min,max);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case OPEN_COR:
        ;
        break;
      default:
        jj_la1[72] = jj_gen;
        break label_13;
      }
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case DEFINTERVALVALUE:
      DefaultIntervalAssignment(defaults);
      break;
    default:
      jj_la1[73] = jj_gen;
      ;
    }
    label_14:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case OPEN_COR:
        ;
        break;
      default:
        jj_la1[74] = jj_gen;
        break label_14;
      }
      ConfIntervalAssignment(min,max);
    }
  }

  final public void ConfIntervalAssignment(PotentialTable TableMin, PotentialTable TableMax) throws ParseException {
 Vector V;
 Configuration C;
 Double Min;
 Double Max;
 Token T;
 Vector values;
    jj_consume_token(OPEN_COR);
    V = ListWordIntegers(TableMin);
    jj_consume_token(CLOSE_COR);
    jj_consume_token(EQUAL);
    // Now will be specified one or two values for the interval 
    
       values = IntervalValues();
      C=new Configuration(TableMin.getVariables(),V);
      TableMin.setValue(C,((Double)values.elementAt(0)).doubleValue());
      TableMax.setValue(C,((Double)values.elementAt(1)).doubleValue());
  }

//Introducido por jruiz
  final public void ListGeneralizedValues(GeneralizedPotentialTable Table) throws ParseException {
int i;
         i=0;
    label_15:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case DECIMAL_LITERAL:
      case INTEGER:
      case FLOATSCI:
      case FLOAT:
      case COMODIN:
        ;
        break;
      default:
        jj_la1[75] = jj_gen;
        break label_15;
      }
      GeneralizedValue(Table,i);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        jj_consume_token(COMMA);
        break;
      default:
        jj_la1[76] = jj_gen;
        ;
      }
         i++;
    }
  }

//Introducido por jruiz
  final public void GeneralizedValue(GeneralizedPotentialTable Table, int i) throws ParseException {
Token T;
Token T1;
Double D;
String P;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case COMODIN:
      jj_consume_token(COMODIN);
                   Table.setValue(i,Double.NaN);Table.setRange(i,Double.NaN,Double.NaN);Table.setName(i,null);
      break;
    case DECIMAL_LITERAL:
    case INTEGER:
    case FLOATSCI:
    case FLOAT:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case DECIMAL_LITERAL:
        T = jj_consume_token(DECIMAL_LITERAL);
        break;
      case INTEGER:
        T = jj_consume_token(INTEGER);
        break;
      case FLOAT:
        T = jj_consume_token(FLOAT);
        break;
      case FLOATSCI:
        T = jj_consume_token(FLOATSCI);
        break;
      default:
        jj_la1[77] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
         D=new Double(T.image);Table.setValue(i,D.doubleValue());
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case OR:
        jj_consume_token(OR);
        RangeDeclaration(Table,i);
        break;
      default:
        jj_la1[78] = jj_gen;
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case OR:
        jj_consume_token(OR);
        T1 = jj_consume_token(STRING);
         P=new String(T1.image);Table.setName(i,P);
        break;
      default:
        jj_la1[79] = jj_gen;
        ;
      }
      break;
    default:
      jj_la1[80] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

//Introducido por jruiz
  final public void RangeDeclaration(GeneralizedPotentialTable Table,int i) throws ParseException {
Token T;
Token T1;
Double M;
Double N;
double m=Double.NaN;
double n=Double.NaN;
    jj_consume_token(RANGE);
    jj_consume_token(OPEN_PAREN);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case DECIMAL_LITERAL:
      T = jj_consume_token(DECIMAL_LITERAL);
      break;
    case INTEGER:
      T = jj_consume_token(INTEGER);
      break;
    case FLOAT:
      T = jj_consume_token(FLOAT);
      break;
    case FLOATSCI:
      T = jj_consume_token(FLOATSCI);
      break;
    default:
      jj_la1[81] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
         M=new Double(T.image);m=M.doubleValue();
    jj_consume_token(COMMA);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case DECIMAL_LITERAL:
      T1 = jj_consume_token(DECIMAL_LITERAL);
      break;
    case INTEGER:
      T1 = jj_consume_token(INTEGER);
      break;
    case FLOAT:
      T1 = jj_consume_token(FLOAT);
      break;
    case FLOATSCI:
      T1 = jj_consume_token(FLOATSCI);
      break;
    default:
      jj_la1[82] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
         N=new Double(T1.image);n=N.doubleValue();
    jj_consume_token(CLOSE_PAREN);
         Table.setRange(i,m,n);
  }

  final public void PosIntervalTableDeclaration(PotentialTable min, PotentialTable max,Vector defaults) throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case DEFINTERVALVALUES:
      InitialDefPosIntervalTableDeclaration(min,max,defaults);
      break;
    case OPEN_PAREN:
    case DECIMAL_LITERAL:
    case INTEGER:
    case FLOATSCI:
    case FLOAT:
      NonInitialDefPosIntervalTableDeclaration(min,max,defaults);
      break;
    default:
      jj_la1[83] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public void InitialDefPosIntervalTableDeclaration(PotentialTable min, PotentialTable max,Vector defaults) throws ParseException {
   int initialDefPos=0,finalDefPos=0;
   int posCounter=0;
    DefaultIntervalAssignments(defaults);
      initialDefPos=0;
      finalDefPos=((Integer)defaults.elementAt(defaults.size()-1)).intValue()-1;
      defaults.removeElementAt(defaults.size()-1);
      posCounter=finalDefPos+1;
    label_16:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case OPEN_PAREN:
      case DECIMAL_LITERAL:
      case INTEGER:
      case FLOATSCI:
      case FLOAT:
        ;
        break;
      default:
        jj_la1[84] = jj_gen;
        break label_16;
      }
      PosIntervalAssignment(min,max,posCounter);
      posCounter++;
    }
      // At the end, insert initialDefPos in defaults vector

      if (defaults.size() != 0){
        defaults.addElement(new Integer(initialDefPos));
        defaults.addElement(new Integer(finalDefPos));
      }
  }

  final public void NonInitialDefPosIntervalTableDeclaration(PotentialTable min, PotentialTable max, Vector defaults) throws ParseException {
   int initialDefPos=0,finalDefPos=0;
   int posCounter=0;
    label_17:
    while (true) {
      PosIntervalAssignment(min,max,posCounter);
      initialDefPos++;
      posCounter++;
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case OPEN_PAREN:
      case DECIMAL_LITERAL:
      case INTEGER:
      case FLOATSCI:
      case FLOAT:
        ;
        break;
      default:
        jj_la1[85] = jj_gen;
        break label_17;
      }
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case DEFINTERVALVALUES:
    case OPEN_PAREN:
    case DECIMAL_LITERAL:
    case INTEGER:
    case FLOATSCI:
    case FLOAT:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case DEFINTERVALVALUES:
        DefaultIntervalAssignments(defaults);
        // The last position of defaults will contain the number of positions
        // related to the default value

        finalDefPos=((Integer)defaults.elementAt(defaults.size()-1)).intValue()-1;
        defaults.removeElementAt(defaults.size()-1);
        finalDefPos=initialDefPos+finalDefPos;
        posCounter=finalDefPos+1;
        break;
      default:
        jj_la1[86] = jj_gen;
        ;
      }
      label_18:
      while (true) {
        PosIntervalAssignment(min,max,posCounter);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case OPEN_PAREN:
        case DECIMAL_LITERAL:
        case INTEGER:
        case FLOATSCI:
        case FLOAT:
          ;
          break;
        default:
          jj_la1[87] = jj_gen;
          break label_18;
        }
      }
        posCounter++;
      break;
    default:
      jj_la1[89] = jj_gen;
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case DEFINTERVALVALUE:
        DefaultIntervalAssignment(defaults);
        finalDefPos=(int)min.getSize()-1;
        break;
      default:
        jj_la1[88] = jj_gen;
        ;
      }
    }
      // At the end, insert initialDefPos in defaults vector

      if (defaults.size() != 0){
        defaults.addElement(new Integer(initialDefPos));
        defaults.addElement(new Integer(finalDefPos));
      }
  }

  final public void PosIntervalAssignment(PotentialTable TableMin,PotentialTable TableMax, int pos) throws ParseException {
 Token T;
 Double D;
 Vector values;
    // The intervals are specified one by one, without configurations
    
       values = IntervalValues();
      TableMin.setValue(pos,((Double)values.elementAt(0)).doubleValue());
      TableMax.setValue(pos,((Double)values.elementAt(1)).doubleValue());
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case COMMA:
      jj_consume_token(COMMA);
      break;
    default:
      jj_la1[90] = jj_gen;
      ;
    }
  }

  final public void FloatsToVector(Vector C) throws ParseException {
 Token T;

 Double D;
    label_19:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case DECIMAL_LITERAL:
      case INTEGER:
      case FLOATSCI:
      case FLOAT:
        ;
        break;
      default:
        jj_la1[91] = jj_gen;
        break label_19;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case DECIMAL_LITERAL:
        T = jj_consume_token(DECIMAL_LITERAL);
        break;
      case INTEGER:
        T = jj_consume_token(INTEGER);
        break;
      case FLOAT:
        T = jj_consume_token(FLOAT);
        break;
      case FLOATSCI:
        T = jj_consume_token(FLOATSCI);
        break;
      default:
        jj_la1[92] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
   D= new Double(T.image);C.addElement(D);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        jj_consume_token(COMMA);
        break;
      default:
        jj_la1[93] = jj_gen;
        ;
      }
    }
  }

  final public Vector ListWordIntegers(PotentialTable Table) throws ParseException {
 Vector V=new Vector();

 Token T;

 Integer I;

 int i;

 int j;
   V = new Vector();j=0;
    label_20:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case BOOLEAN:
      case DECIMAL_LITERAL:
      case WORD:
      case STRINGDECIMAL:
      case STRING:
        ;
        break;
      default:
        jj_la1[94] = jj_gen;
        break label_20;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case DECIMAL_LITERAL:
        T = jj_consume_token(DECIMAL_LITERAL);
                         I = new Integer(T.image);V.addElement(I);j++;
        break;
      case BOOLEAN:
      case WORD:
      case STRING:
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case WORD:
          T = jj_consume_token(WORD);
          break;
        case BOOLEAN:
          T = jj_consume_token(BOOLEAN);
          break;
        case STRING:
          T = jj_consume_token(STRING);
          break;
        default:
          jj_la1[95] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
                                      i = (( FiniteStates) Table.getVariables().elementAt(j)).getId(T.image);



  I = new Integer(i);V.addElement(I);

               j++;
        break;
      case STRINGDECIMAL:
        T = jj_consume_token(STRINGDECIMAL);
                       i = (( FiniteStates) Table.getVariables().elementAt(j)).getId(T.image.substring(1,T.image.length()-1));

               I = new Integer(i);V.addElement(I);

               j++;
        break;
      default:
        jj_la1[96] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        jj_consume_token(COMMA);
        break;
      default:
        jj_la1[97] = jj_gen;
        ;
      }
    }
  {if (true) return(V);}
    throw new Error("Missing return statement in function");
  }

  final public void DefaultAssignment() throws ParseException {
 Token T;
    jj_consume_token(DEFVALUE);
    jj_consume_token(EQUAL);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case DECIMAL_LITERAL:
      T = jj_consume_token(DECIMAL_LITERAL);
      break;
    case INTEGER:
      T = jj_consume_token(INTEGER);
      break;
    case FLOAT:
      T = jj_consume_token(FLOAT);
      break;
    case FLOATSCI:
      T = jj_consume_token(FLOATSCI);
      break;
    default:
      jj_la1[98] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public void DefaultIntervalAssignment(Vector defaults) throws ParseException {
 Token T;
 Double Min;
 Double Max;
 Vector values;
    jj_consume_token(DEFINTERVALVALUE);
    jj_consume_token(EQUAL);
    // As a default interval may be a pair of values or only one
    
       values = IntervalValues();
      defaults.addElement(values.elementAt(0));
      defaults.addElement(values.elementAt(1));
  }

  final public void DefaultIntervalAssignments(Vector defaults) throws ParseException {
 Token T;
 Double Min;
 Double Max;
 Integer Cont;
 Vector values;
    jj_consume_token(DEFINTERVALVALUES);
    jj_consume_token(OPEN_PAREN);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case DECIMAL_LITERAL:
      T = jj_consume_token(DECIMAL_LITERAL);
      break;
    case INTEGER:
      T = jj_consume_token(INTEGER);
      break;
    default:
      jj_la1[99] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
           Cont = new Integer(T.image);
    jj_consume_token(CLOSE_PAREN);
    jj_consume_token(EQUAL);
    // As a default interval may be a pair of values or only one
    
       values = IntervalValues();
      defaults.addElement(values.elementAt(0));
      defaults.addElement(values.elementAt(1));
      defaults.addElement(Cont);
  }

  final public PotentialTree TreeDeclaration(Relation R) throws ParseException {
 PotentialTree T;

 ProbabilityTree T2;
    jj_consume_token(TREE);
  T = new PotentialTree(R.getVariables());T2 = T.getTree();
    jj_consume_token(OPEN_PAREN);
    BodyTree(T2);
    jj_consume_token(CLOSE_PAREN);
 T.updateSize(); {if (true) return T;}
    throw new Error("Missing return statement in function");
  }

  final public PotentialIntervalTree IntervalTreeDeclaration(Relation R) throws ParseException {
 PotentialTree Min;
 PotentialTree Max;
 PotentialIntervalTree pIntervalTree;
 ProbabilityTree TMin;
 ProbabilityTree TMax;
    jj_consume_token(TREEINTERVAL);
  Min = new PotentialTree(R.getVariables());
  Max = new PotentialTree(R.getVariables());
  TMin = Min.getTree();
  TMax = Max.getTree();
    jj_consume_token(OPEN_PAREN);
    IntervalTreeSpecification(TMin,TMax);
    jj_consume_token(CLOSE_PAREN);
 Min.updateSize();
 Max.updateSize();
 pIntervalTree=new PotentialIntervalTree(Min,Max);
 {if (true) return pIntervalTree;}
    throw new Error("Missing return statement in function");
  }

  final public PotentialContinuousPT ContinuousTreeDeclaration(Relation R) throws ParseException {
 PotentialContinuousPT T;

 ContinuousProbabilityTree T2;
    jj_consume_token(CONTINUOUS_TREE);
  T = new PotentialContinuousPT(R.getVariables());T2 = T.getTree();
    jj_consume_token(OPEN_PAREN);
    BodyContinuousTree(T2);
    jj_consume_token(CLOSE_PAREN);
  {if (true) return T;}
    throw new Error("Missing return statement in function");
  }

  final public void BodyContinuousTree(ContinuousProbabilityTree T) throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case EXP:
    case GAUSS:
    case INTEGER:
    case FLOATSCI:
    case FLOAT:
      FinalCT(T);
      break;
    case CASE:
      ExpansionCT(T);
      break;
    default:
      jj_la1[100] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public void FinalCT(ContinuousProbabilityTree T) throws ParseException {
 MixtExpDensity D;
  D = new MixtExpDensity(0.0);
    DensityDeclaration(D);
    jj_consume_token(100);
                                                           T.assignProb(D);
  }

  final public void ExpansionCT(ContinuousProbabilityTree T) throws ParseException {
 Token Q;

 Node V;

Vector C;
    jj_consume_token(CASE);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case WORD:
      Q = jj_consume_token(WORD);
      break;
    case STRING:
      Q = jj_consume_token(STRING);
      break;
    default:
      jj_la1[101] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
        V =  Nodes.getNode(Q.image);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case OPEN_PAREN:
      jj_consume_token(OPEN_PAREN);
                        C = new Vector();
      FloatsToVector(C);
      jj_consume_token(CLOSE_PAREN);
                  T.assignVar((Continuous) V, C);
      jj_consume_token(98);
      ListContinuousOptions(T);
      jj_consume_token(99);
      break;
    case 98:
                 T.assignVar( (FiniteStates ) V);
      jj_consume_token(98);
      ListDiscreteOptions(T);
      jj_consume_token(99);
      break;
    default:
      jj_la1[102] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public void BodyTree(ProbabilityTree T) throws ParseException {
 Token Q;

 FiniteStates V;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case DECIMAL_LITERAL:
    case INTEGER:
    case FLOATSCI:
    case FLOAT:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case DECIMAL_LITERAL:
        Q = jj_consume_token(DECIMAL_LITERAL);
        break;
      case INTEGER:
        Q = jj_consume_token(INTEGER);
        break;
      case FLOAT:
        Q = jj_consume_token(FLOAT);
        break;
      case FLOATSCI:
        Q = jj_consume_token(FLOATSCI);
        break;
      default:
        jj_la1[103] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
                                                                         T.assignProb(Double.valueOf(Q.image).doubleValue());
      jj_consume_token(100);
      break;
    case CASE:
      jj_consume_token(CASE);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case WORD:
        Q = jj_consume_token(WORD);
        break;
      case STRING:
        Q = jj_consume_token(STRING);
        break;
      default:
        jj_la1[104] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
        V = (FiniteStates) Nodes.getNode(Q.image);

        T.assignVar(V);
      jj_consume_token(98);
      ListOptions(T);
      jj_consume_token(99);
      break;
    default:
      jj_la1[105] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public void IntervalTreeSpecification(ProbabilityTree TreeMin, ProbabilityTree TreeMax) throws ParseException {
 Token Q;
 FiniteStates V;
 Vector values;
 Double Max;
 Double Min;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case OPEN_PAREN:
    case DECIMAL_LITERAL:
    case INTEGER:
    case FLOATSCI:
    case FLOAT:
      values = IntervalValues();
     TreeMin.assignProb(((Double)values.elementAt(0)).doubleValue());
     TreeMax.assignProb(((Double)values.elementAt(1)).doubleValue());
      break;
    case CASE:
      jj_consume_token(CASE);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case WORD:
        Q = jj_consume_token(WORD);
        break;
      case STRING:
        Q = jj_consume_token(STRING);
        break;
      default:
        jj_la1[106] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
     // Read the name of the variable

     V = (FiniteStates) Nodes.getNode(Q.image);
     TreeMin.assignVar(V);
     TreeMax.assignVar(V);
      jj_consume_token(98);
      ListIntervalOptions(TreeMin,TreeMax);
      jj_consume_token(99);
      break;
    default:
      jj_la1[107] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public void BodyConvexSetTree(PTreeCredalSet pTreeCredalSet,ProbabilityTree pTree) throws ParseException {
 Token Q;
 FiniteStates V;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case 98:
      jj_consume_token(98);
      ExtremePointsDeclaration(pTreeCredalSet,pTree);
      jj_consume_token(99);
      break;
    case CASE:
      jj_consume_token(CASE);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case WORD:
        Q = jj_consume_token(WORD);
        break;
      case STRING:
        Q = jj_consume_token(STRING);
        break;
      default:
        jj_la1[108] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
         V = (FiniteStates) Nodes.getNode(Q.image);
         pTree.assignVar(V);
      jj_consume_token(98);
      ExtremeOptions(pTreeCredalSet,pTree);
      jj_consume_token(99);
      break;
    default:
      jj_la1[109] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public void ListOptions(ProbabilityTree T) throws ParseException {
    label_21:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case BOOLEAN:
      case DECIMAL_LITERAL:
      case WORD:
      case STRINGDECIMAL:
      case STRING:
        ;
        break;
      default:
        jj_la1[110] = jj_gen;
        break label_21;
      }
      Option(T);
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case DEFVALUE:
      DefaultAssignment();
      jj_consume_token(100);
      break;
    default:
      jj_la1[111] = jj_gen;
      ;
    }
    label_22:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case BOOLEAN:
      case DECIMAL_LITERAL:
      case WORD:
      case STRINGDECIMAL:
      case STRING:
        ;
        break;
      default:
        jj_la1[112] = jj_gen;
        break label_22;
      }
      Option(T);
    }
  }

  final public void ListIntervalOptions(ProbabilityTree Min, ProbabilityTree Max) throws ParseException {
    label_23:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case BOOLEAN:
      case DECIMAL_LITERAL:
      case WORD:
      case STRING:
        ;
        break;
      default:
        jj_la1[113] = jj_gen;
        break label_23;
      }
      IntervalOption(Min,Max);
    }
  }

  final public void ExtremeOptions(PTreeCredalSet pTreeCredalSet,ProbabilityTree pTree) throws ParseException {
    label_24:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case BOOLEAN:
      case DECIMAL_LITERAL:
      case WORD:
      case STRINGDECIMAL:
      case STRING:
        ;
        break;
      default:
        jj_la1[114] = jj_gen;
        break label_24;
      }
      ExtremeOption(pTreeCredalSet,pTree);
    }
  }

  final public void ListContinuousOptions(ContinuousProbabilityTree T) throws ParseException {
    label_25:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case DECIMAL_LITERAL:
        ;
        break;
      default:
        jj_la1[115] = jj_gen;
        break label_25;
      }
      ContinuousOption(T);
    }
  }

  final public void ListDiscreteOptions(ContinuousProbabilityTree T) throws ParseException {
    label_26:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case BOOLEAN:
      case DECIMAL_LITERAL:
      case WORD:
      case STRINGDECIMAL:
      case STRING:
        ;
        break;
      default:
        jj_la1[116] = jj_gen;
        break label_26;
      }
      DiscreteOption(T);
    }
  }

  final public void DiscreteOption(ContinuousProbabilityTree T) throws ParseException {
 Token Q;

 int i;

 ContinuousProbabilityTree T2;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case DECIMAL_LITERAL:
      Q = jj_consume_token(DECIMAL_LITERAL);
         i = Integer.parseInt(Q.image); T2 = (ContinuousProbabilityTree) T.getChild(i);
      break;
    case BOOLEAN:
    case WORD:
    case STRING:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case WORD:
        Q = jj_consume_token(WORD);
        break;
      case STRING:
        Q = jj_consume_token(STRING);
        break;
      case BOOLEAN:
        Q = jj_consume_token(BOOLEAN);
        break;
      default:
        jj_la1[117] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
         i = ((FiniteStates)T.getVar()).getId(Q.image); T2 = (ContinuousProbabilityTree) T.getChild(i);
      break;
    case STRINGDECIMAL:
      Q = jj_consume_token(STRINGDECIMAL);
         i = ((FiniteStates)T.getVar()).getId(Q.image.substring(1,Q.image.length()-1)); T2 = (ContinuousProbabilityTree) T.getChild(i);
      break;
    default:
      jj_la1[118] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    jj_consume_token(EQUAL);
    BodyContinuousTree(T2);
  }

  final public void ContinuousOption(ContinuousProbabilityTree T) throws ParseException {
 Token Q;

 int i;

 ContinuousProbabilityTree T2;
    Q = jj_consume_token(DECIMAL_LITERAL);
  i = (new Integer(Q.image)).intValue();

 T2 = (ContinuousProbabilityTree) T.getChild(i);
    jj_consume_token(EQUAL);
    BodyContinuousTree(T2);
  }

  final public void Option(ProbabilityTree T) throws ParseException {
 Token Q;

 int i;

 ProbabilityTree T2;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case DECIMAL_LITERAL:
      Q = jj_consume_token(DECIMAL_LITERAL);
         i = Integer.parseInt(Q.image); T2 = (ProbabilityTree) T.getChild().elementAt(i);
      break;
    case BOOLEAN:
    case WORD:
    case STRING:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case WORD:
        Q = jj_consume_token(WORD);
        break;
      case STRING:
        Q = jj_consume_token(STRING);
        break;
      case BOOLEAN:
        Q = jj_consume_token(BOOLEAN);
        break;
      default:
        jj_la1[119] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
         i = T.getVar().getId(Q.image); T2 = (ProbabilityTree) T.getChild().elementAt(i);
      break;
    case STRINGDECIMAL:
      Q = jj_consume_token(STRINGDECIMAL);
         i = T.getVar().getId(Q.image.substring(1,Q.image.length()-1)); T2 = (ProbabilityTree) T.getChild().elementAt(i);
      break;
    default:
      jj_la1[120] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    jj_consume_token(EQUAL);
    BodyTree(T2);
  }

  final public void IntervalOption(ProbabilityTree TreeMin, ProbabilityTree TreeMax) throws ParseException {
 Token Q;

 int i;
 ProbabilityTree Min;
 ProbabilityTree Max;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case WORD:
      Q = jj_consume_token(WORD);
      break;
    case STRING:
      Q = jj_consume_token(STRING);
      break;
    case BOOLEAN:
      Q = jj_consume_token(BOOLEAN);
      break;
    case DECIMAL_LITERAL:
      Q = jj_consume_token(DECIMAL_LITERAL);
      break;
    default:
      jj_la1[121] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    i = TreeMin.getVar().getId(Q.image);
    Min = (ProbabilityTree) TreeMin.getChild().elementAt(i);
    Max = (ProbabilityTree) TreeMax.getChild().elementAt(i);
    jj_consume_token(EQUAL);
    IntervalTreeSpecification(Min,Max);
  }

  final public void ExtremeOption(PTreeCredalSet pTreeCredalSet,ProbabilityTree pTree) throws ParseException {
 Token Q;
 int i;
 ProbabilityTree newTree;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case DECIMAL_LITERAL:
      Q = jj_consume_token(DECIMAL_LITERAL);
         i = Integer.parseInt(Q.image);  newTree = (ProbabilityTree) pTree.getChild().elementAt(i);
      break;
    case BOOLEAN:
    case WORD:
    case STRING:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case WORD:
        Q = jj_consume_token(WORD);
        break;
      case STRING:
        Q = jj_consume_token(STRING);
        break;
      case BOOLEAN:
        Q = jj_consume_token(BOOLEAN);
        break;
      default:
        jj_la1[122] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
         i = pTree.getVar().getId(Q.image);  newTree = (ProbabilityTree) pTree.getChild().elementAt(i);
      break;
    case STRINGDECIMAL:
      Q = jj_consume_token(STRINGDECIMAL);
         i = pTree.getVar().getId(Q.image.substring(1,Q.image.length()-1));  newTree = (ProbabilityTree) pTree.getChild().elementAt(i);
      break;
    default:
      jj_la1[123] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    jj_consume_token(EQUAL);
    BodyConvexSetTree(pTreeCredalSet,newTree);
  }

  final public void ExtremePointsDeclaration(PTreeCredalSet pTreeCredalSet,ProbabilityTree pTree) throws ParseException {
  Vector values=new Vector();
  FiniteStates mainVar=(FiniteStates)pTreeCredalSet.getVariables().elementAt(0);
  Relation rel=new Relation(mainVar);
  Potential pot;
    label_27:
    while (true) {
      pot = TableDeclaration(rel);
         values.addElement(pot);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case TABLE:
        ;
        break;
      default:
        jj_la1[124] = jj_gen;
        break label_27;
      }
    }
      // The values are arranged to the PTreeCredalSet

      pTreeCredalSet.addValues(values,pTree);
  }

  final public Vector IntervalValues() throws ParseException {
  Token Q;
  Vector values=new Vector();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case DECIMAL_LITERAL:
    case INTEGER:
    case FLOATSCI:
    case FLOAT:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case DECIMAL_LITERAL:
        Q = jj_consume_token(DECIMAL_LITERAL);
        break;
      case INTEGER:
        Q = jj_consume_token(INTEGER);
        break;
      case FLOAT:
        Q = jj_consume_token(FLOAT);
        break;
      case FLOATSCI:
        Q = jj_consume_token(FLOATSCI);
        break;
      default:
        jj_la1[125] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
       values.addElement(new Double(Q.image));
       values.addElement(new Double(Q.image));
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 100:
        jj_consume_token(100);
        break;
      default:
        jj_la1[126] = jj_gen;
        ;
      }
      break;
    case OPEN_PAREN:
      jj_consume_token(OPEN_PAREN);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case DECIMAL_LITERAL:
        Q = jj_consume_token(DECIMAL_LITERAL);
        break;
      case INTEGER:
        Q = jj_consume_token(INTEGER);
        break;
      case FLOAT:
        Q = jj_consume_token(FLOAT);
        break;
      case FLOATSCI:
        Q = jj_consume_token(FLOATSCI);
        break;
      default:
        jj_la1[127] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
        // Read the min value

        values.addElement(new Double(Q.image));
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        jj_consume_token(COMMA);
        break;
      default:
        jj_la1[128] = jj_gen;
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case DECIMAL_LITERAL:
        Q = jj_consume_token(DECIMAL_LITERAL);
        break;
      case INTEGER:
        Q = jj_consume_token(INTEGER);
        break;
      case FLOAT:
        Q = jj_consume_token(FLOAT);
        break;
      case FLOATSCI:
        Q = jj_consume_token(FLOATSCI);
        break;
      default:
        jj_la1[129] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
        // Max value is assigned

        values.addElement(new Double(Q.image));
      jj_consume_token(CLOSE_PAREN);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 100:
        jj_consume_token(100);
        break;
      default:
        jj_la1[130] = jj_gen;
        ;
      }
      break;
    default:
      jj_la1[131] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
     // Return the vector of values

     {if (true) return values;}
    throw new Error("Missing return statement in function");
  }

  final public void DensityDeclaration(MixtExpDensity D) throws ParseException {
 boolean neg;
 neg=false;
    DensityElement(D,neg);
    label_28:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case EXP:
      case GAUSS:
      case INTEGER:
      case FLOATSCI:
      case FLOAT:
      case 101:
      case 102:
        ;
        break;
      default:
        jj_la1[132] = jj_gen;
        break label_28;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 101:
      case 102:
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case 101:
          jj_consume_token(101);
          break;
        case 102:
          jj_consume_token(102);
                                             neg=true;
          break;
        default:
          jj_la1[133] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        break;
      default:
        jj_la1[134] = jj_gen;
        ;
      }
      DensityElement(D,neg);
                                                                                 neg=false;
    }
  }

  final public void DensityElement(MixtExpDensity D,boolean neg) throws ParseException {
 Token Q;
MixtExpDensity E;
boolean lfac;
 double x;
Continuous C;
double m,v;
 Double y;

 LinearFunction L;
 LinearFunction lf;
 QuadraticFunction qf;
 boolean linear;
    if (jj_2_9(3)) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case FLOAT:
        Q = jj_consume_token(FLOAT);
        break;
      case FLOATSCI:
        Q = jj_consume_token(FLOATSCI);
        break;
      case INTEGER:
        Q = jj_consume_token(INTEGER);
        break;
      default:
        jj_la1[135] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      y =new Double(Q.image);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 103:
        jj_consume_token(103);
        break;
      default:
        jj_la1[136] = jj_gen;
        ;
      }
      jj_consume_token(EXP);
      jj_consume_token(OPEN_PAREN);
           qf = new QuadraticFunction();
      linear = QuadraticFunctionDeclaration(qf);
      jj_consume_token(CLOSE_PAREN);
     if(linear) {lf = new LinearFunction(qf);
     if (neg)
     {D.addTerm(new Double(-y.doubleValue()),lf);} else {D.addTerm(y,lf);}}
     else
     {
     if (neg)
     {D.addTerm(new Double(-y.doubleValue()),qf);} else {D.addTerm(y,qf);}
     }
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case EXP:
        jj_consume_token(EXP);
        jj_consume_token(OPEN_PAREN);
           qf = new QuadraticFunction();
        linear = QuadraticFunctionDeclaration(qf);
        jj_consume_token(CLOSE_PAREN);
         if(linear) {lf = new LinearFunction(qf);
         if (neg)
         {D.addTerm(-1.0,lf);} else {D.addTerm(1.0,lf);}}
                 else
         {
         if (neg)
         {D.addTerm(-1.0,qf);} else {D.addTerm(1.0,qf);}
         }
        break;
      case GAUSS:
        jj_consume_token(GAUSS);
        jj_consume_token(OPEN_PAREN);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case WORD:
          Q = jj_consume_token(WORD);
          break;
        case STRING:
          Q = jj_consume_token(STRING);
          break;
        default:
          jj_la1[137] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        jj_consume_token(COMMA);
 C = (Continuous) Nodes.getNode(Q.image);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case FLOAT:
          Q = jj_consume_token(FLOAT);
          break;
        case FLOATSCI:
          Q = jj_consume_token(FLOATSCI);
          break;
        case INTEGER:
          Q = jj_consume_token(INTEGER);
          break;
        default:
          jj_la1[138] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
 m = (new Double(Q.image)).doubleValue();
        jj_consume_token(COMMA);
    lfac=false;
                 L = new LinearFunction();
        if (jj_2_7(2)) {
          LinearFunctionDeclaration(L);
          jj_consume_token(COMMA);
                                                                                           lfac=true;
        } else {
          ;
        }
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case FLOAT:
          Q = jj_consume_token(FLOAT);
          break;
        case FLOATSCI:
          Q = jj_consume_token(FLOATSCI);
          break;
        case INTEGER:
          Q = jj_consume_token(INTEGER);
          break;
        default:
          jj_la1[139] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
 v = (new Double(Q.image)).doubleValue();
        jj_consume_token(CLOSE_PAREN);
         if(lfac) {E = new  MixtExpDensity(C, m, L, v);} else  {E = new  MixtExpDensity(C, m,  v);}
    if (neg)     {D.addTerm(-E.getFactor(0),E.getExponent(0));}  else {D.addTerm(E.getFactor(0),E.getExponent(0));}
        break;
      default:
        jj_la1[146] = jj_gen;
        if (jj_2_10(3)) {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case FLOAT:
            Q = jj_consume_token(FLOAT);
            break;
          case FLOATSCI:
            Q = jj_consume_token(FLOATSCI);
            break;
          case INTEGER:
            Q = jj_consume_token(INTEGER);
            break;
          default:
            jj_la1[140] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
    y =new Double(Q.image);
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case 103:
            jj_consume_token(103);
            break;
          default:
            jj_la1[141] = jj_gen;
            ;
          }
          jj_consume_token(GAUSS);
          jj_consume_token(OPEN_PAREN);
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case WORD:
            Q = jj_consume_token(WORD);
            break;
          case STRING:
            Q = jj_consume_token(STRING);
            break;
          default:
            jj_la1[142] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
          jj_consume_token(COMMA);
 C = (Continuous) Nodes.getNode(Q.image);
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case FLOAT:
            Q = jj_consume_token(FLOAT);
            break;
          case FLOATSCI:
            Q = jj_consume_token(FLOATSCI);
            break;
          case INTEGER:
            Q = jj_consume_token(INTEGER);
            break;
          default:
            jj_la1[143] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
 m = (new Double(Q.image)).doubleValue();
          jj_consume_token(COMMA);
    lfac=false;
                 L = new LinearFunction();
          if (jj_2_8(2)) {
            LinearFunctionDeclaration(L);
            jj_consume_token(COMMA);
                                                                                           lfac=true;
          } else {
            ;
          }
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case FLOAT:
            Q = jj_consume_token(FLOAT);
            break;
          case FLOATSCI:
            Q = jj_consume_token(FLOATSCI);
            break;
          case INTEGER:
            Q = jj_consume_token(INTEGER);
            break;
          default:
            jj_la1[144] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
 v = (new Double(Q.image)).doubleValue();
          jj_consume_token(CLOSE_PAREN);
         if(lfac) {E = new  MixtExpDensity(C, m, L, v);} else  {E = new  MixtExpDensity(C, m,  v);}
    if (neg)     {D.addTerm(-E.getFactor(0)*y.doubleValue(),E.getExponent(0));}  else {D.addTerm(E.getFactor(0)*y.doubleValue(),E.getExponent(0));}
        } else {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case INTEGER:
          case FLOATSCI:
          case FLOAT:
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case FLOAT:
              Q = jj_consume_token(FLOAT);
              break;
            case FLOATSCI:
              Q = jj_consume_token(FLOATSCI);
              break;
            case INTEGER:
              Q = jj_consume_token(INTEGER);
              break;
            default:
              jj_la1[145] = jj_gen;
              jj_consume_token(-1);
              throw new ParseException();
            }
     x = (new Double(Q.image)).doubleValue();

     if (neg) {D.addIndependent(-x);} else  {D.addIndependent(x);}
            break;
          default:
            jj_la1[147] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
        }
      }
    }
  }

  final public void LinearFunctionDeclaration(LinearFunction L) throws ParseException {
  boolean neg;
  neg=false;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case 102:
      jj_consume_token(102);
                    neg=true;
      break;
    default:
      jj_la1[148] = jj_gen;
      ;
    }
    ElementLinear(L,neg);
    label_29:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case INTEGER:
      case FLOATSCI:
      case FLOAT:
      case WORD:
      case STRING:
      case 101:
      case 102:
        ;
        break;
      default:
        jj_la1[149] = jj_gen;
        break label_29;
      }
                        neg=false;
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 101:
      case 102:
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case 101:
          jj_consume_token(101);
          break;
        case 102:
          jj_consume_token(102);
                                               neg=true;
          break;
        default:
          jj_la1[150] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        break;
      default:
        jj_la1[151] = jj_gen;
        ;
      }
      ElementLinear(L,neg);
    }
  }

  final public void ElementLinear(LinearFunction L,boolean neg) throws ParseException {
 Token Q;

Double y;

Continuous var;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case INTEGER:
    case FLOATSCI:
    case FLOAT:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case FLOAT:
        Q = jj_consume_token(FLOAT);
        break;
      case FLOATSCI:
        Q = jj_consume_token(FLOATSCI);
        break;
      case INTEGER:
        Q = jj_consume_token(INTEGER);
        break;
      default:
        jj_la1[152] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
       y =new Double(Q.image);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 103:
        jj_consume_token(103);
        break;
      default:
        jj_la1[153] = jj_gen;
        ;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case WORD:
        Q = jj_consume_token(WORD);
        break;
      case STRING:
        Q = jj_consume_token(STRING);
        break;
      default:
        jj_la1[154] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
        var =  (Continuous)  Nodes.getNode(Q.image);

        if (neg) {L.addVariable(var,new Double(-y.doubleValue()) );} else {L.addVariable(var,y);}
      break;
    case WORD:
    case STRING:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case WORD:
        Q = jj_consume_token(WORD);
        break;
      case STRING:
        Q = jj_consume_token(STRING);
        break;
      default:
        jj_la1[155] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
        var =  (Continuous)  Nodes.getNode(Q.image);

        if (neg) {L.addVariable(var,-1.0);} else  {L.addVariable(var,1.0);}
      break;
    default:
      jj_la1[156] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  final public boolean QuadraticFunctionDeclaration(QuadraticFunction qf) throws ParseException {
  boolean neg,linear,quaelement;
 linear = true;neg=false;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case 102:
      jj_consume_token(102);
      neg=true;
      break;
    default:
      jj_la1[157] = jj_gen;
      ;
    }
    quaelement = ElementQuadratic(qf,neg);
    label_30:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case INTEGER:
      case FLOATSCI:
      case FLOAT:
      case WORD:
      case STRING:
      case 101:
      case 102:
      case 103:
        ;
        break;
      default:
        jj_la1[158] = jj_gen;
        break label_30;
      }
          neg=false; if (quaelement) {linear=false;}
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 101:
      case 102:
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case 101:
          jj_consume_token(101);
          break;
        case 102:
          jj_consume_token(102);
                   neg=true;
          break;
        default:
          jj_la1[159] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        break;
      default:
        jj_la1[160] = jj_gen;
        ;
      }
      quaelement = ElementQuadratic(qf,neg);
                                                                          if (quaelement) {linear=false;}
    }
 {if (true) return(linear);}
    throw new Error("Missing return statement in function");
  }

  final public boolean ElementQuadratic(QuadraticFunction qf,boolean neg) throws ParseException {
 Token Q;

Double y;

Continuous var1;
Continuous var2;
boolean quadr;
 quadr = false;
y = new Double(2.0);
var2=null;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case INTEGER:
    case FLOATSCI:
    case FLOAT:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case FLOAT:
        Q = jj_consume_token(FLOAT);
        break;
      case FLOATSCI:
        Q = jj_consume_token(FLOATSCI);
        break;
      case INTEGER:
        Q = jj_consume_token(INTEGER);
        break;
      default:
        jj_la1[161] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
                                                   y=new Double(Q.image);
      break;
    default:
      jj_la1[162] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case 103:
      jj_consume_token(103);
      break;
    default:
      jj_la1[163] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case WORD:
      Q = jj_consume_token(WORD);
      break;
    case STRING:
      Q = jj_consume_token(STRING);
      break;
    default:
      jj_la1[164] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
        var1=  (Continuous)  Nodes.getNode(Q.image);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case SQUARE:
    case 103:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 103:
        jj_consume_token(103);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case WORD:
          Q = jj_consume_token(WORD);
          break;
        case STRING:
          Q = jj_consume_token(STRING);
          break;
        default:
          jj_la1[165] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
                                              var2=  (Continuous)  Nodes.getNode(Q.image);quadr=true;
        break;
      case SQUARE:
        jj_consume_token(SQUARE);
                                                                                                                       var2=var1;quadr=true;
        break;
      default:
        jj_la1[166] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      break;
    default:
      jj_la1[167] = jj_gen;
      ;
    }
        if (quadr)
        {if (neg) {qf.addVariable(var1,var2,new Double(-y.doubleValue()) );} else {qf.addVariable(var1,var2,y);}}
        else
        {if (neg) {qf.addVariable(var1,new Double(-y.doubleValue()) );} else {qf.addVariable(var1,y);}
       }
 {if (true) return(quadr);}
    throw new Error("Missing return statement in function");
  }

  final public void ListWords(Vector C) throws ParseException {
 Token T;
    if (jj_2_11(2)) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case WORD:
        T = jj_consume_token(WORD);
        break;
      case STRING:
        T = jj_consume_token(STRING);
        break;
      case BOOLEAN:
        T = jj_consume_token(BOOLEAN);
        break;
      case DECIMAL_LITERAL:
        T = jj_consume_token(DECIMAL_LITERAL);
        break;
      case PARAMETER_WORD:
        T = jj_consume_token(PARAMETER_WORD);
        break;
      default:
        jj_la1[168] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
   C.addElement(T.toString());
      jj_consume_token(COMMA);
      ListWords(C);
    } else if (jj_2_12(2)) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case WORD:
        T = jj_consume_token(WORD);
        break;
      case STRING:
        T = jj_consume_token(STRING);
        break;
      case BOOLEAN:
        T = jj_consume_token(BOOLEAN);
        break;
      case DECIMAL_LITERAL:
        T = jj_consume_token(DECIMAL_LITERAL);
        break;
      case PARAMETER_WORD:
        T = jj_consume_token(PARAMETER_WORD);
        break;
      default:
        jj_la1[169] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
   C.addElement(T.toString());
      ListWords(C);
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case BOOLEAN:
      case DECIMAL_LITERAL:
      case PARAMETER_WORD:
      case WORD:
      case STRING:
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case WORD:
          T = jj_consume_token(WORD);
          break;
        case STRING:
          T = jj_consume_token(STRING);
          break;
        case BOOLEAN:
          T = jj_consume_token(BOOLEAN);
          break;
        case DECIMAL_LITERAL:
          T = jj_consume_token(DECIMAL_LITERAL);
          break;
        case PARAMETER_WORD:
          T = jj_consume_token(PARAMETER_WORD);
          break;
        default:
          jj_la1[170] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
   C.addElement(T.toString());
        break;
      default:
        jj_la1[171] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
  }

  final public void ConstraintBody(LogicalExpression LE) throws ParseException {
 LogicalNode antecedent;

 LogicalNode consecuent;

 Vector logicalNodes=new Vector();

 int operator;
    LogicalExpressionBody(logicalNodes);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case IMPLICATION:
      jj_consume_token(IMPLICATION);
                           operator=LogicalNode.IMPLICATION;
      break;
    case DOUBLEIMPLICATION:
      jj_consume_token(DOUBLEIMPLICATION);
                                 operator=LogicalNode.DOUBLE_IMPLICATION;
      break;
    default:
      jj_la1[172] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    LogicalExpressionBody(logicalNodes);
    antecedent=(LogicalNode)logicalNodes.elementAt(0);

    consecuent=(LogicalNode)logicalNodes.elementAt(1);

    LE.setAntecedent(antecedent);

    LE.setConsecuent(consecuent);

    LE.setOperator(operator);
  }

  final public void LogicalExpressionBody(Vector logicalNodes) throws ParseException {
 LogicalNode LNOperator;

 LogicalNode LNOp1;

 LogicalNode LNOp2;

 int last;
    OrFactor(logicalNodes);
    label_31:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case OR:
        ;
        break;
      default:
        jj_la1[173] = jj_gen;
        break label_31;
      }
      jj_consume_token(OR);
      OrFactor(logicalNodes);
                LNOperator=new LogicalNode(LogicalNode.OR);

                last=logicalNodes.size();

                LNOp1=(LogicalNode)logicalNodes.elementAt(last-1);

                LNOp2=(LogicalNode)logicalNodes.elementAt(last-2);

                logicalNodes.removeElementAt(last-1);

                logicalNodes.removeElementAt(last-2);

                LNOperator.setLeftOperand(LNOp2);

                LNOperator.setRightOperand(LNOp1);

                logicalNodes.addElement(LNOperator);
    }
  }

  final public void OrFactor(Vector logicalNodes) throws ParseException {
 LogicalNode LNOperator;

 LogicalNode LNOp1;

 LogicalNode LNOp2;

 int last;
    Factor(logicalNodes);

    label_32:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case AND:
        ;
        break;
      default:
        jj_la1[174] = jj_gen;
        break label_32;
      }
      jj_consume_token(AND);
      Factor(logicalNodes);
                LNOperator=new LogicalNode(LogicalNode.AND);

                last=logicalNodes.size();

                LNOp1=(LogicalNode)logicalNodes.elementAt(last-1);

                LNOp2=(LogicalNode)logicalNodes.elementAt(last-2);

                logicalNodes.removeElementAt(last-1);

                logicalNodes.removeElementAt(last-2);

                LNOperator.setLeftOperand(LNOp2);

                LNOperator.setRightOperand(LNOp1);

                logicalNodes.addElement(LNOperator);
    }
  }

  final public void Factor(Vector logicalNodes) throws ParseException {
 boolean flag=false;

 LogicalNode LN;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case NOT:
      jj_consume_token(NOT);
         flag=true;
      break;
    default:
      jj_la1[175] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case WORD:
      Assign(logicalNodes);
      break;
    case OPEN_PAREN:
      jj_consume_token(OPEN_PAREN);
      LogicalExpressionBody(logicalNodes);
      jj_consume_token(CLOSE_PAREN);
      break;
    default:
      jj_la1[176] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
            LN=(LogicalNode)logicalNodes.elementAt(logicalNodes.size()-1);

            LN.setNegated(flag);
  }

  final public void Assign(Vector logicalNodes) throws ParseException {
 Token t;

 Vector values;

 LogicalNode LN;

 Node P;

 boolean flag=false;
    t = jj_consume_token(WORD);
              values=new Vector();

              P=Nodes.getNode(t.image);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case IN:
      jj_consume_token(IN);
      break;
    case NOT:
      jj_consume_token(NOT);
      jj_consume_token(IN);
                             flag=true;
      break;
    default:
      jj_la1[177] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    jj_consume_token(98);
    valueList(values);
    jj_consume_token(99);
            DefaultValuesSet=new ValuesSet(P,values,flag);

            LN=new LogicalNode(DefaultValuesSet);

            logicalNodes.addElement(LN);
  }

  final public void valueList(Vector values) throws ParseException {
 Token value;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case WORD:
      value = jj_consume_token(WORD);
                 values.addElement(value.toString());
      label_33:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case COMMA:
          ;
          break;
        default:
          jj_la1[178] = jj_gen;
          break label_33;
        }
        jj_consume_token(COMMA);
        value = jj_consume_token(WORD);
                                                                           values.addElement(value.toString());
      }
      break;
    case STRING:
      value = jj_consume_token(STRING);
                   values.addElement(value.toString());
      label_34:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case COMMA:
          ;
          break;
        default:
          jj_la1[179] = jj_gen;
          break label_34;
        }
        jj_consume_token(COMMA);
        value = jj_consume_token(STRING);
                                                                               values.addElement(value.toString());
      }
      break;
    default:
      jj_la1[180] = jj_gen;

    }
  }

  final private boolean jj_2_1(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_1(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(0, xla); }
  }

  final private boolean jj_2_2(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_2(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(1, xla); }
  }

  final private boolean jj_2_3(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_3(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(2, xla); }
  }

  final private boolean jj_2_4(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_4(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(3, xla); }
  }

  final private boolean jj_2_5(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_5(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(4, xla); }
  }

  final private boolean jj_2_6(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_6(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(5, xla); }
  }

  final private boolean jj_2_7(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_7(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(6, xla); }
  }

  final private boolean jj_2_8(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_8(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(7, xla); }
  }

  final private boolean jj_2_9(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_9(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(8, xla); }
  }

  final private boolean jj_2_10(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_10(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(9, xla); }
  }

  final private boolean jj_2_11(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_11(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(10, xla); }
  }

  final private boolean jj_2_12(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_12(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(11, xla); }
  }

  final private boolean jj_3R_69() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(101)) {
    jj_scanpos = xsp;
    if (jj_3R_77()) return true;
    }
    return false;
  }

  final private boolean jj_3R_37() {
    if (jj_3R_45()) return true;
    return false;
  }

  final private boolean jj_3_5() {
    if (jj_scan_token(CONSISTENCY)) return true;
    if (jj_scan_token(EQUAL)) return true;
    if (jj_scan_token(OPEN_PAREN)) return true;
    return false;
  }

  final private boolean jj_3R_48() {
    if (jj_3R_66()) return true;
    return false;
  }

  final private boolean jj_3R_41() {
    Token xsp;
    xsp = jj_scanpos;
    lookingAhead = true;
    jj_semLA = defaultnodetype==1;
    lookingAhead = false;
    if (!jj_semLA || jj_3R_47()) {
    jj_scanpos = xsp;
    lookingAhead = true;
    jj_semLA = defaultnodetype==2;
    lookingAhead = false;
    if (!jj_semLA || jj_3R_48()) return true;
    }
    return false;
  }

  final private boolean jj_3R_47() {
    if (jj_3R_65()) return true;
    return false;
  }

  final private boolean jj_3R_74() {
    if (jj_scan_token(UNIT)) return true;
    if (jj_scan_token(EQUAL)) return true;
    return false;
  }

  final private boolean jj_3R_73() {
    if (jj_scan_token(MAX)) return true;
    if (jj_scan_token(EQUAL)) return true;
    return false;
  }

  final private boolean jj_3R_72() {
    if (jj_scan_token(MIN)) return true;
    if (jj_scan_token(EQUAL)) return true;
    return false;
  }

  final private boolean jj_3R_38() {
    return false;
  }

  final private boolean jj_3R_64() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_72()) {
    jj_scanpos = xsp;
    if (jj_3R_73()) {
    jj_scanpos = xsp;
    if (jj_3R_74()) return true;
    }
    }
    return false;
  }

  final private boolean jj_3R_51() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_69()) jj_scanpos = xsp;
    if (jj_3R_50()) return true;
    return false;
  }

  final private boolean jj_3R_63() {
    if (jj_scan_token(NODETYPE)) return true;
    if (jj_scan_token(EQUAL)) return true;
    return false;
  }

  final private boolean jj_3R_46() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_63()) {
    jj_scanpos = xsp;
    if (jj_3R_64()) return true;
    }
    return false;
  }

  final private boolean jj_3R_67() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(88)) {
    jj_scanpos = xsp;
    if (jj_scan_token(87)) {
    jj_scanpos = xsp;
    if (jj_scan_token(86)) return true;
    }
    }
    xsp = jj_scanpos;
    if (jj_scan_token(103)) jj_scanpos = xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(91)) {
    jj_scanpos = xsp;
    if (jj_scan_token(96)) return true;
    }
    return false;
  }

  final private boolean jj_3R_50() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_67()) {
    jj_scanpos = xsp;
    if (jj_3R_68()) return true;
    }
    return false;
  }

  final private boolean jj_3R_35() {
    return false;
  }

  final private boolean jj_3R_39() {
    if (jj_3R_44()) return true;
    return false;
  }

  final private boolean jj_3R_49() {
    if (jj_scan_token(102)) return true;
    return false;
  }

  final private boolean jj_3R_76() {
    if (jj_scan_token(98)) return true;
    return false;
  }

  final private boolean jj_3_8() {
    if (jj_3R_42()) return true;
    if (jj_scan_token(COMMA)) return true;
    return false;
  }

  final private boolean jj_3R_66() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_76()) {
    jj_scanpos = xsp;
    if (jj_scan_token(100)) return true;
    }
    return false;
  }

  final private boolean jj_3_6() {
    if (jj_3R_41()) return true;
    return false;
  }

  final private boolean jj_3R_36() {
    if (jj_3R_44()) return true;
    return false;
  }

  final private boolean jj_3_4() {
    if (jj_scan_token(NODE)) return true;
    if (jj_scan_token(OPEN_PAREN)) return true;
    if (jj_scan_token(FINITE)) return true;
    return false;
  }

  final private boolean jj_3R_71() {
    if (jj_scan_token(NUMSTATES)) return true;
    if (jj_scan_token(EQUAL)) return true;
    return false;
  }

  final private boolean jj_3_9() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(88)) {
    jj_scanpos = xsp;
    if (jj_scan_token(87)) {
    jj_scanpos = xsp;
    if (jj_scan_token(86)) return true;
    }
    }
    xsp = jj_scanpos;
    if (jj_scan_token(103)) jj_scanpos = xsp;
    if (jj_scan_token(EXP)) return true;
    if (jj_scan_token(OPEN_PAREN)) return true;
    return false;
  }

  final private boolean jj_3R_70() {
    if (jj_scan_token(NODETYPE)) return true;
    if (jj_scan_token(EQUAL)) return true;
    return false;
  }

  final private boolean jj_3R_62() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_70()) {
    jj_scanpos = xsp;
    if (jj_3R_71()) return true;
    }
    return false;
  }

  final private boolean jj_3_3() {
    if (jj_scan_token(NODE)) return true;
    Token xsp;
    xsp = jj_scanpos;
    lookingAhead = true;
    jj_semLA = defaultnodetype==2;
    lookingAhead = false;
    if (!jj_semLA || jj_3R_38()) return true;
    xsp = jj_scanpos;
    if (jj_3R_39()) {
    jj_scanpos = xsp;
    if (jj_3R_40()) return true;
    }
    return false;
  }

  final private boolean jj_3R_42() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_49()) jj_scanpos = xsp;
    if (jj_3R_50()) return true;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_51()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  final private boolean jj_3_2() {
    if (jj_scan_token(NODE)) return true;
    Token xsp;
    xsp = jj_scanpos;
    lookingAhead = true;
    jj_semLA = defaultnodetype==1;
    lookingAhead = false;
    if (!jj_semLA || jj_3R_35()) return true;
    xsp = jj_scanpos;
    if (jj_3R_36()) {
    jj_scanpos = xsp;
    if (jj_3R_37()) return true;
    }
    return false;
  }

  final private boolean jj_3_7() {
    if (jj_3R_42()) return true;
    if (jj_scan_token(COMMA)) return true;
    return false;
  }

  final private boolean jj_3_1() {
    if (jj_scan_token(NODE)) return true;
    if (jj_scan_token(NODETYPE)) return true;
    if (jj_scan_token(EQUAL)) return true;
    return false;
  }

  final private boolean jj_3R_61() {
    if (jj_scan_token(STATES)) return true;
    if (jj_scan_token(EQUAL)) return true;
    return false;
  }

  final private boolean jj_3R_45() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_61()) {
    jj_scanpos = xsp;
    if (jj_3R_62()) return true;
    }
    return false;
  }

  final private boolean jj_3R_75() {
    if (jj_scan_token(98)) return true;
    return false;
  }

  final private boolean jj_3R_65() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_75()) {
    jj_scanpos = xsp;
    if (jj_scan_token(100)) return true;
    }
    return false;
  }

  final private boolean jj_3R_60() {
    if (jj_scan_token(WORD)) return true;
    if (jj_scan_token(EQUAL)) return true;
    return false;
  }

  final private boolean jj_3R_59() {
    if (jj_scan_token(PURPOSE)) return true;
    if (jj_scan_token(EQUAL)) return true;
    return false;
  }

  final private boolean jj_3R_58() {
    if (jj_scan_token(RELEVANCE)) return true;
    if (jj_scan_token(EQUAL)) return true;
    return false;
  }

  final private boolean jj_3R_57() {
    if (jj_scan_token(POSY)) return true;
    if (jj_scan_token(EQUAL)) return true;
    return false;
  }

  final private boolean jj_3_10() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(88)) {
    jj_scanpos = xsp;
    if (jj_scan_token(87)) {
    jj_scanpos = xsp;
    if (jj_scan_token(86)) return true;
    }
    }
    xsp = jj_scanpos;
    if (jj_scan_token(103)) jj_scanpos = xsp;
    if (jj_scan_token(GAUSS)) return true;
    if (jj_scan_token(OPEN_PAREN)) return true;
    return false;
  }

  final private boolean jj_3R_56() {
    if (jj_scan_token(POSX)) return true;
    if (jj_scan_token(EQUAL)) return true;
    return false;
  }

  final private boolean jj_3R_55() {
    if (jj_scan_token(NODEKIND)) return true;
    if (jj_scan_token(EQUAL)) return true;
    return false;
  }

  final private boolean jj_3R_54() {
    if (jj_scan_token(COMMENT)) return true;
    if (jj_scan_token(EQUAL)) return true;
    return false;
  }

  final private boolean jj_3R_44() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_53()) {
    jj_scanpos = xsp;
    if (jj_3R_54()) {
    jj_scanpos = xsp;
    if (jj_3R_55()) {
    jj_scanpos = xsp;
    if (jj_3R_56()) {
    jj_scanpos = xsp;
    if (jj_3R_57()) {
    jj_scanpos = xsp;
    if (jj_3R_58()) {
    jj_scanpos = xsp;
    if (jj_3R_59()) {
    jj_scanpos = xsp;
    if (jj_3R_60()) return true;
    }
    }
    }
    }
    }
    }
    }
    return false;
  }

  final private boolean jj_3R_53() {
    if (jj_scan_token(TITLE)) return true;
    if (jj_scan_token(EQUAL)) return true;
    return false;
  }

  final private boolean jj_3R_52() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(91)) {
    jj_scanpos = xsp;
    if (jj_scan_token(96)) {
    jj_scanpos = xsp;
    if (jj_scan_token(77)) {
    jj_scanpos = xsp;
    if (jj_scan_token(85)) {
    jj_scanpos = xsp;
    if (jj_scan_token(90)) return true;
    }
    }
    }
    }
    return false;
  }

  final private boolean jj_3_12() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(91)) {
    jj_scanpos = xsp;
    if (jj_scan_token(96)) {
    jj_scanpos = xsp;
    if (jj_scan_token(77)) {
    jj_scanpos = xsp;
    if (jj_scan_token(85)) {
    jj_scanpos = xsp;
    if (jj_scan_token(90)) return true;
    }
    }
    }
    }
    if (jj_3R_43()) return true;
    return false;
  }

  final private boolean jj_3R_40() {
    if (jj_3R_46()) return true;
    return false;
  }

  final private boolean jj_3_11() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(91)) {
    jj_scanpos = xsp;
    if (jj_scan_token(96)) {
    jj_scanpos = xsp;
    if (jj_scan_token(77)) {
    jj_scanpos = xsp;
    if (jj_scan_token(85)) {
    jj_scanpos = xsp;
    if (jj_scan_token(90)) return true;
    }
    }
    }
    }
    if (jj_scan_token(COMMA)) return true;
    return false;
  }

  final private boolean jj_3R_43() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_11()) {
    jj_scanpos = xsp;
    if (jj_3_12()) {
    jj_scanpos = xsp;
    if (jj_3R_52()) return true;
    }
    }
    return false;
  }

  final private boolean jj_3R_77() {
    if (jj_scan_token(102)) return true;
    return false;
  }

  final private boolean jj_3R_68() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(91)) {
    jj_scanpos = xsp;
    if (jj_scan_token(96)) return true;
    }
    return false;
  }

  public BayesNetParseTokenManager token_source;
  SimpleCharStream jj_input_stream;
  public Token token, jj_nt;
  private int jj_ntk;
  private Token jj_scanpos, jj_lastpos;
  private int jj_la;
  public boolean lookingAhead = false;
  private boolean jj_semLA;
  private int jj_gen;
  final private int[] jj_la1 = new int[181];
  static private int[] jj_la1_0;
  static private int[] jj_la1_1;
  static private int[] jj_la1_2;
  static private int[] jj_la1_3;
  static {
      jj_la1_0();
      jj_la1_1();
      jj_la1_2();
      jj_la1_3();
   }
   private static void jj_la1_0() {
      jj_la1_0 = new int[] {0x0,0x7f0,0x33ff800,0x1ff800,0x33ff800,0x0,0x70002800,0xb0002800,0x70002800,0xb0002800,0x200000,0x2200000,0x0,0x0,0x0,0x2800,0x1fd000,0x3200000,0x0,0xc00000,0x0,0x0,0x0,0x70002800,0x70002800,0xb0002800,0xb0002800,0x0,0x0,0x0,0x0,0x0,0x20002800,0x50000000,0x50000000,0x0,0x0,0x80000000,0x90000000,0x0,0x0,0x0,0x0,0x0,0x2000,0x2000,0x0,0xc002000,0xc002000,0x0,0x0,0xc002000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,};
   }
   private static void jj_la1_1() {
      jj_la1_1 = new int[] {0x0,0x0,0x11000,0x11000,0x11000,0x11000,0x7,0xc00003,0x7,0xc00003,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x7,0x7,0xc00003,0xc00003,0x1f000000,0x0,0x0,0x0,0x0,0x3,0x0,0x4,0x0,0x0,0xc00000,0xc00000,0x0,0x0,0x0,0x0,0x0,0x8000,0x8000,0x0,0x1a0008,0x1a0008,0x407f0,0xe8000000,0x1a0008,0x0,0x0,0x0,0x1000,0x0,0x0,0x0,0x6000,0x10,0x0,0x0,0x1000,0x0,0x0,0x0,0x0,0x1000,0x0,0x2000,0x0,0x0,0x2000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x4000,0x0,0x0,0x4000,0x0,0x2000,0x4000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x200800,0x0,0x0,0x0,0x0,0x800,0x0,0x800,0x0,0x800,0x0,0x1000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x10,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x200000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x200000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,};
   }
   private static void jj_la1_2() {
      jj_la1_2 = new int[] {0x8000000,0x0,0x8000000,0x8000000,0x8000000,0x0,0x8000003,0x8000003,0x8000003,0x8000003,0x0,0x0,0x80000000,0x8202000,0x88202000,0x0,0x8000000,0x0,0xc000000,0x0,0x10000,0x0,0x0,0x8000003,0x8000003,0x8000003,0x8000003,0x0,0x600000,0x600000,0x80000000,0x80200000,0x8000003,0x0,0x0,0x1e00000,0x1e00000,0x0,0x0,0x8000000,0xc000000,0x8000000,0xc000000,0x0,0x0,0x0,0x0,0x0,0x0,0x1008,0x4,0x0,0x9000000,0x40000,0x9000000,0x80000,0x1e00000,0x1e00000,0x40000,0x1e90000,0x0,0x40000,0x80000,0x0,0x80000,0x40000,0x80000,0x40000,0x80000,0x1e00000,0x80000,0x80000,0x80000,0x0,0x80000,0x3e00000,0x40000,0x1e00000,0x80,0x80,0x3e00000,0x1e00000,0x1e00000,0x1e10000,0x1e10000,0x1e10000,0x0,0x1e10000,0x0,0x1e10000,0x40000,0x1e00000,0x1e00000,0x40000,0x88202000,0x8002000,0x88202000,0x40000,0x1e00000,0x600000,0x1c00010,0x8000000,0x10000,0x1e00000,0x8000000,0x1e00000,0x8000000,0x1e10000,0x8000000,0x0,0x88202000,0x0,0x88202000,0x8202000,0x88202000,0x200000,0x88202000,0x8002000,0x88202000,0x8002000,0x88202000,0x8202000,0x8002000,0x88202000,0x0,0x1e00000,0x0,0x1e00000,0x40000,0x1e00000,0x0,0x1e10000,0x1c00010,0x0,0x0,0x1c00000,0x0,0x8000000,0x1c00000,0x1c00000,0x1c00000,0x0,0x8000000,0x1c00000,0x1c00000,0x1c00000,0x10,0x1c00000,0x0,0x9c00000,0x0,0x0,0x1c00000,0x0,0x8000000,0x8000000,0x9c00000,0x0,0x9c00000,0x0,0x0,0x1c00000,0x1c00000,0x0,0x8000000,0x8000000,0x0,0x0,0xc202000,0xc202000,0xc202000,0xc202000,0x300,0x80,0x40,0x400,0x8010000,0x420,0x40000,0x40000,0x8000000,};
   }
   private static void jj_la1_3() {
      jj_la1_3 = new int[] {0x1,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1,0x0,0x1,0x0,0x0,0x0,0x1,0x0,0x0,0x14,0x14,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1,0x1,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1,0x1,0x1,0x1,0x14,0x0,0x0,0x14,0x0,0x10,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1,0x1,0x1,0x0,0x0,0x0,0x0,0x1,0x4,0x0,0x1,0x0,0x1,0x0,0x1,0x4,0x1,0x0,0x1,0x1,0x1,0x0,0x1,0x1,0x1,0x1,0x1,0x1,0x1,0x1,0x0,0x0,0x10,0x0,0x0,0x0,0x10,0x0,0x60,0x60,0x60,0x0,0x80,0x1,0x0,0x0,0x0,0x80,0x1,0x0,0x0,0x0,0x0,0x0,0x40,0x61,0x60,0x60,0x0,0x80,0x1,0x1,0x1,0x40,0xe1,0x60,0x60,0x0,0x0,0x80,0x1,0x1,0x82,0x82,0x1,0x1,0x1,0x1,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1,};
   }
  final private JJCalls[] jj_2_rtns = new JJCalls[12];
  private boolean jj_rescan = false;
  private int jj_gc = 0;

  public BayesNetParse(java.io.InputStream stream) {
     this(stream, null);
  }
  public BayesNetParse(java.io.InputStream stream, String encoding) {
    try { jj_input_stream = new SimpleCharStream(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source = new BayesNetParseTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 181; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  public void ReInit(java.io.InputStream stream) {
     ReInit(stream, null);
  }
  public void ReInit(java.io.InputStream stream, String encoding) {
    try { jj_input_stream.ReInit(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 181; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  public BayesNetParse(java.io.Reader stream) {
    jj_input_stream = new SimpleCharStream(stream, 1, 1);
    token_source = new BayesNetParseTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 181; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  public void ReInit(java.io.Reader stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 181; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  public BayesNetParse(BayesNetParseTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 181; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  public void ReInit(BayesNetParseTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 181; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  final private Token jj_consume_token(int kind) throws ParseException {
    Token oldToken;
    if ((oldToken = token).next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    if (token.kind == kind) {
      jj_gen++;
      if (++jj_gc > 100) {
        jj_gc = 0;
        for (int i = 0; i < jj_2_rtns.length; i++) {
          JJCalls c = jj_2_rtns[i];
          while (c != null) {
            if (c.gen < jj_gen) c.first = null;
            c = c.next;
          }
        }
      }
      return token;
    }
    token = oldToken;
    jj_kind = kind;
    throw generateParseException();
  }

  static private final class LookaheadSuccess extends java.lang.Error { }
  final private LookaheadSuccess jj_ls = new LookaheadSuccess();
  final private boolean jj_scan_token(int kind) {
    if (jj_scanpos == jj_lastpos) {
      jj_la--;
      if (jj_scanpos.next == null) {
        jj_lastpos = jj_scanpos = jj_scanpos.next = token_source.getNextToken();
      } else {
        jj_lastpos = jj_scanpos = jj_scanpos.next;
      }
    } else {
      jj_scanpos = jj_scanpos.next;
    }
    if (jj_rescan) {
      int i = 0; Token tok = token;
      while (tok != null && tok != jj_scanpos) { i++; tok = tok.next; }
      if (tok != null) jj_add_error_token(kind, i);
    }
    if (jj_scanpos.kind != kind) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) throw jj_ls;
    return false;
  }

  final public Token getNextToken() {
    if (token.next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    jj_gen++;
    return token;
  }

  final public Token getToken(int index) {
    Token t = lookingAhead ? jj_scanpos : token;
    for (int i = 0; i < index; i++) {
      if (t.next != null) t = t.next;
      else t = t.next = token_source.getNextToken();
    }
    return t;
  }

  final private int jj_ntk() {
    if ((jj_nt=token.next) == null)
      return (jj_ntk = (token.next=token_source.getNextToken()).kind);
    else
      return (jj_ntk = jj_nt.kind);
  }

  private java.util.Vector jj_expentries = new java.util.Vector();
  private int[] jj_expentry;
  private int jj_kind = -1;
  private int[] jj_lasttokens = new int[100];
  private int jj_endpos;

  private void jj_add_error_token(int kind, int pos) {
    if (pos >= 100) return;
    if (pos == jj_endpos + 1) {
      jj_lasttokens[jj_endpos++] = kind;
    } else if (jj_endpos != 0) {
      jj_expentry = new int[jj_endpos];
      for (int i = 0; i < jj_endpos; i++) {
        jj_expentry[i] = jj_lasttokens[i];
      }
      boolean exists = false;
      for (java.util.Enumeration e = jj_expentries.elements(); e.hasMoreElements();) {
        int[] oldentry = (int[])(e.nextElement());
        if (oldentry.length == jj_expentry.length) {
          exists = true;
          for (int i = 0; i < jj_expentry.length; i++) {
            if (oldentry[i] != jj_expentry[i]) {
              exists = false;
              break;
            }
          }
          if (exists) break;
        }
      }
      if (!exists) jj_expentries.addElement(jj_expentry);
      if (pos != 0) jj_lasttokens[(jj_endpos = pos) - 1] = kind;
    }
  }

  public ParseException generateParseException() {
    jj_expentries.removeAllElements();
    boolean[] la1tokens = new boolean[104];
    for (int i = 0; i < 104; i++) {
      la1tokens[i] = false;
    }
    if (jj_kind >= 0) {
      la1tokens[jj_kind] = true;
      jj_kind = -1;
    }
    for (int i = 0; i < 181; i++) {
      if (jj_la1[i] == jj_gen) {
        for (int j = 0; j < 32; j++) {
          if ((jj_la1_0[i] & (1<<j)) != 0) {
            la1tokens[j] = true;
          }
          if ((jj_la1_1[i] & (1<<j)) != 0) {
            la1tokens[32+j] = true;
          }
          if ((jj_la1_2[i] & (1<<j)) != 0) {
            la1tokens[64+j] = true;
          }
          if ((jj_la1_3[i] & (1<<j)) != 0) {
            la1tokens[96+j] = true;
          }
        }
      }
    }
    for (int i = 0; i < 104; i++) {
      if (la1tokens[i]) {
        jj_expentry = new int[1];
        jj_expentry[0] = i;
        jj_expentries.addElement(jj_expentry);
      }
    }
    jj_endpos = 0;
    jj_rescan_token();
    jj_add_error_token(0, 0);
    int[][] exptokseq = new int[jj_expentries.size()][];
    for (int i = 0; i < jj_expentries.size(); i++) {
      exptokseq[i] = (int[])jj_expentries.elementAt(i);
    }
    return new ParseException(token, exptokseq, tokenImage);
  }

  final public void enable_tracing() {
  }

  final public void disable_tracing() {
  }

  final private void jj_rescan_token() {
    jj_rescan = true;
    for (int i = 0; i < 12; i++) {
    try {
      JJCalls p = jj_2_rtns[i];
      do {
        if (p.gen > jj_gen) {
          jj_la = p.arg; jj_lastpos = jj_scanpos = p.first;
          switch (i) {
            case 0: jj_3_1(); break;
            case 1: jj_3_2(); break;
            case 2: jj_3_3(); break;
            case 3: jj_3_4(); break;
            case 4: jj_3_5(); break;
            case 5: jj_3_6(); break;
            case 6: jj_3_7(); break;
            case 7: jj_3_8(); break;
            case 8: jj_3_9(); break;
            case 9: jj_3_10(); break;
            case 10: jj_3_11(); break;
            case 11: jj_3_12(); break;
          }
        }
        p = p.next;
      } while (p != null);
      } catch(LookaheadSuccess ls) { }
    }
    jj_rescan = false;
  }

  final private void jj_save(int index, int xla) {
    JJCalls p = jj_2_rtns[index];
    while (p.gen > jj_gen) {
      if (p.next == null) { p = p.next = new JJCalls(); break; }
      p = p.next;
    }
    p.gen = jj_gen + xla - jj_la; p.first = token; p.arg = xla;
  }

  static final class JJCalls {
    int gen;
    Token first;
    int arg;
    JJCalls next;
  }

}
